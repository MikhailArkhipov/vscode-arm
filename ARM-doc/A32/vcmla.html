<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="insn.css"/><meta name="generator" content="iform.xsl"/><title>VCMLA -- AArch32</title></head><body><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="index.html">Base Instructions</a></div></td><td><div class="topbar"><a href="fpsimdindex.html">SIMD&amp;FP Instructions</a></div></td><td><div class="topbar"><a href="a32_encindex.html">A32 Instructions by Encoding</a></div></td><td><div class="topbar"><a href="t32_encindex.html">T32 Instructions by Encoding</a></div></td><td><div class="topbar"><a href="shared_pseudocode.html">Shared Pseudocode</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h2 class="instruction-section">VCMLA</h2>
      <p class="aml">Vector Complex Multiply Accumulate.</p>
      <p class="aml">This instruction operates on complex numbers that are represented in SIMD&amp;FP registers as pairs of elements, with the more significant element holding the imaginary part of the number and the less significant element holding the real part of the number. Each element holds a floating-point value. It performs the following computation on the corresponding complex number element pairs from the two source registers and the destination register:</p>
      <ul>
        <li>Considering the complex number from the second source register on an Argand diagram, the number is rotated counterclockwise by 0, 90, 180, or 270 degrees.</li>
        <li>The two elements of the transformed complex number are multiplied by:<ul><li>The real element of the complex number from the first source register, if the transformation was a rotation by 0 or 180 degrees.</li><li>The imaginary element of the complex number from the first source register, if the transformation was a rotation by 90 or 270 degrees.</li></ul></li>
        <li>The complex number resulting from that multiplication is added to the complex number from the destination register.</li>
      </ul>
      <p class="aml">The multiplication and addition operations are performed as a fused multiply-add, without any intermediate rounding.</p>
      <p class="aml">Depending on settings in the <a class="armarm-xref" title="Reference to Armv8 ARM section">CPACR</a>, <a class="armarm-xref" title="Reference to Armv8 ARM section">NSACR</a>, and <a class="armarm-xref" title="Reference to Armv8 ARM section">HCPTR</a> registers, and the Security state and PE mode in which the instruction is executed, an attempt to execute the instruction might be <span class="arm-defined-word">undefined</span>, or trapped to Hyp mode. For more information see <a class="armarm-xref" title="Reference to Armv8 ARM section">Enabling Advanced SIMD and floating-point support</a>.</p>
    
    <p class="desc">
      It has encodings from the following instruction sets:
       A32 (
      <a href="#iclass_a1">A1</a>
      )
       and 
       T32 (
      <a href="#iclass_t1">T1</a>
      )
      .
    </p>
    <h3 class="classheading"><a id="iclass_a1"/>A1<span style="font-size:smaller;"><br/>(FEAT_FCMA)
          </span></h3><p class="desc"/><div class="regdiagram-32"><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td class="r">0</td><td colspan="2" class="lr">rot</td><td class="lr">D</td><td class="lr">1</td><td class="lr">S</td><td colspan="4" class="lr">Vn</td><td colspan="4" class="lr">Vd</td><td class="lr">1</td><td class="lr">0</td><td class="lr">0</td><td class="lr">0</td><td class="lr">N</td><td class="lr">Q</td><td class="lr">M</td><td class="lr">0</td><td colspan="4" class="lr">Vm</td></tr></tbody></table></div><div class="encoding"><h4 class="encoding">64-bit SIMD vector<span class="bitdiff"> (Q == 0)</span></h4><a id="VCMLA_A1_D"/><p class="asm-code">VCMLA{<a href="#sa_q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q&gt;</a>}.<a href="#sa_dt" title="Data type for elements of vectors (field &quot;S&quot;) [F16,F32]">&lt;dt&gt;</a> <a href="#sa_dd" title="64-bit SIMD&amp;FP destination register (field &quot;D:Vd&quot;)">&lt;Dd&gt;</a>, <a href="#sa_dn" title="First 64-bit SIMD&amp;FP source register (field &quot;N:Vn&quot;)">&lt;Dn&gt;</a>, <a href="#sa_dm" title="Second 64-bit SIMD&amp;FP source register (field &quot;M:Vm&quot;)">&lt;Dm&gt;</a>, #<a href="#sa_rotate" title="Rotation applied to elements in the second SIMD&amp;FP source register (field &quot;rot&quot;) [0,90,180,270]">&lt;rotate&gt;</a></p></div><div class="encoding"><h4 class="encoding">128-bit SIMD vector<span class="bitdiff"> (Q == 1)</span></h4><a id="VCMLA_A1_Q"/><p class="asm-code">VCMLA{<a href="#sa_q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q&gt;</a>}.<a href="#sa_dt" title="Data type for elements of vectors (field &quot;S&quot;) [F16,F32]">&lt;dt&gt;</a> <a href="#sa_qd" title="128-bit SIMD&amp;FP destination register (field &quot;D:Vd&quot;)">&lt;Qd&gt;</a>, <a href="#sa_qn" title="First 128-bit SIMD&amp;FP source register (field &quot;N:Vn&quot;)">&lt;Qn&gt;</a>, <a href="#sa_qm" title="Second 128-bit SIMD&amp;FP source register (field &quot;M:Vm&quot;)">&lt;Qm&gt;</a>, #<a href="#sa_rotate" title="Rotation applied to elements in the second SIMD&amp;FP source register (field &quot;rot&quot;) [0,90,180,270]">&lt;rotate&gt;</a></p></div><p class="pseudocode">if !<a href="shared_pseudocode.html#impl-shared.HaveFCADDExt.0" title="function: boolean HaveFCADDExt()">HaveFCADDExt</a>() then UNDEFINED;
if Q == '1' &amp;&amp; (Vd&lt;0&gt; == '1' || Vn&lt;0&gt; == '1' || Vm&lt;0&gt; == '1') then UNDEFINED;
d = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(D:Vd); n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(N:Vn); m = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(M:Vm);
esize = 16 &lt;&lt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(S);
if !<a href="shared_pseudocode.html#impl-shared.HaveFP16Ext.0" title="function: boolean HaveFP16Ext()">HaveFP16Ext</a>() &amp;&amp; esize == 16 then UNDEFINED;
elements = 64 DIV esize;
regs = if Q == '0' then 1 else 2;</p>
    <h3 class="classheading"><a id="iclass_t1"/>T1<span style="font-size:smaller;"><br/>(FEAT_FCMA)
          </span></h3><p class="desc"/><div class="regdiagram-16x2"><table class="regdiagram"><thead><tr><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td class="r">0</td><td colspan="2" class="lr">rot</td><td class="lr">D</td><td class="lr">1</td><td class="lr">S</td><td colspan="4" class="lr">Vn</td><td colspan="4" class="lr">Vd</td><td class="lr">1</td><td class="lr">0</td><td class="lr">0</td><td class="lr">0</td><td class="lr">N</td><td class="lr">Q</td><td class="lr">M</td><td class="lr">0</td><td colspan="4" class="lr">Vm</td></tr></tbody></table></div><div class="encoding"><h4 class="encoding">64-bit SIMD vector<span class="bitdiff"> (Q == 0)</span></h4><a id="VCMLA_T1_D"/><p class="asm-code">VCMLA{<a href="#sa_q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q&gt;</a>}.<a href="#sa_dt" title="Data type for elements of vectors (field &quot;S&quot;) [F16,F32]">&lt;dt&gt;</a> <a href="#sa_dd" title="64-bit SIMD&amp;FP destination register (field &quot;D:Vd&quot;)">&lt;Dd&gt;</a>, <a href="#sa_dn" title="First 64-bit SIMD&amp;FP source register (field &quot;N:Vn&quot;)">&lt;Dn&gt;</a>, <a href="#sa_dm" title="Second 64-bit SIMD&amp;FP source register (field &quot;M:Vm&quot;)">&lt;Dm&gt;</a>, #<a href="#sa_rotate" title="Rotation applied to elements in the second SIMD&amp;FP source register (field &quot;rot&quot;) [0,90,180,270]">&lt;rotate&gt;</a></p></div><div class="encoding"><h4 class="encoding">128-bit SIMD vector<span class="bitdiff"> (Q == 1)</span></h4><a id="VCMLA_T1_Q"/><p class="asm-code">VCMLA{<a href="#sa_q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q&gt;</a>}.<a href="#sa_dt" title="Data type for elements of vectors (field &quot;S&quot;) [F16,F32]">&lt;dt&gt;</a> <a href="#sa_qd" title="128-bit SIMD&amp;FP destination register (field &quot;D:Vd&quot;)">&lt;Qd&gt;</a>, <a href="#sa_qn" title="First 128-bit SIMD&amp;FP source register (field &quot;N:Vn&quot;)">&lt;Qn&gt;</a>, <a href="#sa_qm" title="Second 128-bit SIMD&amp;FP source register (field &quot;M:Vm&quot;)">&lt;Qm&gt;</a>, #<a href="#sa_rotate" title="Rotation applied to elements in the second SIMD&amp;FP source register (field &quot;rot&quot;) [0,90,180,270]">&lt;rotate&gt;</a></p></div><p class="pseudocode">if <a href="shared_pseudocode.html#impl-aarch32.InITBlock.0" title="function: boolean InITBlock()">InITBlock</a>() then UNPREDICTABLE;
if !<a href="shared_pseudocode.html#impl-shared.HaveFCADDExt.0" title="function: boolean HaveFCADDExt()">HaveFCADDExt</a>() then UNDEFINED;
if Q == '1' &amp;&amp; (Vd&lt;0&gt; == '1' || Vn&lt;0&gt; == '1' || Vm&lt;0&gt; == '1') then UNDEFINED;
d = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(D:Vd); n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(N:Vn); m = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(M:Vm);
esize = 16 &lt;&lt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(S);
if !<a href="shared_pseudocode.html#impl-shared.HaveFP16Ext.0" title="function: boolean HaveFP16Ext()">HaveFP16Ext</a>() &amp;&amp; esize == 16 then UNDEFINED;
elements = 64 DIV esize;
regs = if Q == '0' then 1 else 2;</p>
  <div class="encoding-notes"/><h3 class="explanations">Assembler Symbols</h3><div class="explanations"><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;q&gt;</td><td><a id="sa_q"/>
        
          <p class="aml">See <a class="armarm-xref" title="Reference to Armv8 ARM section">Standard assembler syntax fields</a>.</p>
        
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;dt&gt;</td><td><a id="sa_dt"/>
        <p>Is the data type for the elements of the vectors, 
      encoded in
      <q>S</q>:
        </p>
        <table class="valuetable">
          
            <thead>
              <tr>
                <th class="bitfield">S</th>
                <th class="symbol">&lt;dt&gt;</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td class="bitfield">0</td>
                <td class="symbol">F16</td>
              </tr>
              <tr>
                <td class="bitfield">1</td>
                <td class="symbol">F32</td>
              </tr>
            </tbody>
          
        </table>
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Qd&gt;</td><td><a id="sa_qd"/>
        
          <p class="aml">Is the 128-bit name of the SIMD&amp;FP destination register, encoded in the "D:Vd" field as &lt;Qd&gt;*2.</p>
        
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Qn&gt;</td><td><a id="sa_qn"/>
        
          <p class="aml">Is the 128-bit name of the first SIMD&amp;FP source register, encoded in the "N:Vn" field as &lt;Qn&gt;*2.</p>
        
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Qm&gt;</td><td><a id="sa_qm"/>
        
          <p class="aml">Is the 128-bit name of the second SIMD&amp;FP source register, encoded in the "M:Vm" field as &lt;Qm&gt;*2.</p>
        
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Dd&gt;</td><td><a id="sa_dd"/>
        
          <p class="aml">Is the 64-bit name of the SIMD&amp;FP destination register, encoded in the "D:Vd" field.</p>
        
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Dn&gt;</td><td><a id="sa_dn"/>
        
          <p class="aml">Is the 64-bit name of the first SIMD&amp;FP source register, encoded in the "N:Vn" field.</p>
        
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Dm&gt;</td><td><a id="sa_dm"/>
        
          <p class="aml">Is the 64-bit name of the second SIMD&amp;FP source register, encoded in the "M:Vm" field.</p>
        
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;rotate&gt;</td><td><a id="sa_rotate"/>
        <p>Is the rotation to be applied to elements in the second SIMD&amp;FP source register, 
      encoded in
      <q>rot</q>:
        </p>
        <table class="valuetable">
          
            <thead>
              <tr>
                <th class="bitfield">rot</th>
                <th class="symbol">&lt;rotate&gt;</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td class="bitfield">00</td>
                <td class="symbol">0</td>
              </tr>
              <tr>
                <td class="bitfield">01</td>
                <td class="symbol">90</td>
              </tr>
              <tr>
                <td class="bitfield">10</td>
                <td class="symbol">180</td>
              </tr>
              <tr>
                <td class="bitfield">11</td>
                <td class="symbol">270</td>
              </tr>
            </tbody>
          
        </table>
      </td></tr></table></div><div class="syntax-notes"/>
    <div class="ps"><a id="execute"/><h3 class="pseudocode">Operation</h3>
      <p class="pseudocode">EncodingSpecificOperations();
<a href="shared_pseudocode.html#impl-aarch32.CheckAdvSIMDEnabled.0" title="function: CheckAdvSIMDEnabled()">CheckAdvSIMDEnabled</a>();
for r = 0 to regs-1
    operand1 = <a href="shared_pseudocode.html#impl-aarch32.D.read.1" title="accessor: bits(64) D[integer n]">D</a>[n+r];
    operand2 = <a href="shared_pseudocode.html#impl-aarch32.D.read.1" title="accessor: bits(64) D[integer n]">D</a>[m+r];
    operand3 = <a href="shared_pseudocode.html#impl-aarch32.D.read.1" title="accessor: bits(64) D[integer n]">D</a>[d+r];
    for e = 0 to (elements DIV 2)-1
        bits(esize) element1;
        bits(esize) element2;
        bits(esize) element3;
        bits(esize) element4;
        case rot of
            when '00'
                element1 = <a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[operand2,e*2,esize];
                element2 = <a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[operand1,e*2,esize];
                element3 = <a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[operand2,e*2+1,esize];
                element4 = <a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[operand1,e*2,esize];
            when '01'
                element1 = <a href="shared_pseudocode.html#impl-shared.FPNeg.1" title="function: bits(N) FPNeg(bits(N) op)">FPNeg</a>(<a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[operand2,e*2+1,esize]);
                element2 = <a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[operand1,e*2+1,esize];
                element3 = <a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[operand2,e*2,esize];
                element4 = <a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[operand1,e*2+1,esize];
            when '10'
                element1 = <a href="shared_pseudocode.html#impl-shared.FPNeg.1" title="function: bits(N) FPNeg(bits(N) op)">FPNeg</a>(<a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[operand2,e*2,esize]);
                element2 = <a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[operand1,e*2,esize];
                element3 = <a href="shared_pseudocode.html#impl-shared.FPNeg.1" title="function: bits(N) FPNeg(bits(N) op)">FPNeg</a>(<a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[operand2,e*2+1,esize]);
                element4 = <a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[operand1,e*2,esize];
            when '11'
                element1 = <a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[operand2,e*2+1,esize];
                element2 = <a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[operand1,e*2+1,esize];
                element3 = <a href="shared_pseudocode.html#impl-shared.FPNeg.1" title="function: bits(N) FPNeg(bits(N) op)">FPNeg</a>(<a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[operand2,e*2,esize]);
                element4 = <a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[operand1,e*2+1,esize];
        result1 = <a href="shared_pseudocode.html#impl-shared.FPMulAdd.4" title="function: bits(N) FPMulAdd(bits(N) addend, bits(N) op1, bits(N) op2, FPCRType fpcr)">FPMulAdd</a>(<a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[operand3,e*2,esize],element2,element1, <a href="shared_pseudocode.html#impl-aarch32.StandardFPSCRValue.0" title="function: FPCRType StandardFPSCRValue()">StandardFPSCRValue</a>());
        result2 = <a href="shared_pseudocode.html#impl-shared.FPMulAdd.4" title="function: bits(N) FPMulAdd(bits(N) addend, bits(N) op1, bits(N) op2, FPCRType fpcr)">FPMulAdd</a>(<a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[operand3,e*2+1,esize],element4,element3, <a href="shared_pseudocode.html#impl-aarch32.StandardFPSCRValue.0" title="function: FPCRType StandardFPSCRValue()">StandardFPSCRValue</a>());
        <a href="shared_pseudocode.html#impl-shared.Elem.write.3" title="accessor: Elem[bits(N) &amp;vector, integer e, integer size] = bits(size) value">Elem</a>[<a href="shared_pseudocode.html#impl-aarch32.D.write.1" title="accessor: D[integer n] = bits(64) value">D</a>[d+r],e*2,esize] = result1;
        <a href="shared_pseudocode.html#impl-shared.Elem.write.3" title="accessor: Elem[bits(N) &amp;vector, integer e, integer size] = bits(size) value">Elem</a>[<a href="shared_pseudocode.html#impl-aarch32.D.write.1" title="accessor: D[integer n] = bits(64) value">D</a>[d+r],e*2+1,esize] = result2;</p>
    </div>
  <hr/><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="index.html">Base Instructions</a></div></td><td><div class="topbar"><a href="fpsimdindex.html">SIMD&amp;FP Instructions</a></div></td><td><div class="topbar"><a href="a32_encindex.html">A32 Instructions by Encoding</a></div></td><td><div class="topbar"><a href="t32_encindex.html">T32 Instructions by Encoding</a></div></td><td><div class="topbar"><a href="shared_pseudocode.html">Shared Pseudocode</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">
      Internal version only: isa v01_31, pseudocode v2023-06_rel, sve v2023-06_rel
      ; Build timestamp: 2023-07-04T18:06
    </p><p class="copyconf">
      Copyright © 2010-2023 Arm Limited or its affiliates. All rights reserved.
      This document is Non-Confidential.
    </p></body></html>

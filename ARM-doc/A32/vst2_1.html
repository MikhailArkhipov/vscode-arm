<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="insn.css"/><meta name="generator" content="iform.xsl"/><title>VST2 (single 2-element structure from one lane) -- AArch32</title></head><body><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="index.html">Base Instructions</a></div></td><td><div class="topbar"><a href="fpsimdindex.html">SIMD&amp;FP Instructions</a></div></td><td><div class="topbar"><a href="a32_encindex.html">A32 Instructions by Encoding</a></div></td><td><div class="topbar"><a href="t32_encindex.html">T32 Instructions by Encoding</a></div></td><td><div class="topbar"><a href="shared_pseudocode.html">Shared Pseudocode</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h2 class="instruction-section">VST2 (single 2-element structure from one lane)</h2>
      <p class="aml">Store single 2-element structure from one lane of two registers stores one 2-element structure to memory from corresponding elements of two registers. For details of the addressing mode, see <a class="armarm-xref" title="Reference to Armv8 ARM section">Advanced SIMD addressing mode</a>.</p>
      <p class="aml">Depending on settings in the <a class="armarm-xref" title="Reference to Armv8 ARM section">CPACR</a>, <a class="armarm-xref" title="Reference to Armv8 ARM section">NSACR</a>, and <a class="armarm-xref" title="Reference to Armv8 ARM section">HCPTR</a> registers, and the Security state and PE mode in which the instruction is executed, an attempt to execute the instruction might be <span class="arm-defined-word">undefined</span>, or trapped to Hyp mode. For more information, see <a class="armarm-xref" title="Reference to Armv8 ARM section">Enabling Advanced SIMD and floating-point support</a>.</p>
    
    <p class="desc">
      It has encodings from the following instruction sets:
       A32 (
      <a href="#iclass_a1">A1</a>
      , 
      <a href="#iclass_a2">A2</a>
       and 
      <a href="#iclass_a3">A3</a>
      )
       and 
       T32 (
      <a href="#iclass_t1">T1</a>
      , 
      <a href="#iclass_t2">T2</a>
       and 
      <a href="#iclass_t3">T3</a>
      )
      .
    </p>
    <h3 class="classheading"><a id="iclass_a1"/>A1</h3><p class="desc"/><div class="regdiagram-32"><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td class="r">1</td><td class="lr">D</td><td class="lr">0</td><td class="lr">0</td><td colspan="4" class="lr">Rn</td><td colspan="4" class="lr">Vd</td><td class="l">0</td><td class="r">0</td><td class="l">0</td><td class="r">1</td><td colspan="4" class="lr">index_align</td><td colspan="4" class="lr">Rm</td></tr><tr class="secondrow"><td colspan="9"/><td/><td/><td/><td colspan="4"/><td colspan="4"/><td colspan="2" class="droppedname">size</td><td colspan="2"/><td colspan="4"/><td colspan="4"/></tr></tbody></table></div><div class="encoding"><h4 class="encoding">Offset<span class="bitdiff"> (Rm == 1111)</span></h4><a id="VST2_1_A1_nowb"/><p class="asm-code">VST2{<a href="#sa_c_1" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c&gt;</a>}{<a href="#sa_q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q&gt;</a>}.<a href="#sa_size" title="Data size (field &quot;size&quot;) [8,16,32]">&lt;size&gt;</a> <a href="#sa_list" title="List containing the 64-bit names of two SIMD&amp;FP registers holding element (field &quot;index_align&lt;1&gt;&quot;)">&lt;list&gt;</a>, [<a href="#sa_rn" title="General-purpose base register (field &quot;Rn&quot;)">&lt;Rn&gt;</a>{:<a href="#sa_align" title="Optional alignment (field &quot;index_align&lt;0&gt;&quot;)">&lt;align&gt;</a>}]</p></div><div class="encoding"><h4 class="encoding">Post-indexed<span class="bitdiff"> (Rm == 1101)</span></h4><a id="VST2_1_A1_posti"/><p class="asm-code">VST2{<a href="#sa_c_1" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c&gt;</a>}{<a href="#sa_q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q&gt;</a>}.<a href="#sa_size" title="Data size (field &quot;size&quot;) [8,16,32]">&lt;size&gt;</a> <a href="#sa_list" title="List containing the 64-bit names of two SIMD&amp;FP registers holding element (field &quot;index_align&lt;1&gt;&quot;)">&lt;list&gt;</a>, [<a href="#sa_rn" title="General-purpose base register (field &quot;Rn&quot;)">&lt;Rn&gt;</a>{:<a href="#sa_align" title="Optional alignment (field &quot;index_align&lt;0&gt;&quot;)">&lt;align&gt;</a>}]!</p></div><div class="encoding"><h4 class="encoding">Post-indexed<span class="bitdiff"> (Rm != 11x1)</span></h4><a id="VST2_1_A1_postr"/><p class="asm-code">VST2{<a href="#sa_c_1" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c&gt;</a>}{<a href="#sa_q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q&gt;</a>}.<a href="#sa_size" title="Data size (field &quot;size&quot;) [8,16,32]">&lt;size&gt;</a> <a href="#sa_list" title="List containing the 64-bit names of two SIMD&amp;FP registers holding element (field &quot;index_align&lt;1&gt;&quot;)">&lt;list&gt;</a>, [<a href="#sa_rn" title="General-purpose base register (field &quot;Rn&quot;)">&lt;Rn&gt;</a>{:<a href="#sa_align" title="Optional alignment (field &quot;index_align&lt;0&gt;&quot;)">&lt;align&gt;</a>}], <a href="#sa_rm" title="General-purpose index register containing an offset applied after the access (field &quot;Rm&quot;)">&lt;Rm&gt;</a></p></div><p class="pseudocode">if size == '11' then UNDEFINED;
ebytes = 1;  index = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(index_align&lt;3:1&gt;);  inc = 1;
alignment = if index_align&lt;0&gt; == '0' then 1 else 2;
d = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(D:Vd);  d2 = d + inc;  n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rn);  m = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rm);
wback = (m != 15);  register_index = (m != 15 &amp;&amp; m != 13);
if n == 15 || d2 &gt; 31 then UNPREDICTABLE;</p><h3>CONSTRAINED UNPREDICTABLE behavior</h3><p>If <span class="pseudocode">d2 &gt; 31</span>, then one of the following behaviors must occur:</p><ul><li>The instruction is <span class="arm-defined-word">undefined</span>.</li><li>The instruction executes as <span class="asm-code">NOP</span>.</li><li>The memory locations specified by the instruction and the number of registers specified by the instruction become <span class="arm-defined-word">unknown</span>. If the instruction specifies writeback, then that register becomes <span class="arm-defined-word">unknown</span>. This behavior does not affect any other memory locations.</li></ul>
    <h3 class="classheading"><a id="iclass_a2"/>A2</h3><p class="desc"/><div class="regdiagram-32"><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td class="r">1</td><td class="lr">D</td><td class="lr">0</td><td class="lr">0</td><td colspan="4" class="lr">Rn</td><td colspan="4" class="lr">Vd</td><td class="l">0</td><td class="r">1</td><td class="l">0</td><td class="r">1</td><td colspan="4" class="lr">index_align</td><td colspan="4" class="lr">Rm</td></tr><tr class="secondrow"><td colspan="9"/><td/><td/><td/><td colspan="4"/><td colspan="4"/><td colspan="2" class="droppedname">size</td><td colspan="2"/><td colspan="4"/><td colspan="4"/></tr></tbody></table></div><div class="encoding"><h4 class="encoding">Offset<span class="bitdiff"> (Rm == 1111)</span></h4><a id="VST2_1_A2_nowb"/><p class="asm-code">VST2{<a href="#sa_c_1" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c&gt;</a>}{<a href="#sa_q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q&gt;</a>}.<a href="#sa_size" title="Data size (field &quot;size&quot;) [8,16,32]">&lt;size&gt;</a> <a href="#sa_list" title="List containing the 64-bit names of two SIMD&amp;FP registers holding element (field &quot;index_align&lt;1&gt;&quot;)">&lt;list&gt;</a>, [<a href="#sa_rn" title="General-purpose base register (field &quot;Rn&quot;)">&lt;Rn&gt;</a>{:<a href="#sa_align" title="Optional alignment (field &quot;index_align&lt;0&gt;&quot;)">&lt;align&gt;</a>}]</p></div><div class="encoding"><h4 class="encoding">Post-indexed<span class="bitdiff"> (Rm == 1101)</span></h4><a id="VST2_1_A2_posti"/><p class="asm-code">VST2{<a href="#sa_c_1" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c&gt;</a>}{<a href="#sa_q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q&gt;</a>}.<a href="#sa_size" title="Data size (field &quot;size&quot;) [8,16,32]">&lt;size&gt;</a> <a href="#sa_list" title="List containing the 64-bit names of two SIMD&amp;FP registers holding element (field &quot;index_align&lt;1&gt;&quot;)">&lt;list&gt;</a>, [<a href="#sa_rn" title="General-purpose base register (field &quot;Rn&quot;)">&lt;Rn&gt;</a>{:<a href="#sa_align" title="Optional alignment (field &quot;index_align&lt;0&gt;&quot;)">&lt;align&gt;</a>}]!</p></div><div class="encoding"><h4 class="encoding">Post-indexed<span class="bitdiff"> (Rm != 11x1)</span></h4><a id="VST2_1_A2_postr"/><p class="asm-code">VST2{<a href="#sa_c_1" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c&gt;</a>}{<a href="#sa_q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q&gt;</a>}.<a href="#sa_size" title="Data size (field &quot;size&quot;) [8,16,32]">&lt;size&gt;</a> <a href="#sa_list" title="List containing the 64-bit names of two SIMD&amp;FP registers holding element (field &quot;index_align&lt;1&gt;&quot;)">&lt;list&gt;</a>, [<a href="#sa_rn" title="General-purpose base register (field &quot;Rn&quot;)">&lt;Rn&gt;</a>{:<a href="#sa_align" title="Optional alignment (field &quot;index_align&lt;0&gt;&quot;)">&lt;align&gt;</a>}], <a href="#sa_rm" title="General-purpose index register containing an offset applied after the access (field &quot;Rm&quot;)">&lt;Rm&gt;</a></p></div><p class="pseudocode">if size == '11' then UNDEFINED;
ebytes = 2;  index = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(index_align&lt;3:2&gt;);
inc = if index_align&lt;1&gt; == '0' then 1 else 2;
alignment = if index_align&lt;0&gt; == '0' then 1 else 4;
d = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(D:Vd);  d2 = d + inc;  n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rn);  m = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rm);
wback = (m != 15);  register_index = (m != 15 &amp;&amp; m != 13);
if n == 15 || d2 &gt; 31 then UNPREDICTABLE;</p><h3>CONSTRAINED UNPREDICTABLE behavior</h3><p>If <span class="pseudocode">d2 &gt; 31</span>, then one of the following behaviors must occur:</p><ul><li>The instruction is <span class="arm-defined-word">undefined</span>.</li><li>The instruction executes as <span class="asm-code">NOP</span>.</li><li>The memory locations specified by the instruction and the number of registers specified by the instruction become <span class="arm-defined-word">unknown</span>. If the instruction specifies writeback, then that register becomes <span class="arm-defined-word">unknown</span>. This behavior does not affect any other memory locations.</li></ul>
    <h3 class="classheading"><a id="iclass_a3"/>A3</h3><p class="desc"/><div class="regdiagram-32"><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td class="r">1</td><td class="lr">D</td><td class="lr">0</td><td class="lr">0</td><td colspan="4" class="lr">Rn</td><td colspan="4" class="lr">Vd</td><td class="l">1</td><td class="r">0</td><td class="l">0</td><td class="r">1</td><td colspan="4" class="lr">index_align</td><td colspan="4" class="lr">Rm</td></tr><tr class="secondrow"><td colspan="9"/><td/><td/><td/><td colspan="4"/><td colspan="4"/><td colspan="2" class="droppedname">size</td><td colspan="2"/><td colspan="4"/><td colspan="4"/></tr></tbody></table></div><div class="encoding"><h4 class="encoding">Offset<span class="bitdiff"> (Rm == 1111)</span></h4><a id="VST2_1_A3_nowb"/><p class="asm-code">VST2{<a href="#sa_c_1" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c&gt;</a>}{<a href="#sa_q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q&gt;</a>}.<a href="#sa_size" title="Data size (field &quot;size&quot;) [8,16,32]">&lt;size&gt;</a> <a href="#sa_list" title="List containing the 64-bit names of two SIMD&amp;FP registers holding element (field &quot;index_align&lt;1&gt;&quot;)">&lt;list&gt;</a>, [<a href="#sa_rn" title="General-purpose base register (field &quot;Rn&quot;)">&lt;Rn&gt;</a>{:<a href="#sa_align" title="Optional alignment (field &quot;index_align&lt;0&gt;&quot;)">&lt;align&gt;</a>}]</p></div><div class="encoding"><h4 class="encoding">Post-indexed<span class="bitdiff"> (Rm == 1101)</span></h4><a id="VST2_1_A3_posti"/><p class="asm-code">VST2{<a href="#sa_c_1" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c&gt;</a>}{<a href="#sa_q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q&gt;</a>}.<a href="#sa_size" title="Data size (field &quot;size&quot;) [8,16,32]">&lt;size&gt;</a> <a href="#sa_list" title="List containing the 64-bit names of two SIMD&amp;FP registers holding element (field &quot;index_align&lt;1&gt;&quot;)">&lt;list&gt;</a>, [<a href="#sa_rn" title="General-purpose base register (field &quot;Rn&quot;)">&lt;Rn&gt;</a>{:<a href="#sa_align" title="Optional alignment (field &quot;index_align&lt;0&gt;&quot;)">&lt;align&gt;</a>}]!</p></div><div class="encoding"><h4 class="encoding">Post-indexed<span class="bitdiff"> (Rm != 11x1)</span></h4><a id="VST2_1_A3_postr"/><p class="asm-code">VST2{<a href="#sa_c_1" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c&gt;</a>}{<a href="#sa_q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q&gt;</a>}.<a href="#sa_size" title="Data size (field &quot;size&quot;) [8,16,32]">&lt;size&gt;</a> <a href="#sa_list" title="List containing the 64-bit names of two SIMD&amp;FP registers holding element (field &quot;index_align&lt;1&gt;&quot;)">&lt;list&gt;</a>, [<a href="#sa_rn" title="General-purpose base register (field &quot;Rn&quot;)">&lt;Rn&gt;</a>{:<a href="#sa_align" title="Optional alignment (field &quot;index_align&lt;0&gt;&quot;)">&lt;align&gt;</a>}], <a href="#sa_rm" title="General-purpose index register containing an offset applied after the access (field &quot;Rm&quot;)">&lt;Rm&gt;</a></p></div><p class="pseudocode">if size == '11' then UNDEFINED;
if index_align&lt;1&gt; != '0' then UNDEFINED;
ebytes = 4;  index = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(index_align&lt;3&gt;);
inc = if index_align&lt;2&gt; == '0' then 1 else 2;
alignment = if index_align&lt;0&gt; == '0' then 1 else 8;
d = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(D:Vd);  d2 = d + inc;  n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rn);  m = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rm);
wback = (m != 15);  register_index = (m != 15 &amp;&amp; m != 13);
if n == 15 || d2 &gt; 31 then UNPREDICTABLE;</p><h3>CONSTRAINED UNPREDICTABLE behavior</h3><p>If <span class="pseudocode">d2 &gt; 31</span>, then one of the following behaviors must occur:</p><ul><li>The instruction is <span class="arm-defined-word">undefined</span>.</li><li>The instruction executes as <span class="asm-code">NOP</span>.</li><li>The memory locations specified by the instruction and the number of registers specified by the instruction become <span class="arm-defined-word">unknown</span>. If the instruction specifies writeback, then that register becomes <span class="arm-defined-word">unknown</span>. This behavior does not affect any other memory locations.</li></ul>
    <h3 class="classheading"><a id="iclass_t1"/>T1</h3><p class="desc"/><div class="regdiagram-16x2"><table class="regdiagram"><thead><tr><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td class="r">1</td><td class="lr">D</td><td class="lr">0</td><td class="lr">0</td><td colspan="4" class="lr">Rn</td><td colspan="4" class="lr">Vd</td><td class="l">0</td><td class="r">0</td><td class="l">0</td><td class="r">1</td><td colspan="4" class="lr">index_align</td><td colspan="4" class="lr">Rm</td></tr><tr class="secondrow"><td colspan="9"/><td/><td/><td/><td colspan="4"/><td colspan="4"/><td colspan="2" class="droppedname">size</td><td colspan="2"/><td colspan="4"/><td colspan="4"/></tr></tbody></table></div><div class="encoding"><h4 class="encoding">Offset<span class="bitdiff"> (Rm == 1111)</span></h4><a id="VST2_1_T1_nowb"/><p class="asm-code">VST2{<a href="#sa_c" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c&gt;</a>}{<a href="#sa_q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q&gt;</a>}.<a href="#sa_size" title="Data size (field &quot;size&quot;) [8,16,32]">&lt;size&gt;</a> <a href="#sa_list" title="List containing the 64-bit names of two SIMD&amp;FP registers holding element (field &quot;index_align&lt;1&gt;&quot;)">&lt;list&gt;</a>, [<a href="#sa_rn" title="General-purpose base register (field &quot;Rn&quot;)">&lt;Rn&gt;</a>{:<a href="#sa_align" title="Optional alignment (field &quot;index_align&lt;0&gt;&quot;)">&lt;align&gt;</a>}]</p></div><div class="encoding"><h4 class="encoding">Post-indexed<span class="bitdiff"> (Rm == 1101)</span></h4><a id="VST2_1_T1_posti"/><p class="asm-code">VST2{<a href="#sa_c" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c&gt;</a>}{<a href="#sa_q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q&gt;</a>}.<a href="#sa_size" title="Data size (field &quot;size&quot;) [8,16,32]">&lt;size&gt;</a> <a href="#sa_list" title="List containing the 64-bit names of two SIMD&amp;FP registers holding element (field &quot;index_align&lt;1&gt;&quot;)">&lt;list&gt;</a>, [<a href="#sa_rn" title="General-purpose base register (field &quot;Rn&quot;)">&lt;Rn&gt;</a>{:<a href="#sa_align" title="Optional alignment (field &quot;index_align&lt;0&gt;&quot;)">&lt;align&gt;</a>}]!</p></div><div class="encoding"><h4 class="encoding">Post-indexed<span class="bitdiff"> (Rm != 11x1)</span></h4><a id="VST2_1_T1_postr"/><p class="asm-code">VST2{<a href="#sa_c" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c&gt;</a>}{<a href="#sa_q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q&gt;</a>}.<a href="#sa_size" title="Data size (field &quot;size&quot;) [8,16,32]">&lt;size&gt;</a> <a href="#sa_list" title="List containing the 64-bit names of two SIMD&amp;FP registers holding element (field &quot;index_align&lt;1&gt;&quot;)">&lt;list&gt;</a>, [<a href="#sa_rn" title="General-purpose base register (field &quot;Rn&quot;)">&lt;Rn&gt;</a>{:<a href="#sa_align" title="Optional alignment (field &quot;index_align&lt;0&gt;&quot;)">&lt;align&gt;</a>}], <a href="#sa_rm" title="General-purpose index register containing an offset applied after the access (field &quot;Rm&quot;)">&lt;Rm&gt;</a></p></div><p class="pseudocode">if size == '11' then UNDEFINED;
ebytes = 1;  index = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(index_align&lt;3:1&gt;);  inc = 1;
alignment = if index_align&lt;0&gt; == '0' then 1 else 2;
d = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(D:Vd);  d2 = d + inc;  n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rn);  m = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rm);
wback = (m != 15);  register_index = (m != 15 &amp;&amp; m != 13);
if n == 15 || d2 &gt; 31 then UNPREDICTABLE;</p><h3>CONSTRAINED UNPREDICTABLE behavior</h3><p>If <span class="pseudocode">d2 &gt; 31</span>, then one of the following behaviors must occur:</p><ul><li>The instruction is <span class="arm-defined-word">undefined</span>.</li><li>The instruction executes as <span class="asm-code">NOP</span>.</li><li>The memory locations specified by the instruction and the number of registers specified by the instruction become <span class="arm-defined-word">unknown</span>. If the instruction specifies writeback, then that register becomes <span class="arm-defined-word">unknown</span>. This behavior does not affect any other memory locations.</li></ul>
    <h3 class="classheading"><a id="iclass_t2"/>T2</h3><p class="desc"/><div class="regdiagram-16x2"><table class="regdiagram"><thead><tr><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td class="r">1</td><td class="lr">D</td><td class="lr">0</td><td class="lr">0</td><td colspan="4" class="lr">Rn</td><td colspan="4" class="lr">Vd</td><td class="l">0</td><td class="r">1</td><td class="l">0</td><td class="r">1</td><td colspan="4" class="lr">index_align</td><td colspan="4" class="lr">Rm</td></tr><tr class="secondrow"><td colspan="9"/><td/><td/><td/><td colspan="4"/><td colspan="4"/><td colspan="2" class="droppedname">size</td><td colspan="2"/><td colspan="4"/><td colspan="4"/></tr></tbody></table></div><div class="encoding"><h4 class="encoding">Offset<span class="bitdiff"> (Rm == 1111)</span></h4><a id="VST2_1_T2_nowb"/><p class="asm-code">VST2{<a href="#sa_c" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c&gt;</a>}{<a href="#sa_q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q&gt;</a>}.<a href="#sa_size" title="Data size (field &quot;size&quot;) [8,16,32]">&lt;size&gt;</a> <a href="#sa_list" title="List containing the 64-bit names of two SIMD&amp;FP registers holding element (field &quot;index_align&lt;1&gt;&quot;)">&lt;list&gt;</a>, [<a href="#sa_rn" title="General-purpose base register (field &quot;Rn&quot;)">&lt;Rn&gt;</a>{:<a href="#sa_align" title="Optional alignment (field &quot;index_align&lt;0&gt;&quot;)">&lt;align&gt;</a>}]</p></div><div class="encoding"><h4 class="encoding">Post-indexed<span class="bitdiff"> (Rm == 1101)</span></h4><a id="VST2_1_T2_posti"/><p class="asm-code">VST2{<a href="#sa_c" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c&gt;</a>}{<a href="#sa_q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q&gt;</a>}.<a href="#sa_size" title="Data size (field &quot;size&quot;) [8,16,32]">&lt;size&gt;</a> <a href="#sa_list" title="List containing the 64-bit names of two SIMD&amp;FP registers holding element (field &quot;index_align&lt;1&gt;&quot;)">&lt;list&gt;</a>, [<a href="#sa_rn" title="General-purpose base register (field &quot;Rn&quot;)">&lt;Rn&gt;</a>{:<a href="#sa_align" title="Optional alignment (field &quot;index_align&lt;0&gt;&quot;)">&lt;align&gt;</a>}]!</p></div><div class="encoding"><h4 class="encoding">Post-indexed<span class="bitdiff"> (Rm != 11x1)</span></h4><a id="VST2_1_T2_postr"/><p class="asm-code">VST2{<a href="#sa_c" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c&gt;</a>}{<a href="#sa_q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q&gt;</a>}.<a href="#sa_size" title="Data size (field &quot;size&quot;) [8,16,32]">&lt;size&gt;</a> <a href="#sa_list" title="List containing the 64-bit names of two SIMD&amp;FP registers holding element (field &quot;index_align&lt;1&gt;&quot;)">&lt;list&gt;</a>, [<a href="#sa_rn" title="General-purpose base register (field &quot;Rn&quot;)">&lt;Rn&gt;</a>{:<a href="#sa_align" title="Optional alignment (field &quot;index_align&lt;0&gt;&quot;)">&lt;align&gt;</a>}], <a href="#sa_rm" title="General-purpose index register containing an offset applied after the access (field &quot;Rm&quot;)">&lt;Rm&gt;</a></p></div><p class="pseudocode">if size == '11' then UNDEFINED;
ebytes = 2;  index = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(index_align&lt;3:2&gt;);
inc = if index_align&lt;1&gt; == '0' then 1 else 2;
alignment = if index_align&lt;0&gt; == '0' then 1 else 4;
d = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(D:Vd);  d2 = d + inc;  n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rn);  m = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rm);
wback = (m != 15);  register_index = (m != 15 &amp;&amp; m != 13);
if n == 15 || d2 &gt; 31 then UNPREDICTABLE;</p><h3>CONSTRAINED UNPREDICTABLE behavior</h3><p>If <span class="pseudocode">d2 &gt; 31</span>, then one of the following behaviors must occur:</p><ul><li>The instruction is <span class="arm-defined-word">undefined</span>.</li><li>The instruction executes as <span class="asm-code">NOP</span>.</li><li>The memory locations specified by the instruction and the number of registers specified by the instruction become <span class="arm-defined-word">unknown</span>. If the instruction specifies writeback, then that register becomes <span class="arm-defined-word">unknown</span>. This behavior does not affect any other memory locations.</li></ul>
    <h3 class="classheading"><a id="iclass_t3"/>T3</h3><p class="desc"/><div class="regdiagram-16x2"><table class="regdiagram"><thead><tr><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td class="r">1</td><td class="lr">D</td><td class="lr">0</td><td class="lr">0</td><td colspan="4" class="lr">Rn</td><td colspan="4" class="lr">Vd</td><td class="l">1</td><td class="r">0</td><td class="l">0</td><td class="r">1</td><td colspan="4" class="lr">index_align</td><td colspan="4" class="lr">Rm</td></tr><tr class="secondrow"><td colspan="9"/><td/><td/><td/><td colspan="4"/><td colspan="4"/><td colspan="2" class="droppedname">size</td><td colspan="2"/><td colspan="4"/><td colspan="4"/></tr></tbody></table></div><div class="encoding"><h4 class="encoding">Offset<span class="bitdiff"> (Rm == 1111)</span></h4><a id="VST2_1_T3_nowb"/><p class="asm-code">VST2{<a href="#sa_c" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c&gt;</a>}{<a href="#sa_q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q&gt;</a>}.<a href="#sa_size" title="Data size (field &quot;size&quot;) [8,16,32]">&lt;size&gt;</a> <a href="#sa_list" title="List containing the 64-bit names of two SIMD&amp;FP registers holding element (field &quot;index_align&lt;1&gt;&quot;)">&lt;list&gt;</a>, [<a href="#sa_rn" title="General-purpose base register (field &quot;Rn&quot;)">&lt;Rn&gt;</a>{:<a href="#sa_align" title="Optional alignment (field &quot;index_align&lt;0&gt;&quot;)">&lt;align&gt;</a>}]</p></div><div class="encoding"><h4 class="encoding">Post-indexed<span class="bitdiff"> (Rm == 1101)</span></h4><a id="VST2_1_T3_posti"/><p class="asm-code">VST2{<a href="#sa_c" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c&gt;</a>}{<a href="#sa_q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q&gt;</a>}.<a href="#sa_size" title="Data size (field &quot;size&quot;) [8,16,32]">&lt;size&gt;</a> <a href="#sa_list" title="List containing the 64-bit names of two SIMD&amp;FP registers holding element (field &quot;index_align&lt;1&gt;&quot;)">&lt;list&gt;</a>, [<a href="#sa_rn" title="General-purpose base register (field &quot;Rn&quot;)">&lt;Rn&gt;</a>{:<a href="#sa_align" title="Optional alignment (field &quot;index_align&lt;0&gt;&quot;)">&lt;align&gt;</a>}]!</p></div><div class="encoding"><h4 class="encoding">Post-indexed<span class="bitdiff"> (Rm != 11x1)</span></h4><a id="VST2_1_T3_postr"/><p class="asm-code">VST2{<a href="#sa_c" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c&gt;</a>}{<a href="#sa_q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q&gt;</a>}.<a href="#sa_size" title="Data size (field &quot;size&quot;) [8,16,32]">&lt;size&gt;</a> <a href="#sa_list" title="List containing the 64-bit names of two SIMD&amp;FP registers holding element (field &quot;index_align&lt;1&gt;&quot;)">&lt;list&gt;</a>, [<a href="#sa_rn" title="General-purpose base register (field &quot;Rn&quot;)">&lt;Rn&gt;</a>{:<a href="#sa_align" title="Optional alignment (field &quot;index_align&lt;0&gt;&quot;)">&lt;align&gt;</a>}], <a href="#sa_rm" title="General-purpose index register containing an offset applied after the access (field &quot;Rm&quot;)">&lt;Rm&gt;</a></p></div><p class="pseudocode">if size == '11' then UNDEFINED;
if index_align&lt;1&gt; != '0' then UNDEFINED;
ebytes = 4;  index = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(index_align&lt;3&gt;);
inc = if index_align&lt;2&gt; == '0' then 1 else 2;
alignment = if index_align&lt;0&gt; == '0' then 1 else 8;
d = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(D:Vd);  d2 = d + inc;  n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rn);  m = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rm);
wback = (m != 15);  register_index = (m != 15 &amp;&amp; m != 13);
if n == 15 || d2 &gt; 31 then UNPREDICTABLE;</p><h3>CONSTRAINED UNPREDICTABLE behavior</h3><p>If <span class="pseudocode">d2 &gt; 31</span>, then one of the following behaviors must occur:</p><ul><li>The instruction is <span class="arm-defined-word">undefined</span>.</li><li>The instruction executes as <span class="asm-code">NOP</span>.</li><li>The memory locations specified by the instruction and the number of registers specified by the instruction become <span class="arm-defined-word">unknown</span>. If the instruction specifies writeback, then that register becomes <span class="arm-defined-word">unknown</span>. This behavior does not affect any other memory locations.</li></ul>
  <div class="encoding-notes">
      <p class="aml">For more information about the <span class="arm-defined-word">constrained unpredictable</span> behavior of this instruction, see <a class="armarm-xref" title="Reference to Armv8 ARM section">Architectural Constraints on UNPREDICTABLE behaviors</a>, and particularly <a class="armarm-xref" title="Reference to Armv8 ARM section">VST2 (single 2-element structure from one lane)</a>.</p>
    </div><h3 class="explanations">Assembler Symbols</h3><div class="explanations"><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;c&gt;</td><td><a id="sa_c_1"/>
        
          
        
        
          <p class="aml">For encoding A1, A2 and A3: see <a class="armarm-xref" title="Reference to Armv8 ARM section">Standard assembler syntax fields</a>. This encoding must be unconditional.</p>
        
      </td></tr><tr><td/><td><a id="sa_c"/>
        
          
        
        
          <p class="aml">For encoding T1, T2 and T3: see <a class="armarm-xref" title="Reference to Armv8 ARM section">Standard assembler syntax fields</a>.</p>
        
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;q&gt;</td><td><a id="sa_q"/>
        
          <p class="aml">See <a class="armarm-xref" title="Reference to Armv8 ARM section">Standard assembler syntax fields</a>.</p>
        
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;size&gt;</td><td><a id="sa_size"/>
        <p>Is the data size, 
      encoded in
      <q>size</q>:
        </p>
        <table class="valuetable">
          
            <thead>
              <tr>
                <th class="bitfield">size</th>
                <th class="symbol">&lt;size&gt;</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td class="bitfield">00</td>
                <td class="symbol">8</td>
              </tr>
              <tr>
                <td class="bitfield">01</td>
                <td class="symbol">16</td>
              </tr>
              <tr>
                <td class="bitfield">10</td>
                <td class="symbol">32</td>
              </tr>
            </tbody>
          
        </table>
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;list&gt;</td><td><a id="sa_list"/>
        
          <p class="aml">Is a list containing the 64-bit names of the two SIMD&amp;FP registers holding the element.</p>
          <p class="aml">The list must be one of:</p>
          <dl>
            <dt>{ &lt;Dd&gt;[&lt;index&gt;], &lt;Dd+1&gt;[&lt;index&gt;] }</dt><dd>Single-spaced registers, encoded as "spacing" = 0.</dd>
            <dt>{ &lt;Dd&gt;[&lt;index&gt;], &lt;Dd+2&gt;[&lt;index&gt;] }</dt><dd>Double-spaced registers, encoded as "spacing" = 1. Not permitted when &lt;size&gt; == 8.</dd>
          </dl>
          <p class="aml">The encoding of "spacing" depends on &lt;size&gt;:</p>
          <dl>
            <dt>&lt;size&gt; == 16</dt><dd>"spacing" is encoded in the "index_align&lt;1&gt;" field.</dd>
            <dt>&lt;size&gt; == 32</dt><dd>"spacing" is encoded in the "index_align&lt;2&gt;" field.</dd>
          </dl>
          <p class="aml">The register &lt;Dd&gt; is encoded in the "D:Vd" field.</p>
          <p class="aml">The permitted values and encoding of &lt;index&gt; depend on &lt;size&gt;:</p>
          <dl>
            <dt>&lt;size&gt; == 8</dt><dd>&lt;index&gt; is in the range 0 to 7, encoded in the "index_align&lt;3:1&gt;" field.</dd>
            <dt>&lt;size&gt; == 16</dt><dd>&lt;index&gt; is in the range 0 to 3, encoded in the "index_align&lt;3:2&gt;" field.</dd>
            <dt>&lt;size&gt; == 32</dt><dd>&lt;index&gt; is 0 or 1, encoded in the "index_align&lt;3&gt;" field.</dd>
          </dl>
        
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Rn&gt;</td><td><a id="sa_rn"/>
        
          <p class="aml">Is the general-purpose base register, encoded in the "Rn" field.</p>
        
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;align&gt;</td><td><a id="sa_align"/>
        
          <p class="aml">Is the optional alignment.</p>
          <p class="aml">Whenever &lt;align&gt; is omitted, the standard alignment is used, see <a class="armarm-xref" title="Reference to Armv8 ARM section">Unaligned data access</a>, and the encoding depends on &lt;size&gt;:</p>
          <dl>
            <dt>&lt;size&gt; == 8</dt><dd>Encoded in the "index_align&lt;0&gt;" field as 0.</dd>
            <dt>&lt;size&gt; == 16</dt><dd>Encoded in the "index_align&lt;0&gt;" field as 0.</dd>
            <dt>&lt;size&gt; == 32</dt><dd>Encoded in the "index_align&lt;1:0&gt;" field as 0b00.</dd>
          </dl>
          <p class="aml">Whenever &lt;align&gt; is present, the permitted values and encoding depend on &lt;size&gt;:</p>
          <dl>
            <dt>&lt;size&gt; == 8</dt><dd>&lt;align&gt; is 16, meaning 16-bit alignment, encoded in the "index_align&lt;0&gt;" field as 1.</dd>
            <dt>&lt;size&gt; == 16</dt><dd>&lt;align&gt; is 32, meaning 32-bit alignment, encoded in the "index_align&lt;0&gt;" field as 1.</dd>
            <dt>&lt;size&gt; == 32</dt><dd>&lt;align&gt; is 64, meaning 64-bit alignment, encoded in the "index_align&lt;1:0&gt;" field as 0b01.</dd>
          </dl>
          <p class="aml">: is the preferred separator before the &lt;align&gt; value, but the alignment can be specified as @&lt;align&gt;, see <a class="armarm-xref" title="Reference to Armv8 ARM section">Advanced SIMD addressing mode</a>.</p>
        
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Rm&gt;</td><td><a id="sa_rm"/>
        
          <p class="aml">Is the general-purpose index register containing an offset applied after the access, encoded in the "Rm" field.</p>
        
      </td></tr></table></div><div class="syntax-notes">
      <p class="aml">For more information about the variants of this instruction, see <a class="armarm-xref" title="Reference to Armv8 ARM section">Advanced SIMD addressing mode</a>.</p>
    </div>
    <div class="ps"><a id="execute"/><h3 class="pseudocode">Operation</h3>
      <p class="pseudocode">if <a href="shared_pseudocode.html#impl-aarch32.ConditionPassed.0" title="function: boolean ConditionPassed()">ConditionPassed</a>() then
    EncodingSpecificOperations();
    <a href="shared_pseudocode.html#impl-aarch32.CheckAdvSIMDEnabled.0" title="function: CheckAdvSIMDEnabled()">CheckAdvSIMDEnabled</a>();

    address = <a href="shared_pseudocode.html#impl-aarch32.R.read.1" title="accessor: bits(32) R[integer n]">R</a>[n];

    boolean nontemporal = FALSE;
    boolean tagchecked  = FALSE;
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, boolean ispair, boolean highestaddressfirst, MPAMinfo mpam )">AccessDescriptor</a> accdesc = <a href="shared_pseudocode.html#impl-shared.CreateAccDescASIMD.3" title="function: AccessDescriptor CreateAccDescASIMD(MemOp memop, boolean nontemporal, boolean tagchecked)">CreateAccDescASIMD</a>(<a href="shared_pseudocode.html#MemOp_STORE" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp_STORE</a>, nontemporal, tagchecked);
    if !<a href="shared_pseudocode.html#impl-shared.IsAligned.2" title="function: boolean IsAligned(bits(N) x, integer y)">IsAligned</a>(address, alignment) then
        <a href="shared_pseudocode.html#AArch32.Abort.2" title="function: AArch32.Abort(bits(32) vaddress, FaultRecord fault)">AArch32.Abort</a>(address, <a href="shared_pseudocode.html#impl-shared.AlignmentFault.1" title="function: FaultRecord AlignmentFault(AccessDescriptor accdesc)">AlignmentFault</a>(accdesc));

    <a href="shared_pseudocode.html#impl-aarch32.MemU.write.2" title="accessor: MemU[bits(32) address, integer size] = bits(8*size) value">MemU</a>[address,       ebytes] = <a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[<a href="shared_pseudocode.html#impl-aarch32.D.read.1" title="accessor: bits(64) D[integer n]">D</a>[d], index,8*ebytes];
    <a href="shared_pseudocode.html#impl-aarch32.MemU.write.2" title="accessor: MemU[bits(32) address, integer size] = bits(8*size) value">MemU</a>[address+ebytes,ebytes] = <a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[<a href="shared_pseudocode.html#impl-aarch32.D.read.1" title="accessor: bits(64) D[integer n]">D</a>[d2],index,8*ebytes];
    if wback then
        if register_index then
            <a href="shared_pseudocode.html#impl-aarch32.R.write.1" title="accessor: R[integer n] = bits(32) value">R</a>[n] = <a href="shared_pseudocode.html#impl-aarch32.R.read.1" title="accessor: bits(32) R[integer n]">R</a>[n] + <a href="shared_pseudocode.html#impl-aarch32.R.read.1" title="accessor: bits(32) R[integer n]">R</a>[m];
        else
            <a href="shared_pseudocode.html#impl-aarch32.R.write.1" title="accessor: R[integer n] = bits(32) value">R</a>[n] = <a href="shared_pseudocode.html#impl-aarch32.R.read.1" title="accessor: bits(32) R[integer n]">R</a>[n] + 2*ebytes;</p>
    </div>
  <h3>Operational information</h3>
    <p class="aml">If CPSR.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.</p>
  <hr/><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="index.html">Base Instructions</a></div></td><td><div class="topbar"><a href="fpsimdindex.html">SIMD&amp;FP Instructions</a></div></td><td><div class="topbar"><a href="a32_encindex.html">A32 Instructions by Encoding</a></div></td><td><div class="topbar"><a href="t32_encindex.html">T32 Instructions by Encoding</a></div></td><td><div class="topbar"><a href="shared_pseudocode.html">Shared Pseudocode</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">
      Internal version only: isa v01_31, pseudocode v2023-06_rel, sve v2023-06_rel
      ; Build timestamp: 2023-07-04T18:06
    </p><p class="copyconf">
      Copyright Â© 2010-2023 Arm Limited or its affiliates. All rights reserved.
      This document is Non-Confidential.
    </p></body></html>

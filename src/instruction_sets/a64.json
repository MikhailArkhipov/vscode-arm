[
  {
    "name": "ADDHN",
    "doc": "Add returning High Narrow. This instruction adds each vector element in the first source SIMD&amp;FP register to the corresponding vector element in the second source SIMD&amp;FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&amp;FP register."
  },
  {
    "name": "ADDP",
    "doc": "Add Pair of elements (scalar). This instruction adds two vector elements in the source SIMD&amp;FP register and writes the scalar result into the destination SIMD&amp;FP register."
  },
  {
    "name": "ADDS",
    "doc": "Add (extended register), setting flags, adds a register value and a sign or zero-extended register value, followed by an optional left shift amount, and writes the result to the destination register. The argument that is extended from the &lt;Rm&gt; register can be a byte, halfword, word, or doubleword. It updates the condition flags based on the result."
  },
  {
    "name": "ADD",
    "doc": "Add (extended register) adds a register value and a sign or zero-extended register value, followed by an optional left shift amount, and writes the result to the destination register. The argument that is extended from the &lt;Rm&gt; register can be a byte, halfword, word, or doubleword."
  },
  {
    "name": "ANDS",
    "doc": "Bitwise AND (immediate), setting flags, performs a bitwise AND of a register value and an immediate value, and writes the result to the destination register. It updates the condition flags based on the result."
  },
  {
    "name": "AND",
    "doc": "Bitwise AND (vector). This instruction performs a bitwise AND between the two source SIMD&amp;FP registers, and writes the result to the destination SIMD&amp;FP register."
  },
  {
    "name": "ASR",
    "doc": "Arithmetic Shift Right (register) shifts a register value right by a variable number of bits, shifting in copies of its sign bit, and writes the result to the destination register. The remainder obtained by dividing the second source register by the data size defines the number of bits by which the first source register is right-shifted."
  },
  {
    "name": "AUTDA",
    "doc": "Authenticate Data address, using key A. This instruction authenticates a data address, using a modifier and key A."
  },
  {
    "name": "AUTDB",
    "doc": "Authenticate Data address, using key B. This instruction authenticates a data address, using a modifier and key B."
  },
  {
    "name": "AUTIA",
    "doc": "Authenticate Instruction address, using key A. This instruction authenticates an instruction address, using a modifier and key A."
  },
  {
    "name": "AUTIASP",
    "doc": "Authenticate Instruction address, using key A. This instruction authenticates an instruction address, using a modifier and key A."
  },
  {
    "name": "AUTIAZ",
    "doc": "Authenticate Instruction address, using key A. This instruction authenticates an instruction address, using a modifier and key A."
  },
  {
    "name": "AUTIB",
    "doc": "Authenticate Instruction address, using key B. This instruction authenticates an instruction address, using a modifier and key B."
  },
  {
    "name": "AUTIBSP",
    "doc": "Authenticate Instruction address, using key B. This instruction authenticates an instruction address, using a modifier and key B."
  },
  {
    "name": "AUTIBZ",
    "doc": "Authenticate Instruction address, using key B. This instruction authenticates an instruction address, using a modifier and key B."
  },
  {
    "name": "BC",
    "doc": "Branch Consistent conditionally to a label at a PC-relative offset, with a hint that this branch will behave very consistently and is very unlikely to change direction."
  },
  {
    "name": "BFADD",
    "doc": "BFloat16 floating-point add vectors (predicated)"
  },
  {
    "name": "BFCVTN",
    "doc": "Floating-point convert from single-precision to BFloat16 format (vector) reads each single-precision element in the SIMD&amp;FP source vector, converts each value to BFloat16 format, and writes the results in the lower or upper half of the SIMD&amp;FP destination vector. The result elements are half the width of the source elements."
  },
  {
    "name": "BFDOT",
    "doc": "BFloat16 floating-point dot product (vector, by element). This instruction delimits the source vectors into pairs of BFloat16 elements. The BFloat16 pair within the second source vector is specified using an immediate index. The index range is from 0 to 3 inclusive."
  },
  {
    "name": "BFMAXNM",
    "doc": "Multi-vector BFloat16 floating-point maximum number by vector"
  },
  {
    "name": "BFMAX",
    "doc": "Multi-vector BFloat16 floating-point maximum by vector"
  },
  {
    "name": "BFMINNM",
    "doc": "Multi-vector BFloat16 floating-point minimum number by vector"
  },
  {
    "name": "BFMIN",
    "doc": "Multi-vector BFloat16 floating-point minimum by vector"
  },
  {
    "name": "BFMLALB",
    "doc": "BFloat16 floating-point multiply-add long to single-precision (bottom)"
  },
  {
    "name": "BFMLALT",
    "doc": "BFloat16 floating-point multiply-add long to single-precision (top)"
  },
  {
    "name": "BFMLAL",
    "doc": "Multi-vector BFloat16 floating-point multiply-add long by indexed element"
  },
  {
    "name": "BFMLA",
    "doc": "Multi-vector BFloat16 floating-point fused multiply-add by indexed element"
  },
  {
    "name": "BFMLSLB",
    "doc": "BFloat16 floating-point multiply-subtract long from single-precision (bottom)"
  },
  {
    "name": "BFMLSLT",
    "doc": "BFloat16 floating-point multiply-subtract long from single-precision (top)"
  },
  {
    "name": "BFMLSL",
    "doc": "Multi-vector BFloat16 floating-point multiply-subtract long by indexed element"
  },
  {
    "name": "BFMLS",
    "doc": "Multi-vector BFloat16 floating-point fused multiply-subtract by indexed element"
  },
  {
    "name": "BFMOPA",
    "doc": "BFloat16 sum of outer products and accumulate"
  },
  {
    "name": "BFMOPS",
    "doc": "BFloat16 sum of outer products and subtract"
  },
  {
    "name": "BFMUL",
    "doc": "BFloat16 floating-point multiply vectors (predicated)"
  },
  {
    "name": "BFSUB",
    "doc": "BFloat16 floating-point subtract vectors (predicated)"
  },
  {
    "name": "BICS",
    "doc": "Bitwise Bit Clear (shifted register), setting flags, performs a bitwise AND of a register value and the complement of an optionally-shifted register value, and writes the result to the destination register. It updates the condition flags based on the result."
  },
  {
    "name": "BIC",
    "doc": "Bitwise bit Clear (vector, immediate). This instruction reads each vector element from the destination SIMD&amp;FP register, performs a bitwise AND between each result and the complement of an immediate constant, places the result into a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "BLRAA",
    "doc": "Branch with Link to Register, with pointer authentication. This instruction authenticates the address in the general-purpose register that is specified by &lt;Xn&gt;, using a modifier and the specified key, and calls a subroutine at the authenticated address, setting register X30 to PC+4."
  },
  {
    "name": "BLRAAZ",
    "doc": "Branch with Link to Register, with pointer authentication. This instruction authenticates the address in the general-purpose register that is specified by &lt;Xn&gt;, using a modifier and the specified key, and calls a subroutine at the authenticated address, setting register X30 to PC+4."
  },
  {
    "name": "BLRAB",
    "doc": "Branch with Link to Register, with pointer authentication. This instruction authenticates the address in the general-purpose register that is specified by &lt;Xn&gt;, using a modifier and the specified key, and calls a subroutine at the authenticated address, setting register X30 to PC+4."
  },
  {
    "name": "BRAA",
    "doc": "Branch to Register, with pointer authentication. This instruction authenticates the address in the general-purpose register that is specified by &lt;Xn&gt;, using a modifier and the specified key, and branches to the authenticated address."
  },
  {
    "name": "BRAAZ",
    "doc": "Branch to Register, with pointer authentication. This instruction authenticates the address in the general-purpose register that is specified by &lt;Xn&gt;, using a modifier and the specified key, and branches to the authenticated address."
  },
  {
    "name": "BRAB",
    "doc": "Branch to Register, with pointer authentication. This instruction authenticates the address in the general-purpose register that is specified by &lt;Xn&gt;, using a modifier and the specified key, and branches to the authenticated address."
  },
  {
    "name": "BSL",
    "doc": "Bitwise select with first input inverted"
  },
  {
    "name": "B",
    "doc": "Branch conditionally to a label at a PC-relative offset, with a hint that this is not a subroutine call or return."
  },
  {
    "name": "CAS",
    "doc": "Compare and Swap word or doubleword in memory reads a 32-bit word or 64-bit doubleword from memory, and compares it against the value held in a first register. If the comparison is equal, the value in a second register is written to memory. If the write is performed, the read and write occur atomically such that no other modification of the memory location can take place between the read and write."
  },
  {
    "name": "CASA",
    "doc": "Compare and Swap word or doubleword in memory reads a 32-bit word or 64-bit doubleword from memory, and compares it against the value held in a first register. If the comparison is equal, the value in a second register is written to memory. If the write is performed, the read and write occur atomically such that no other modification of the memory location can take place between the read and write."
  },
  {
    "name": "CASAL",
    "doc": "Compare and Swap word or doubleword in memory reads a 32-bit word or 64-bit doubleword from memory, and compares it against the value held in a first register. If the comparison is equal, the value in a second register is written to memory. If the write is performed, the read and write occur atomically such that no other modification of the memory location can take place between the read and write."
  },
  {
    "name": "CASB",
    "doc": "Compare and Swap byte in memory reads an 8-bit byte from memory, and compares it against the value held in a first register. If the comparison is equal, the value in a second register is written to memory. If the write is performed, the read and write occur atomically such that no other modification of the memory location can take place between the read and write."
  },
  {
    "name": "CASAB",
    "doc": "Compare and Swap byte in memory reads an 8-bit byte from memory, and compares it against the value held in a first register. If the comparison is equal, the value in a second register is written to memory. If the write is performed, the read and write occur atomically such that no other modification of the memory location can take place between the read and write."
  },
  {
    "name": "CASALB",
    "doc": "Compare and Swap byte in memory reads an 8-bit byte from memory, and compares it against the value held in a first register. If the comparison is equal, the value in a second register is written to memory. If the write is performed, the read and write occur atomically such that no other modification of the memory location can take place between the read and write."
  },
  {
    "name": "CASH",
    "doc": "Compare and Swap halfword in memory reads a 16-bit halfword from memory, and compares it against the value held in a first register. If the comparison is equal, the value in a second register is written to memory. If the write is performed, the read and write occur atomically such that no other modification of the memory location can take place between the read and write."
  },
  {
    "name": "CASAH",
    "doc": "Compare and Swap halfword in memory reads a 16-bit halfword from memory, and compares it against the value held in a first register. If the comparison is equal, the value in a second register is written to memory. If the write is performed, the read and write occur atomically such that no other modification of the memory location can take place between the read and write."
  },
  {
    "name": "CASALH",
    "doc": "Compare and Swap halfword in memory reads a 16-bit halfword from memory, and compares it against the value held in a first register. If the comparison is equal, the value in a second register is written to memory. If the write is performed, the read and write occur atomically such that no other modification of the memory location can take place between the read and write."
  },
  {
    "name": "CASP",
    "doc": "Compare and Swap Pair of words or doublewords in memory reads a pair of 32-bit words or 64-bit doublewords from memory, and compares them against the values held in the first pair of registers. If the comparison is equal, the values in the second pair of registers are written to memory. If the writes are performed, the reads and writes occur atomically such that no other modification of the memory location can take place between the reads and writes."
  },
  {
    "name": "CASPA",
    "doc": "Compare and Swap Pair of words or doublewords in memory reads a pair of 32-bit words or 64-bit doublewords from memory, and compares them against the values held in the first pair of registers. If the comparison is equal, the values in the second pair of registers are written to memory. If the writes are performed, the reads and writes occur atomically such that no other modification of the memory location can take place between the reads and writes."
  },
  {
    "name": "CASPAL",
    "doc": "Compare and Swap Pair of words or doublewords in memory reads a pair of 32-bit words or 64-bit doublewords from memory, and compares them against the values held in the first pair of registers. If the comparison is equal, the values in the second pair of registers are written to memory. If the writes are performed, the reads and writes occur atomically such that no other modification of the memory location can take place between the reads and writes."
  },
  {
    "name": "CCMN",
    "doc": "Conditional Compare Negative (immediate) sets the value of the condition flags to the result of the comparison of a register value and a negated immediate value if the condition is TRUE, and an immediate value otherwise."
  },
  {
    "name": "CCMP",
    "doc": "Conditional Compare (immediate) sets the value of the condition flags to the result of the comparison of a register value and an immediate value if the condition is TRUE, and an immediate value otherwise."
  },
  {
    "name": "CDOT",
    "doc": "Complex integer dot product"
  },
  {
    "name": "CLASTA",
    "doc": "Conditionally extract element after last to general-purpose register"
  },
  {
    "name": "SIMD",
    "doc": "Conditionally extract element after last to SIMD&amp;FP scalar register"
  },
  {
    "name": "CLASTB",
    "doc": "Conditionally extract last element to general-purpose register"
  },
  {
    "name": "CLS",
    "doc": "Count Leading Sign bits (vector). This instruction counts the number of consecutive bits following the most significant bit that are the same as the most significant bit in each vector element in the source SIMD&amp;FP register, places the result into a vector, and writes the vector to the destination SIMD&amp;FP register. The count does not include the most significant bit itself."
  },
  {
    "name": "CLZ",
    "doc": "Count Leading Zero bits (vector). This instruction counts the number of consecutive zeros, starting from the most significant bit, in each vector element in the source SIMD&amp;FP register, places the result into a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "CMEQ",
    "doc": "Compare bitwise Equal (vector). This instruction compares each vector element from the first source SIMD&amp;FP register with the corresponding vector element from the second source SIMD&amp;FP register, and if the comparison is equal sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to zero."
  },
  {
    "name": "CMGE",
    "doc": "Compare signed Greater than or Equal (vector). This instruction compares each vector element in the first source SIMD&amp;FP register with the corresponding vector element in the second source SIMD&amp;FP register and if the first signed integer value is greater than or equal to the second signed integer value sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to zero."
  },
  {
    "name": "CMGT",
    "doc": "Compare signed Greater than (vector). This instruction compares each vector element in the first source SIMD&amp;FP register with the corresponding vector element in the second source SIMD&amp;FP register and if the first signed integer value is greater than the second signed integer value sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to zero."
  },
  {
    "name": "CMHI",
    "doc": "Compare unsigned Higher (vector). This instruction compares each vector element in the first source SIMD&amp;FP register with the corresponding vector element in the second source SIMD&amp;FP register and if the first unsigned integer value is greater than the second unsigned integer value sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to zero."
  },
  {
    "name": "CMHS",
    "doc": "Compare unsigned Higher or Same (vector). This instruction compares each vector element in the first source SIMD&amp;FP register with the corresponding vector element in the second source SIMD&amp;FP register and if the first unsigned integer value is greater than or equal to the second unsigned integer value sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to zero."
  },
  {
    "name": "CMLA",
    "doc": "Complex integer multiply-add with rotate"
  },
  {
    "name": "CMLE",
    "doc": "Compare signed Less than or Equal to zero (vector). This instruction reads each vector element in the source SIMD&amp;FP register and if the signed integer value is less than or equal to zero sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to zero."
  },
  {
    "name": "CMLT",
    "doc": "Compare signed Less than zero (vector). This instruction reads each vector element in the source SIMD&amp;FP register and if the signed integer value is less than zero sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to zero."
  },
  {
    "name": "CMN",
    "doc": "Compare Negative (extended register) adds a register value and a sign or zero-extended register value, followed by an optional left shift amount. The argument that is extended from the &lt;Rm&gt; register can be a byte, halfword, word, or doubleword. It updates the condition flags based on the result, and discards the result."
  },
  {
    "name": "CMP",
    "doc": "Compare vector to immediate"
  },
  {
    "name": "CMPLE",
    "doc": "Compare signed less than or equal to vector, setting the condition flags"
  },
  {
    "name": "CMPLO",
    "doc": "Compare unsigned lower than vector, setting the condition flags"
  },
  {
    "name": "CMPLS",
    "doc": "Compare unsigned lower or same as vector, setting the condition flags"
  },
  {
    "name": "CMPLT",
    "doc": "Compare signed less than vector, setting the condition flags"
  },
  {
    "name": "CNTB",
    "doc": "Set scalar to multiple of predicate constraint element count"
  },
  {
    "name": "CNTD",
    "doc": "Set scalar to multiple of predicate constraint element count"
  },
  {
    "name": "CNTH",
    "doc": "Set scalar to multiple of predicate constraint element count"
  },
  {
    "name": "CNTP",
    "doc": "Set scalar to count from predicate-as-counter"
  },
  {
    "name": "CPYFP",
    "doc": "Memory Copy Forward-only. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFP, then CPYFM, and then CPYFE."
  },
  {
    "name": "CPYFM",
    "doc": "Memory Copy Forward-only. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFP, then CPYFM, and then CPYFE."
  },
  {
    "name": "CPYFPN",
    "doc": "Memory Copy Forward-only, reads and writes non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPN, then CPYFMN, and then CPYFEN."
  },
  {
    "name": "CPYFMN",
    "doc": "Memory Copy Forward-only, reads and writes non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPN, then CPYFMN, and then CPYFEN."
  },
  {
    "name": "CPYFPRN",
    "doc": "Memory Copy Forward-only, reads non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPRN, then CPYFMRN, and then CPYFERN."
  },
  {
    "name": "CPYFMRN",
    "doc": "Memory Copy Forward-only, reads non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPRN, then CPYFMRN, and then CPYFERN."
  },
  {
    "name": "CPYFPRT",
    "doc": "Memory Copy Forward-only, reads unprivileged. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPRT, then CPYFMRT, and then CPYFERT."
  },
  {
    "name": "CPYFMRT",
    "doc": "Memory Copy Forward-only, reads unprivileged. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPRT, then CPYFMRT, and then CPYFERT."
  },
  {
    "name": "CPYFPRTN",
    "doc": "Memory Copy Forward-only, reads unprivileged, reads and writes non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPRTN, then CPYFMRTN, and then CPYFERTN."
  },
  {
    "name": "CPYFMRTN",
    "doc": "Memory Copy Forward-only, reads unprivileged, reads and writes non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPRTN, then CPYFMRTN, and then CPYFERTN."
  },
  {
    "name": "CPYFPRTRN",
    "doc": "Memory Copy Forward-only, reads unprivileged and non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPRTRN, then CPYFMRTRN, and then CPYFERTRN."
  },
  {
    "name": "CPYFMRTRN",
    "doc": "Memory Copy Forward-only, reads unprivileged and non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPRTRN, then CPYFMRTRN, and then CPYFERTRN."
  },
  {
    "name": "CPYFPRTWN",
    "doc": "Memory Copy Forward-only, reads unprivileged, writes non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPRTWN, then CPYFMRTWN, and then CPYFERTWN."
  },
  {
    "name": "CPYFMRTWN",
    "doc": "Memory Copy Forward-only, reads unprivileged, writes non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPRTWN, then CPYFMRTWN, and then CPYFERTWN."
  },
  {
    "name": "CPYFPT",
    "doc": "Memory Copy Forward-only, reads and writes unprivileged. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPT, then CPYFMT, and then CPYFET."
  },
  {
    "name": "CPYFMT",
    "doc": "Memory Copy Forward-only, reads and writes unprivileged. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPT, then CPYFMT, and then CPYFET."
  },
  {
    "name": "CPYFPTN",
    "doc": "Memory Copy Forward-only, reads and writes unprivileged and non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPTN, then CPYFMTN, and then CPYFETN."
  },
  {
    "name": "CPYFMTN",
    "doc": "Memory Copy Forward-only, reads and writes unprivileged and non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPTN, then CPYFMTN, and then CPYFETN."
  },
  {
    "name": "CPYFPTRN",
    "doc": "Memory Copy Forward-only, reads and writes unprivileged, reads non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPTRN, then CPYFMTRN, and then CPYFETRN."
  },
  {
    "name": "CPYFMTRN",
    "doc": "Memory Copy Forward-only, reads and writes unprivileged, reads non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPTRN, then CPYFMTRN, and then CPYFETRN."
  },
  {
    "name": "CPYFPTWN",
    "doc": "Memory Copy Forward-only, reads and writes unprivileged, writes non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPTWN, then CPYFMTWN, and then CPYFETWN."
  },
  {
    "name": "CPYFMTWN",
    "doc": "Memory Copy Forward-only, reads and writes unprivileged, writes non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPTWN, then CPYFMTWN, and then CPYFETWN."
  },
  {
    "name": "CPYFPWN",
    "doc": "Memory Copy Forward-only, writes non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPWN, then CPYFMWN, and then CPYFEWN."
  },
  {
    "name": "CPYFMWN",
    "doc": "Memory Copy Forward-only, writes non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPWN, then CPYFMWN, and then CPYFEWN."
  },
  {
    "name": "CPYFPWT",
    "doc": "Memory Copy Forward-only, writes unprivileged. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPWT, then CPYFMWT, and then CPYFEWT."
  },
  {
    "name": "CPYFMWT",
    "doc": "Memory Copy Forward-only, writes unprivileged. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPWT, then CPYFMWT, and then CPYFEWT."
  },
  {
    "name": "CPYFPWTN",
    "doc": "Memory Copy Forward-only, writes unprivileged, reads and writes non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPWTN, then CPYFMWTN, and then CPYFEWTN."
  },
  {
    "name": "CPYFMWTN",
    "doc": "Memory Copy Forward-only, writes unprivileged, reads and writes non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPWTN, then CPYFMWTN, and then CPYFEWTN."
  },
  {
    "name": "CPYFPWTRN",
    "doc": "Memory Copy Forward-only, writes unprivileged, reads non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPWTRN, then CPYFMWTRN, and then CPYFEWTRN."
  },
  {
    "name": "CPYFMWTRN",
    "doc": "Memory Copy Forward-only, writes unprivileged, reads non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPWTRN, then CPYFMWTRN, and then CPYFEWTRN."
  },
  {
    "name": "CPYFPWTWN",
    "doc": "Memory Copy Forward-only, writes unprivileged and non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPWTWN, then CPYFMWTWN, and then CPYFEWTWN."
  },
  {
    "name": "CPYFMWTWN",
    "doc": "Memory Copy Forward-only, writes unprivileged and non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPWTWN, then CPYFMWTWN, and then CPYFEWTWN."
  },
  {
    "name": "CPYP",
    "doc": "Memory Copy. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYP, then CPYM, and then CPYE."
  },
  {
    "name": "CPYM",
    "doc": "Memory Copy. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYP, then CPYM, and then CPYE."
  },
  {
    "name": "CPYPN",
    "doc": "Memory Copy, reads and writes non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPN, then CPYMN, and then CPYEN."
  },
  {
    "name": "CPYMN",
    "doc": "Memory Copy, reads and writes non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPN, then CPYMN, and then CPYEN."
  },
  {
    "name": "CPYPRN",
    "doc": "Memory Copy, reads non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPRN, then CPYMRN, and then CPYERN."
  },
  {
    "name": "CPYMRN",
    "doc": "Memory Copy, reads non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPRN, then CPYMRN, and then CPYERN."
  },
  {
    "name": "CPYPRT",
    "doc": "Memory Copy, reads unprivileged. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPRT, then CPYMRT, and then CPYERT."
  },
  {
    "name": "CPYMRT",
    "doc": "Memory Copy, reads unprivileged. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPRT, then CPYMRT, and then CPYERT."
  },
  {
    "name": "CPYPRTN",
    "doc": "Memory Copy, reads unprivileged, reads and writes non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPRTN, then CPYMRTN, and then CPYERTN."
  },
  {
    "name": "CPYMRTN",
    "doc": "Memory Copy, reads unprivileged, reads and writes non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPRTN, then CPYMRTN, and then CPYERTN."
  },
  {
    "name": "CPYPRTRN",
    "doc": "Memory Copy, reads unprivileged and non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPRTRN, then CPYMRTRN, and then CPYERTRN."
  },
  {
    "name": "CPYMRTRN",
    "doc": "Memory Copy, reads unprivileged and non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPRTRN, then CPYMRTRN, and then CPYERTRN."
  },
  {
    "name": "CPYPRTWN",
    "doc": "Memory Copy, reads unprivileged, writes non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPRTWN, then CPYMRTWN, and then CPYERTWN."
  },
  {
    "name": "CPYMRTWN",
    "doc": "Memory Copy, reads unprivileged, writes non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPRTWN, then CPYMRTWN, and then CPYERTWN."
  },
  {
    "name": "CPYPT",
    "doc": "Memory Copy, reads and writes unprivileged. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPT, then CPYMT, and then CPYET."
  },
  {
    "name": "CPYMT",
    "doc": "Memory Copy, reads and writes unprivileged. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPT, then CPYMT, and then CPYET."
  },
  {
    "name": "CPYPTN",
    "doc": "Memory Copy, reads and writes unprivileged and non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPTN, then CPYMTN, and then CPYETN."
  },
  {
    "name": "CPYMTN",
    "doc": "Memory Copy, reads and writes unprivileged and non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPTN, then CPYMTN, and then CPYETN."
  },
  {
    "name": "CPYPTRN",
    "doc": "Memory Copy, reads and writes unprivileged, reads non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPTRN, then CPYMTRN, and then CPYETRN."
  },
  {
    "name": "CPYMTRN",
    "doc": "Memory Copy, reads and writes unprivileged, reads non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPTRN, then CPYMTRN, and then CPYETRN."
  },
  {
    "name": "CPYPTWN",
    "doc": "Memory Copy, reads and writes unprivileged, writes non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPTWN, then CPYMTWN, and then CPYETWN."
  },
  {
    "name": "CPYMTWN",
    "doc": "Memory Copy, reads and writes unprivileged, writes non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPTWN, then CPYMTWN, and then CPYETWN."
  },
  {
    "name": "CPYPWN",
    "doc": "Memory Copy, writes non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPWN, then CPYMWN, and then CPYEWN."
  },
  {
    "name": "CPYMWN",
    "doc": "Memory Copy, writes non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPWN, then CPYMWN, and then CPYEWN."
  },
  {
    "name": "CPYPWT",
    "doc": "Memory Copy, writes unprivileged. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPWT, then CPYMWT, and then CPYEWT."
  },
  {
    "name": "CPYMWT",
    "doc": "Memory Copy, writes unprivileged. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPWT, then CPYMWT, and then CPYEWT."
  },
  {
    "name": "CPYPWTN",
    "doc": "Memory Copy, writes unprivileged, reads and writes non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPWTN, then CPYMWTN, and then CPYEWTN."
  },
  {
    "name": "CPYMWTN",
    "doc": "Memory Copy, writes unprivileged, reads and writes non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPWTN, then CPYMWTN, and then CPYEWTN."
  },
  {
    "name": "CPYPWTRN",
    "doc": "Memory Copy, writes unprivileged, reads non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPWTRN, then CPYMWTRN, and then CPYEWTRN."
  },
  {
    "name": "CPYMWTRN",
    "doc": "Memory Copy, writes unprivileged, reads non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPWTRN, then CPYMWTRN, and then CPYEWTRN."
  },
  {
    "name": "CPYPWTWN",
    "doc": "Memory Copy, writes unprivileged and non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPWTWN, then CPYMWTWN, and then CPYEWTWN."
  },
  {
    "name": "CPYMWTWN",
    "doc": "Memory Copy, writes unprivileged and non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPWTWN, then CPYMWTWN, and then CPYEWTWN."
  },
  {
    "name": "CPY",
    "doc": "Copy signed integer immediate to vector elements (zeroing)"
  },
  {
    "name": "CRC",
    "doc": "CRC32 checksum performs a cyclic redundancy check (CRC) calculation on a value held in a general-purpose register. It takes an input CRC value in the first source operand, performs a CRC on the input value in the second source operand, and returns the output CRC value. The second source operand can be 8, 16, 32, or 64 bits. To align with common usage, the bit order of the values is reversed as part of the operation, and the polynomial 0x04C11DB7 is used for the CRC calculation."
  },
  {
    "name": "H",
    "doc": "CRC32 checksum performs a cyclic redundancy check (CRC) calculation on a value held in a general-purpose register. It takes an input CRC value in the first source operand, performs a CRC on the input value in the second source operand, and returns the output CRC value. The second source operand can be 8, 16, 32, or 64 bits. To align with common usage, the bit order of the values is reversed as part of the operation, and the polynomial 0x04C11DB7 is used for the CRC calculation."
  },
  {
    "name": "W",
    "doc": "CRC32 checksum performs a cyclic redundancy check (CRC) calculation on a value held in a general-purpose register. It takes an input CRC value in the first source operand, performs a CRC on the input value in the second source operand, and returns the output CRC value. The second source operand can be 8, 16, 32, or 64 bits. To align with common usage, the bit order of the values is reversed as part of the operation, and the polynomial 0x04C11DB7 is used for the CRC calculation."
  },
  {
    "name": "CB",
    "doc": "CRC32C checksum performs a cyclic redundancy check (CRC) calculation on a value held in a general-purpose register. It takes an input CRC value in the first source operand, performs a CRC on the input value in the second source operand, and returns the output CRC value. The second source operand can be 8, 16, 32, or 64 bits. To align with common usage, the bit order of the values is reversed as part of the operation, and the polynomial 0x1EDC6F41 is used for the CRC calculation."
  },
  {
    "name": "CH",
    "doc": "CRC32C checksum performs a cyclic redundancy check (CRC) calculation on a value held in a general-purpose register. It takes an input CRC value in the first source operand, performs a CRC on the input value in the second source operand, and returns the output CRC value. The second source operand can be 8, 16, 32, or 64 bits. To align with common usage, the bit order of the values is reversed as part of the operation, and the polynomial 0x1EDC6F41 is used for the CRC calculation."
  },
  {
    "name": "CW",
    "doc": "CRC32C checksum performs a cyclic redundancy check (CRC) calculation on a value held in a general-purpose register. It takes an input CRC value in the first source operand, performs a CRC on the input value in the second source operand, and returns the output CRC value. The second source operand can be 8, 16, 32, or 64 bits. To align with common usage, the bit order of the values is reversed as part of the operation, and the polynomial 0x1EDC6F41 is used for the CRC calculation."
  },
  {
    "name": "CTERMEQ",
    "doc": "Compare and terminate loop"
  },
  {
    "name": "DCPS",
    "doc": "Debug Change PE State to EL1, when executed in Debug state:"
  },
  {
    "name": "DECB",
    "doc": "Decrement scalar by multiple of predicate constraint element count"
  },
  {
    "name": "DECD",
    "doc": "Decrement scalar by multiple of predicate constraint element count"
  },
  {
    "name": "DECH",
    "doc": "Decrement scalar by multiple of predicate constraint element count"
  },
  {
    "name": "DECW",
    "doc": "Decrement scalar by multiple of predicate constraint element count"
  },
  {
    "name": "DECP",
    "doc": "Decrement scalar by count of true predicate elements"
  },
  {
    "name": "DUP",
    "doc": "Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&amp;FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&amp;FP register."
  },
  {
    "name": "EON",
    "doc": "Bitwise Exclusive-OR NOT (shifted register) performs a bitwise exclusive-OR NOT of a register value and an optionally-shifted register value, and writes the result to the destination register."
  },
  {
    "name": "EOR",
    "doc": "Three-way Exclusive-OR performs a three-way exclusive-OR of the values in the three source SIMD&amp;FP registers, and writes the result to the destination SIMD&amp;FP register."
  },
  {
    "name": "ERETAA",
    "doc": "Exception Return, with pointer authentication. This instruction authenticates the address in ELR, using SP as the modifier and the specified key, the PE restores PSTATE from the SPSR for the current Exception level, and branches to the authenticated address."
  },
  {
    "name": "FABS",
    "doc": "Floating-point Absolute value (vector). This instruction calculates the absolute value of each vector element in the source SIMD&amp;FP register, writes the result to a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "FAC",
    "doc": "Floating-point absolute compare vectors"
  },
  {
    "name": "FADDP",
    "doc": "Floating-point Add Pair of elements (scalar). This instruction adds two floating-point vector elements in the source SIMD&amp;FP register and writes the scalar result into the destination SIMD&amp;FP register."
  },
  {
    "name": "FADD",
    "doc": "Floating-point Add (vector). This instruction adds corresponding vector elements in the two source SIMD&amp;FP registers, writes the result into a vector, and writes the vector to the destination SIMD&amp;FP register. All the values in this instruction are floating-point values."
  },
  {
    "name": "FCMEQ",
    "doc": "Floating-point Compare Equal (vector). This instruction compares each floating-point value from the first source SIMD&amp;FP register, with the corresponding floating-point value from the second source SIMD&amp;FP register, and if the comparison is equal sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to zero."
  },
  {
    "name": "FCM",
    "doc": "Floating-point compare vector with zero"
  },
  {
    "name": "FCMGE",
    "doc": "Floating-point Compare Greater than or Equal (vector). This instruction reads each floating-point value in the first source SIMD&amp;FP register and if the value is greater than or equal to the corresponding floating-point value in the second source SIMD&amp;FP register sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to zero."
  },
  {
    "name": "FCMGT",
    "doc": "Floating-point Compare Greater than (vector). This instruction reads each floating-point value in the first source SIMD&amp;FP register and if the value is greater than the corresponding floating-point value in the second source SIMD&amp;FP register sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to zero."
  },
  {
    "name": "FCMLA",
    "doc": "Floating-point Complex Multiply Accumulate (by element)."
  },
  {
    "name": "FCMLE",
    "doc": "Floating-point Compare Less than or Equal to zero (vector). This instruction reads each floating-point value in the source SIMD&amp;FP register and if the value is less than or equal to zero sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to zero."
  },
  {
    "name": "FCMLT",
    "doc": "Floating-point Compare Less than zero (vector). This instruction reads each floating-point value in the source SIMD&amp;FP register and if the value is less than zero sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to zero."
  },
  {
    "name": "FCVTAS",
    "doc": "Floating-point Convert to Signed integer, rounding to nearest with ties to Away (vector). This instruction converts each element in a vector from a floating-point value to a signed integer value using the Round to Nearest with Ties to Away rounding mode and writes the result to the SIMD&amp;FP destination register."
  },
  {
    "name": "FCVTAU",
    "doc": "Floating-point Convert to Unsigned integer, rounding to nearest with ties to Away (vector). This instruction converts each element in a vector from a floating-point value to an unsigned integer value using the Round to Nearest with Ties to Away rounding mode and writes the result to the SIMD&amp;FP destination register."
  },
  {
    "name": "FCVTL",
    "doc": "Floating-point Convert to higher precision Long (vector). This instruction reads each element in a vector in the SIMD&amp;FP source register, converts each value to double the precision of the source element using the rounding mode that is determined by the FPCR, and writes each result to the equivalent element of the vector in the SIMD&amp;FP destination register."
  },
  {
    "name": "FCVTMS",
    "doc": "Floating-point Convert to Signed integer, rounding toward Minus infinity (vector). This instruction converts a scalar or each element in a vector from a floating-point value to a signed integer value using the Round towards Minus Infinity rounding mode, and writes the result to the SIMD&amp;FP destination register."
  },
  {
    "name": "FCVTMU",
    "doc": "Floating-point Convert to Unsigned integer, rounding toward Minus infinity (vector). This instruction converts a scalar or each element in a vector from a floating-point value to an unsigned integer value using the Round towards Minus Infinity rounding mode, and writes the result to the SIMD&amp;FP destination register."
  },
  {
    "name": "FCVTNS",
    "doc": "Floating-point Convert to Signed integer, rounding to nearest with ties to even (vector). This instruction converts a scalar or each element in a vector from a floating-point value to a signed integer value using the Round to Nearest rounding mode, and writes the result to the SIMD&amp;FP destination register."
  },
  {
    "name": "FCVTNU",
    "doc": "Floating-point Convert to Unsigned integer, rounding to nearest with ties to even (vector). This instruction converts a scalar or each element in a vector from a floating-point value to an unsigned integer value using the Round to Nearest rounding mode, and writes the result to the SIMD&amp;FP destination register."
  },
  {
    "name": "FCVTN",
    "doc": "Floating-point Convert to lower precision Narrow (vector). This instruction reads each vector element in the SIMD&amp;FP source register, converts each result to half the precision of the source element, writes the final result to a vector, and writes the vector to the lower or upper half of the destination SIMD&amp;FP register. The destination vector elements are half as long as the source vector elements. The rounding mode is determined by the FPCR."
  },
  {
    "name": "FCVTPS",
    "doc": "Floating-point Convert to Signed integer, rounding toward Plus infinity (vector). This instruction converts a scalar or each element in a vector from a floating-point value to a signed integer value using the Round towards Plus Infinity rounding mode, and writes the result to the SIMD&amp;FP destination register."
  },
  {
    "name": "FCVTPU",
    "doc": "Floating-point Convert to Unsigned integer, rounding toward Plus infinity (vector). This instruction converts a scalar or each element in a vector from a floating-point value to an unsigned integer value using the Round towards Plus Infinity rounding mode, and writes the result to the SIMD&amp;FP destination register."
  },
  {
    "name": "FCVTXN",
    "doc": "Floating-point Convert to lower precision Narrow, rounding to odd (vector). This instruction reads each vector element in the source SIMD&amp;FP register, narrows each value to half the precision of the source element using the Round to Odd rounding mode, writes the result to a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "FCVTZS",
    "doc": "Floating-point Convert to Signed fixed-point, rounding toward Zero (vector). This instruction converts a scalar or each element in a vector from floating-point to fixed-point signed integer using the Round towards Zero rounding mode, and writes the result to the SIMD&amp;FP destination register."
  },
  {
    "name": "FCVTZU",
    "doc": "Floating-point Convert to Unsigned fixed-point, rounding toward Zero (vector). This instruction converts a scalar or each element in a vector from floating-point to fixed-point unsigned integer using the Round towards Zero rounding mode, and writes the result to the general-purpose destination register."
  },
  {
    "name": "FCVT",
    "doc": "Multi-vector floating-point convert from half-precision to single-precision (in-order)"
  },
  {
    "name": "FDIV",
    "doc": "Floating-point Divide (vector). This instruction divides the floating-point values in the elements in the first source SIMD&amp;FP register, by the floating-point values in the corresponding elements in the second source SIMD&amp;FP register, places the results in a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "FDOT",
    "doc": "Multi-vector half-precision floating-point dot-product by indexed element"
  },
  {
    "name": "FMAXNMP",
    "doc": "Floating-point Maximum Number of Pair of elements (scalar). This instruction compares two vector elements in the source SIMD&amp;FP register and writes the largest of the floating-point values as a scalar to the destination SIMD&amp;FP register."
  },
  {
    "name": "FMAXNM",
    "doc": "Floating-point Maximum Number (vector). This instruction compares corresponding vector elements in the two source SIMD&amp;FP registers, writes the larger of the two floating-point values into a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "FMAXP",
    "doc": "Floating-point Maximum of Pair of elements (scalar). This instruction compares two vector elements in the source SIMD&amp;FP register and writes the largest of the floating-point values as a scalar to the destination SIMD&amp;FP register."
  },
  {
    "name": "FMAX",
    "doc": "Floating-point Maximum (vector). This instruction compares corresponding vector elements in the two source SIMD&amp;FP registers, places the larger of each of the two floating-point values into a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "FMINNMP",
    "doc": "Floating-point Minimum Number of Pair of elements (scalar). This instruction compares two vector elements in the source SIMD&amp;FP register and writes the smallest of the floating-point values as a scalar to the destination SIMD&amp;FP register."
  },
  {
    "name": "FMINNM",
    "doc": "Floating-point Minimum Number (vector). This instruction compares corresponding vector elements in the two source SIMD&amp;FP registers, writes the smaller of the two floating-point values into a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "FMINP",
    "doc": "Floating-point Minimum of Pair of elements (scalar). This instruction compares two vector elements in the source SIMD&amp;FP register and writes the smallest of the floating-point values as a scalar to the destination SIMD&amp;FP register."
  },
  {
    "name": "FMIN",
    "doc": "Floating-point minimum (vector). This instruction compares corresponding elements in the vectors in the two source SIMD&amp;FP registers, places the smaller of each of the two floating-point values into a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "FMLALB",
    "doc": "Half-precision floating-point multiply-add long to single-precision (bottom)"
  },
  {
    "name": "FMLALT",
    "doc": "Half-precision floating-point multiply-add long to single-precision (top)"
  },
  {
    "name": "FMLAL",
    "doc": "Floating-point fused Multiply-Add Long to accumulator (by element). This instruction multiplies the vector elements in the first source SIMD&amp;FP register by the specified value in the second source SIMD&amp;FP register, and accumulates the product to the corresponding vector element of the destination SIMD&amp;FP register. The instruction does not round the result of the multiply before the accumulation."
  },
  {
    "name": "FMLA",
    "doc": "Floating-point fused Multiply-Add to accumulator (by element). This instruction multiplies the vector elements in the first source SIMD&amp;FP register by the specified value in the second source SIMD&amp;FP register, and accumulates the results in the vector elements of the destination SIMD&amp;FP register. All the values in this instruction are floating-point values."
  },
  {
    "name": "FMLSLB",
    "doc": "Half-precision floating-point multiply-subtract long from single-precision (bottom)"
  },
  {
    "name": "FMLSLT",
    "doc": "Half-precision floating-point multiply-subtract long from single-precision (top)"
  },
  {
    "name": "FMLSL",
    "doc": "Floating-point fused Multiply-Subtract Long from accumulator (by element). This instruction multiplies the negated vector elements in the first source SIMD&amp;FP register by the specified value in the second source SIMD&amp;FP register, and accumulates the product to the corresponding vector element of the destination SIMD&amp;FP register. The instruction does not round the result of the multiply before the accumulation."
  },
  {
    "name": "FMLS",
    "doc": "Floating-point fused Multiply-Subtract from accumulator (by element). This instruction multiplies the vector elements in the first source SIMD&amp;FP register by the specified value in the second source SIMD&amp;FP register, and subtracts the results from the vector elements of the destination SIMD&amp;FP register. All the values in this instruction are floating-point values."
  },
  {
    "name": "FMOPA",
    "doc": "Half-precision floating-point sum of outer products and accumulate"
  },
  {
    "name": "FMOPS",
    "doc": "Half-precision floating-point sum of outer products and subtract"
  },
  {
    "name": "FMOV",
    "doc": "Floating-point move immediate (vector). This instruction copies an immediate floating-point constant into every element of the SIMD&amp;FP destination register."
  },
  {
    "name": "FMULX",
    "doc": "Floating-point Multiply extended (by element). This instruction multiplies the floating-point values in the vector elements in the first source SIMD&amp;FP register by the specified floating-point value in the second source SIMD&amp;FP register, places the results in a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "FMUL",
    "doc": "Floating-point Multiply (by element). This instruction multiplies the vector elements in the first source SIMD&amp;FP register by the specified value in the second source SIMD&amp;FP register, places the results in a vector, and writes the vector to the destination SIMD&amp;FP register. All the values in this instruction are floating-point values."
  },
  {
    "name": "FNEG",
    "doc": "Floating-point Negate (vector). This instruction negates the value of each vector element in the source SIMD&amp;FP register, writes the result to a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "FNMUL",
    "doc": "Floating-point Multiply-Negate (scalar). This instruction multiplies the floating-point values of the two source SIMD&amp;FP registers, and writes the negation of the result to the destination SIMD&amp;FP register."
  },
  {
    "name": "FRINT",
    "doc": "Floating-point Round to 32-bit Integer, using current rounding mode (vector). This instruction rounds a vector of floating-point values in the SIMD&amp;FP source register to integral floating-point values that fit into a 32-bit integer size using the rounding mode that is determined by the FPCR, and writes the result to the SIMD&amp;FP destination register."
  },
  {
    "name": "X",
    "doc": "Floating-point Round to 32-bit Integer, using current rounding mode (vector). This instruction rounds a vector of floating-point values in the SIMD&amp;FP source register to integral floating-point values that fit into a 32-bit integer size using the rounding mode that is determined by the FPCR, and writes the result to the SIMD&amp;FP destination register."
  },
  {
    "name": "Z",
    "doc": "Floating-point Round to 32-bit Integer toward Zero (vector). This instruction rounds a vector of floating-point values in the SIMD&amp;FP source register to integral floating-point values that fit into a 32-bit integer size using the Round towards Zero rounding mode, and writes the result to the SIMD&amp;FP destination register."
  },
  {
    "name": "FRINTA",
    "doc": "Floating-point Round to Integral, to nearest with ties to Away (vector). This instruction rounds a vector of floating-point values in the SIMD&amp;FP source register to integral floating-point values of the same size using the Round to Nearest with Ties to Away rounding mode, and writes the result to the SIMD&amp;FP destination register."
  },
  {
    "name": "FRINTI",
    "doc": "Floating-point Round to Integral, using current rounding mode (vector). This instruction rounds a vector of floating-point values in the SIMD&amp;FP source register to integral floating-point values of the same size using the rounding mode that is determined by the FPCR, and writes the result to the SIMD&amp;FP destination register."
  },
  {
    "name": "FRINTM",
    "doc": "Floating-point Round to Integral, toward Minus infinity (vector). This instruction rounds a vector of floating-point values in the SIMD&amp;FP source register to integral floating-point values of the same size using the Round towards Minus Infinity rounding mode, and writes the result to the SIMD&amp;FP destination register."
  },
  {
    "name": "FRINTN",
    "doc": "Floating-point Round to Integral, to nearest with ties to even (vector). This instruction rounds a vector of floating-point values in the SIMD&amp;FP source register to integral floating-point values of the same size using the Round to Nearest rounding mode, and writes the result to the SIMD&amp;FP destination register."
  },
  {
    "name": "FRINTP",
    "doc": "Floating-point Round to Integral, toward Plus infinity (vector). This instruction rounds a vector of floating-point values in the SIMD&amp;FP source register to integral floating-point values of the same size using the Round towards Plus Infinity rounding mode, and writes the result to the SIMD&amp;FP destination register."
  },
  {
    "name": "FRINTX",
    "doc": "Floating-point Round to Integral exact, using current rounding mode (vector). This instruction rounds a vector of floating-point values in the SIMD&amp;FP source register to integral floating-point values of the same size using the rounding mode that is determined by the FPCR, and writes the result to the SIMD&amp;FP destination register."
  },
  {
    "name": "FRINTZ",
    "doc": "Floating-point Round to Integral, toward Zero (vector). This instruction rounds a vector of floating-point values in the SIMD&amp;FP source register to integral floating-point values of the same size using the Round towards Zero rounding mode, and writes the result to the SIMD&amp;FP destination register."
  },
  {
    "name": "FSQRT",
    "doc": "Floating-point Square Root (vector). This instruction calculates the square root for each vector element in the source SIMD&amp;FP register, places the result in a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "FSUBR",
    "doc": "Floating-point reversed subtract from immediate (predicated)"
  },
  {
    "name": "FSUB",
    "doc": "Floating-point Subtract (vector). This instruction subtracts the elements in the vector in the second source SIMD&amp;FP register, from the corresponding elements in the vector in the first source SIMD&amp;FP register, places each result into elements of a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "GCSB",
    "doc": "Guarded Control Stack Barrier. This instruction generates a Guarded control stack data synchronization event."
  },
  {
    "name": "GCSSS",
    "doc": "Guarded Control Stack Switch Stack 1 validates that the stack being switched to contains a Valid cap entry, stores an In-progress cap entry to the stack that is being switched to, and sets the current Guarded control stack pointer to the stack that is being switched to."
  },
  {
    "name": "INCB",
    "doc": "Increment scalar by multiple of predicate constraint element count"
  },
  {
    "name": "INCD",
    "doc": "Increment scalar by multiple of predicate constraint element count"
  },
  {
    "name": "INCH",
    "doc": "Increment scalar by multiple of predicate constraint element count"
  },
  {
    "name": "INCW",
    "doc": "Increment scalar by multiple of predicate constraint element count"
  },
  {
    "name": "INCP",
    "doc": "Increment scalar by count of true predicate elements"
  },
  {
    "name": "INDEX",
    "doc": "Create index starting from and incremented by immediate"
  },
  {
    "name": "INSR",
    "doc": "Insert general-purpose register in shifted vector"
  },
  {
    "name": "INS",
    "doc": "Insert vector element from another vector element. This instruction copies the vector element of the source SIMD&amp;FP register to the specified vector element of the destination SIMD&amp;FP register."
  },
  {
    "name": "LASTA",
    "doc": "Extract element after last to general-purpose register"
  },
  {
    "name": "LASTB",
    "doc": "Extract last element to general-purpose register"
  },
  {
    "name": "LD",
    "doc": "Contiguous load of bytes to multiple strided vectors (immediate index)"
  },
  {
    "name": "D",
    "doc": "Contiguous load of doublewords to multiple strided vectors (immediate index)"
  },
  {
    "name": "ROB",
    "doc": "Contiguous load and replicate thirty-two bytes (immediate index)"
  },
  {
    "name": "ROD",
    "doc": "Contiguous load and replicate four doublewords (immediate index)"
  },
  {
    "name": "ROH",
    "doc": "Contiguous load and replicate sixteen halfwords (immediate index)"
  },
  {
    "name": "ROW",
    "doc": "Contiguous load and replicate eight words (immediate index)"
  },
  {
    "name": "RQB",
    "doc": "Contiguous load and replicate sixteen bytes (immediate index)"
  },
  {
    "name": "RQD",
    "doc": "Contiguous load and replicate two doublewords (immediate index)"
  },
  {
    "name": "RQH",
    "doc": "Contiguous load and replicate eight halfwords (immediate index)"
  },
  {
    "name": "RQW",
    "doc": "Contiguous load and replicate four words (immediate index)"
  },
  {
    "name": "SB",
    "doc": "Gather load signed bytes to vector (immediate index)"
  },
  {
    "name": "SH",
    "doc": "Gather load signed halfwords to vector (immediate index)"
  },
  {
    "name": "SW",
    "doc": "Gather load signed words to vector (immediate index)"
  },
  {
    "name": "Q",
    "doc": "Contiguous load two-quadword structures to two vectors (immediate index)"
  },
  {
    "name": "LDADD",
    "doc": "Atomic add on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, adds the value held in a register to it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDADDA",
    "doc": "Atomic add on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, adds the value held in a register to it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDADDAL",
    "doc": "Atomic add on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, adds the value held in a register to it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDADDB",
    "doc": "Atomic add on byte in memory atomically loads an 8-bit byte from memory, adds the value held in a register to it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDADDAB",
    "doc": "Atomic add on byte in memory atomically loads an 8-bit byte from memory, adds the value held in a register to it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDADDALB",
    "doc": "Atomic add on byte in memory atomically loads an 8-bit byte from memory, adds the value held in a register to it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDADDH",
    "doc": "Atomic add on halfword in memory atomically loads a 16-bit halfword from memory, adds the value held in a register to it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDADDAH",
    "doc": "Atomic add on halfword in memory atomically loads a 16-bit halfword from memory, adds the value held in a register to it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDADDALH",
    "doc": "Atomic add on halfword in memory atomically loads a 16-bit halfword from memory, adds the value held in a register to it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDAP",
    "doc": "Load-Acquire RCpc one single-element structure to one lane of one register. This instruction loads a single-element structure from memory and writes the result to the specified lane of the SIMD&amp;FP register without affecting the other bits of the register."
  },
  {
    "name": "LDAPUR",
    "doc": "Load-Acquire RCpc SIMD&amp;FP Register (unscaled offset). This instruction loads a SIMD&amp;FP register from memory. The address that is used for the load is calculated from a base register value and an optional immediate offset."
  },
  {
    "name": "LDCLR",
    "doc": "Atomic bit clear on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, performs a bitwise AND with the complement of the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDCLRA",
    "doc": "Atomic bit clear on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, performs a bitwise AND with the complement of the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDCLRAL",
    "doc": "Atomic bit clear on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, performs a bitwise AND with the complement of the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDCLRB",
    "doc": "Atomic bit clear on byte in memory atomically loads an 8-bit byte from memory, performs a bitwise AND with the complement of the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDCLRAB",
    "doc": "Atomic bit clear on byte in memory atomically loads an 8-bit byte from memory, performs a bitwise AND with the complement of the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDCLRALB",
    "doc": "Atomic bit clear on byte in memory atomically loads an 8-bit byte from memory, performs a bitwise AND with the complement of the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDCLRH",
    "doc": "Atomic bit clear on halfword in memory atomically loads a 16-bit halfword from memory, performs a bitwise AND with the complement of the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDCLRAH",
    "doc": "Atomic bit clear on halfword in memory atomically loads a 16-bit halfword from memory, performs a bitwise AND with the complement of the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDCLRALH",
    "doc": "Atomic bit clear on halfword in memory atomically loads a 16-bit halfword from memory, performs a bitwise AND with the complement of the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDCLRP",
    "doc": "Atomic bit clear on quadword in memory atomically loads a 128-bit quadword from memory, performs a bitwise AND with the complement of the value held in a pair of registers on it, and stores the result back to memory. The value initially loaded from memory is returned in the same pair of registers."
  },
  {
    "name": "LDCLRPA",
    "doc": "Atomic bit clear on quadword in memory atomically loads a 128-bit quadword from memory, performs a bitwise AND with the complement of the value held in a pair of registers on it, and stores the result back to memory. The value initially loaded from memory is returned in the same pair of registers."
  },
  {
    "name": "LDCLRPAL",
    "doc": "Atomic bit clear on quadword in memory atomically loads a 128-bit quadword from memory, performs a bitwise AND with the complement of the value held in a pair of registers on it, and stores the result back to memory. The value initially loaded from memory is returned in the same pair of registers."
  },
  {
    "name": "LDEOR",
    "doc": "Atomic Exclusive-OR on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, performs an exclusive-OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDEORA",
    "doc": "Atomic Exclusive-OR on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, performs an exclusive-OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDEORAL",
    "doc": "Atomic Exclusive-OR on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, performs an exclusive-OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDEORB",
    "doc": "Atomic Exclusive-OR on byte in memory atomically loads an 8-bit byte from memory, performs an exclusive-OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDEORAB",
    "doc": "Atomic Exclusive-OR on byte in memory atomically loads an 8-bit byte from memory, performs an exclusive-OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDEORALB",
    "doc": "Atomic Exclusive-OR on byte in memory atomically loads an 8-bit byte from memory, performs an exclusive-OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDEORH",
    "doc": "Atomic Exclusive-OR on halfword in memory atomically loads a 16-bit halfword from memory, performs an exclusive-OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDEORAH",
    "doc": "Atomic Exclusive-OR on halfword in memory atomically loads a 16-bit halfword from memory, performs an exclusive-OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDEORALH",
    "doc": "Atomic Exclusive-OR on halfword in memory atomically loads a 16-bit halfword from memory, performs an exclusive-OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDFF",
    "doc": "Gather load first-fault unsigned bytes to vector (immediate index)"
  },
  {
    "name": "LDNF",
    "doc": "Contiguous load non-fault unsigned bytes to vector (immediate index)"
  },
  {
    "name": "LDNP",
    "doc": "Load Pair of SIMD&amp;FP registers, with Non-temporal hint. This instruction loads a pair of SIMD&amp;FP registers from memory, issuing a hint to the memory system that the access is non-temporal. The address that is used for the load is calculated from a base register value and an optional immediate offset."
  },
  {
    "name": "LDNT",
    "doc": "Contiguous load non-temporal of bytes to multiple strided vectors (immediate index)"
  },
  {
    "name": "LDP",
    "doc": "Load Pair of SIMD&amp;FP registers. This instruction loads a pair of SIMD&amp;FP registers from memory. The address that is used for the load is calculated from a base register value and an optional immediate offset."
  },
  {
    "name": "LDRAA",
    "doc": "Load Register, with pointer authentication. This instruction authenticates an address from a base register using a modifier of zero and the specified key, adds an immediate offset to the authenticated address, and loads a 64-bit doubleword from memory at this resulting address into a register."
  },
  {
    "name": "LDRB",
    "doc": "Load Register Byte (immediate) loads a byte from memory, zero-extends it, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset. For information about memory accesses, see Load/Store addressing modes."
  },
  {
    "name": "LDRH",
    "doc": "Load Register Halfword (immediate) loads a halfword from memory, zero-extends it, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset. For information about memory accesses, see Load/Store addressing modes."
  },
  {
    "name": "LDRSB",
    "doc": "Load Register Signed Byte (immediate) loads a byte from memory, sign-extends it to either 32 bits or 64 bits, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset. For information about memory accesses, see Load/Store addressing modes."
  },
  {
    "name": "LDRSH",
    "doc": "Load Register Signed Halfword (immediate) loads a halfword from memory, sign-extends it to 32 bits or 64 bits, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset. For information about memory accesses, see Load/Store addressing modes."
  },
  {
    "name": "LDRSW",
    "doc": "Load Register Signed Word (immediate) loads a word from memory, sign-extends it to 64 bits, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset. For information about memory accesses, see Load/Store addressing modes."
  },
  {
    "name": "LDR",
    "doc": "Load SIMD&amp;FP Register (immediate offset). This instruction loads an element from memory, and writes the result as a scalar to the SIMD&amp;FP register. The address that is used for the load is calculated from a base register value, a signed immediate offset, and an optional offset that is a multiple of the element size."
  },
  {
    "name": "ZT",
    "doc": "Load ZT0 register"
  },
  {
    "name": "LDSET",
    "doc": "Atomic bit set on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, performs a bitwise OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDSETA",
    "doc": "Atomic bit set on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, performs a bitwise OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDSETAL",
    "doc": "Atomic bit set on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, performs a bitwise OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDSETB",
    "doc": "Atomic bit set on byte in memory atomically loads an 8-bit byte from memory, performs a bitwise OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDSETAB",
    "doc": "Atomic bit set on byte in memory atomically loads an 8-bit byte from memory, performs a bitwise OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDSETALB",
    "doc": "Atomic bit set on byte in memory atomically loads an 8-bit byte from memory, performs a bitwise OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDSETH",
    "doc": "Atomic bit set on halfword in memory atomically loads a 16-bit halfword from memory, performs a bitwise OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDSETAH",
    "doc": "Atomic bit set on halfword in memory atomically loads a 16-bit halfword from memory, performs a bitwise OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDSETALH",
    "doc": "Atomic bit set on halfword in memory atomically loads a 16-bit halfword from memory, performs a bitwise OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDSETP",
    "doc": "Atomic bit set on quadword in memory atomically loads a 128-bit quadword from memory, performs a bitwise OR with the value held in a pair of registers on it, and stores the result back to memory. The value initially loaded from memory is returned in the same pair of registers."
  },
  {
    "name": "LDSETPA",
    "doc": "Atomic bit set on quadword in memory atomically loads a 128-bit quadword from memory, performs a bitwise OR with the value held in a pair of registers on it, and stores the result back to memory. The value initially loaded from memory is returned in the same pair of registers."
  },
  {
    "name": "LDSETPAL",
    "doc": "Atomic bit set on quadword in memory atomically loads a 128-bit quadword from memory, performs a bitwise OR with the value held in a pair of registers on it, and stores the result back to memory. The value initially loaded from memory is returned in the same pair of registers."
  },
  {
    "name": "LDSMAX",
    "doc": "Atomic signed maximum on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDSMAXA",
    "doc": "Atomic signed maximum on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDSMAXAL",
    "doc": "Atomic signed maximum on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDSMAXB",
    "doc": "Atomic signed maximum on byte in memory atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDSMAXAB",
    "doc": "Atomic signed maximum on byte in memory atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDSMAXALB",
    "doc": "Atomic signed maximum on byte in memory atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDSMAXH",
    "doc": "Atomic signed maximum on halfword in memory atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDSMAXAH",
    "doc": "Atomic signed maximum on halfword in memory atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDSMAXALH",
    "doc": "Atomic signed maximum on halfword in memory atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDSMIN",
    "doc": "Atomic signed minimum on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDSMINA",
    "doc": "Atomic signed minimum on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDSMINAL",
    "doc": "Atomic signed minimum on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDSMINB",
    "doc": "Atomic signed minimum on byte in memory atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDSMINAB",
    "doc": "Atomic signed minimum on byte in memory atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDSMINALB",
    "doc": "Atomic signed minimum on byte in memory atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDSMINH",
    "doc": "Atomic signed minimum on halfword in memory atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDSMINAH",
    "doc": "Atomic signed minimum on halfword in memory atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDSMINALH",
    "doc": "Atomic signed minimum on halfword in memory atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDUMAX",
    "doc": "Atomic unsigned maximum on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDUMAXA",
    "doc": "Atomic unsigned maximum on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDUMAXAL",
    "doc": "Atomic unsigned maximum on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDUMAXB",
    "doc": "Atomic unsigned maximum on byte in memory atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDUMAXAB",
    "doc": "Atomic unsigned maximum on byte in memory atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDUMAXALB",
    "doc": "Atomic unsigned maximum on byte in memory atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDUMAXH",
    "doc": "Atomic unsigned maximum on halfword in memory atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDUMAXAH",
    "doc": "Atomic unsigned maximum on halfword in memory atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDUMAXALH",
    "doc": "Atomic unsigned maximum on halfword in memory atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDUMIN",
    "doc": "Atomic unsigned minimum on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDUMINA",
    "doc": "Atomic unsigned minimum on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDUMINAL",
    "doc": "Atomic unsigned minimum on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDUMINB",
    "doc": "Atomic unsigned minimum on byte in memory atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDUMINAB",
    "doc": "Atomic unsigned minimum on byte in memory atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDUMINALB",
    "doc": "Atomic unsigned minimum on byte in memory atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDUMINH",
    "doc": "Atomic unsigned minimum on halfword in memory atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDUMINAH",
    "doc": "Atomic unsigned minimum on halfword in memory atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDUMINALH",
    "doc": "Atomic unsigned minimum on halfword in memory atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDUR",
    "doc": "Load SIMD&amp;FP Register (unscaled offset). This instruction loads a SIMD&amp;FP register from memory. The address that is used for the load is calculated from a base register value and an optional immediate offset."
  },
  {
    "name": "LSL",
    "doc": "Logical Shift Left (register) shifts a register value left by a variable number of bits, shifting in zeros, and writes the result to the destination register. The remainder obtained by dividing the second source register by the data size defines the number of bits by which the first source register is left-shifted."
  },
  {
    "name": "LSR",
    "doc": "Logical Shift Right (register) shifts a register value right by a variable number of bits, shifting in zeros, and writes the result to the destination register. The remainder obtained by dividing the second source register by the data size defines the number of bits by which the first source register is right-shifted."
  },
  {
    "name": "LUTI",
    "doc": "Lookup table read with 2-bit indexes"
  },
  {
    "name": "MLA",
    "doc": "Multiply-Add to accumulator (vector, by element). This instruction multiplies the vector elements in the first source SIMD&amp;FP register by the specified value in the second source SIMD&amp;FP register, and accumulates the results with the vector elements of the destination SIMD&amp;FP register. All the values in this instruction are unsigned integer values."
  },
  {
    "name": "MLS",
    "doc": "Multiply-Subtract from accumulator (vector, by element). This instruction multiplies the vector elements in the first source SIMD&amp;FP register by the specified value in the second source SIMD&amp;FP register, and subtracts the results from the vector elements of the destination SIMD&amp;FP register. All the values in this instruction are unsigned integer values."
  },
  {
    "name": "MOVAZ",
    "doc": "Move and zero two ZA tile slices to vector registers"
  },
  {
    "name": "MOVA",
    "doc": "Move two ZA tile slices to two vector registers"
  },
  {
    "name": "MOVPRFX",
    "doc": "Move prefix (predicated)"
  },
  {
    "name": "MOVS",
    "doc": "Move predicates (zeroing), setting the condition flags"
  },
  {
    "name": "MOVT",
    "doc": "Move 8 bytes from ZT0 to general-purpose register"
  },
  {
    "name": "MOV",
    "doc": "Move between register and stack pointer\n\n: Rd = Rn."
  },
  {
    "name": "MSR",
    "doc": "Move immediate value to Special Register moves an immediate value to selected bits of the PSTATE. For more information, see Process state, PSTATE."
  },
  {
    "name": "MUL",
    "doc": "Multiply (vector, by element). This instruction multiplies the vector elements in the first source SIMD&amp;FP register by the specified value in the second source SIMD&amp;FP register, places the results in a vector, and writes the vector to the destination SIMD&amp;FP register. All the values in this instruction are unsigned integer values."
  },
  {
    "name": "NEG",
    "doc": "Negate (vector). This instruction reads each vector element from the source SIMD&amp;FP register, negates each value, puts the result into a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "NOT",
    "doc": "Bitwise invert predicate"
  },
  {
    "name": "ORN",
    "doc": "Bitwise inclusive OR NOT (vector). This instruction performs a bitwise OR NOT between the two source SIMD&amp;FP registers, and writes the result to the destination SIMD&amp;FP register."
  },
  {
    "name": "ORR",
    "doc": "Bitwise inclusive OR (vector, immediate). This instruction reads each vector element from the destination SIMD&amp;FP register, performs a bitwise OR between each result and an immediate constant, places the result into a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "PACDA",
    "doc": "Pointer Authentication Code for Data address, using key A. This instruction computes and inserts a pointer authentication code for a data address, using a modifier and key A."
  },
  {
    "name": "PACDB",
    "doc": "Pointer Authentication Code for Data address, using key B. This instruction computes and inserts a pointer authentication code for a data address, using a modifier and key B."
  },
  {
    "name": "PACIA",
    "doc": "Pointer Authentication Code for Instruction address, using key A. This instruction computes and inserts a pointer authentication code for an instruction address, using a modifier and key A."
  },
  {
    "name": "PACIASP",
    "doc": "Pointer Authentication Code for Instruction address, using key A. This instruction computes and inserts a pointer authentication code for an instruction address, using a modifier and key A."
  },
  {
    "name": "PACIAZ",
    "doc": "Pointer Authentication Code for Instruction address, using key A. This instruction computes and inserts a pointer authentication code for an instruction address, using a modifier and key A."
  },
  {
    "name": "PACIB",
    "doc": "Pointer Authentication Code for Instruction address, using key B. This instruction computes and inserts a pointer authentication code for an instruction address, using a modifier and key B."
  },
  {
    "name": "PACIBSP",
    "doc": "Pointer Authentication Code for Instruction address, using key B. This instruction computes and inserts a pointer authentication code for an instruction address, using a modifier and key B."
  },
  {
    "name": "PACIBZ",
    "doc": "Pointer Authentication Code for Instruction address, using key B. This instruction computes and inserts a pointer authentication code for an instruction address, using a modifier and key B."
  },
  {
    "name": "PEXT",
    "doc": "Set predicate from predicate-as-counter"
  },
  {
    "name": "PMOV",
    "doc": "Move predicate from vector"
  },
  {
    "name": "PMULL",
    "doc": "Polynomial Multiply Long. This instruction multiplies corresponding elements in the lower or upper half of the vectors of the two source SIMD&amp;FP registers, places the results in a vector, and writes the vector to the destination SIMD&amp;FP register. The destination vector elements are twice as long as the elements that are multiplied."
  },
  {
    "name": "PRFB",
    "doc": "Gather prefetch bytes (vector plus immediate)"
  },
  {
    "name": "PRFD",
    "doc": "Gather prefetch doublewords (vector plus immediate)"
  },
  {
    "name": "PRFH",
    "doc": "Gather prefetch halfwords (vector plus immediate)"
  },
  {
    "name": "PRFM",
    "doc": "Prefetch Memory (immediate) signals the memory system that data memory accesses from a specified address are likely to occur in the near future. The memory system can respond by taking actions that are expected to speed up the memory accesses when they do occur, such as preloading the cache line containing the specified address into one or more caches."
  },
  {
    "name": "PRFW",
    "doc": "Gather prefetch words (vector plus immediate)"
  },
  {
    "name": "PSB",
    "doc": "Profiling Synchronization Barrier. This instruction is a barrier that ensures that all existing profiling data for the current PE has been formatted, and profiling buffer addresses have been translated such that all writes to the profiling buffer have been initiated.  A following DSB instruction completes when the writes to the profiling buffer have completed."
  },
  {
    "name": "PTRUE",
    "doc": "Initialise predicate-as-counter to all active"
  },
  {
    "name": "PUNPKHI",
    "doc": "Unpack and widen half of predicate"
  },
  {
    "name": "RADDHN",
    "doc": "Rounding Add returning High Narrow. This instruction adds each vector element in the first source SIMD&amp;FP register to the corresponding vector element in the second source SIMD&amp;FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&amp;FP register."
  },
  {
    "name": "RAX",
    "doc": "Rotate and Exclusive-OR rotates each 64-bit element of the 128-bit vector in a source SIMD&amp;FP register left by 1, performs a bitwise exclusive-OR of the resulting 128-bit vector and the vector in another source SIMD&amp;FP register, and writes the result to the destination SIMD&amp;FP register."
  },
  {
    "name": "RBIT",
    "doc": "Reverse Bit order (vector). This instruction reads each vector element from the source SIMD&amp;FP register, reverses the bits of the element, places the results into a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "RCWCAS",
    "doc": "Read Check Write Compare and Swap doubleword in memory reads a 64-bit doubleword from memory, and compares it against the value held in a register. If the comparison is equal, the value in a second register is conditionally written to memory. Storing back to memory is conditional on RCW Checks. If the write is performed, the read and the write occur atomically such that no other modification of the memory location can take place between the read and the write. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWCASA",
    "doc": "Read Check Write Compare and Swap doubleword in memory reads a 64-bit doubleword from memory, and compares it against the value held in a register. If the comparison is equal, the value in a second register is conditionally written to memory. Storing back to memory is conditional on RCW Checks. If the write is performed, the read and the write occur atomically such that no other modification of the memory location can take place between the read and the write. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWCASL",
    "doc": "Read Check Write Compare and Swap doubleword in memory reads a 64-bit doubleword from memory, and compares it against the value held in a register. If the comparison is equal, the value in a second register is conditionally written to memory. Storing back to memory is conditional on RCW Checks. If the write is performed, the read and the write occur atomically such that no other modification of the memory location can take place between the read and the write. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWCASP",
    "doc": "Read Check Write Compare and Swap quadword in memory reads a 128-bit quadword from memory, and compares it against the value held in a pair of registers. If the comparison is equal, the value in a second pair of registers is conditionally written to memory. Storing back to memory is conditional on RCW Checks. If the write is performed, the read and the write occur atomically such that no other modification of the memory location can take place between the read and the write. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWCASPA",
    "doc": "Read Check Write Compare and Swap quadword in memory reads a 128-bit quadword from memory, and compares it against the value held in a pair of registers. If the comparison is equal, the value in a second pair of registers is conditionally written to memory. Storing back to memory is conditional on RCW Checks. If the write is performed, the read and the write occur atomically such that no other modification of the memory location can take place between the read and the write. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWCASPL",
    "doc": "Read Check Write Compare and Swap quadword in memory reads a 128-bit quadword from memory, and compares it against the value held in a pair of registers. If the comparison is equal, the value in a second pair of registers is conditionally written to memory. Storing back to memory is conditional on RCW Checks. If the write is performed, the read and the write occur atomically such that no other modification of the memory location can take place between the read and the write. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWCLR",
    "doc": "Read Check Write atomic bit Clear on doubleword in memory atomically loads a 64-bit doubleword from memory, performs a bitwise AND with the complement of the value held in a register on it, and conditionally stores the result back to memory. Storing of the result back to memory is conditional on RCW Checks. The value initially loaded from memory is returned in the destination register. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWCLRA",
    "doc": "Read Check Write atomic bit Clear on doubleword in memory atomically loads a 64-bit doubleword from memory, performs a bitwise AND with the complement of the value held in a register on it, and conditionally stores the result back to memory. Storing of the result back to memory is conditional on RCW Checks. The value initially loaded from memory is returned in the destination register. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWCLRL",
    "doc": "Read Check Write atomic bit Clear on doubleword in memory atomically loads a 64-bit doubleword from memory, performs a bitwise AND with the complement of the value held in a register on it, and conditionally stores the result back to memory. Storing of the result back to memory is conditional on RCW Checks. The value initially loaded from memory is returned in the destination register. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWCLRP",
    "doc": "Read Check Write atomic bit Clear on quadword in memory atomically loads a 128-bit quadword from memory, performs a bitwise AND with the complement of the value held in a pair of registers on it, and conditionally stores the result back to memory. Storing of the result back to memory is conditional on RCW Checks. The value initially loaded from memory is returned in the same pair of registers. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWCLRPA",
    "doc": "Read Check Write atomic bit Clear on quadword in memory atomically loads a 128-bit quadword from memory, performs a bitwise AND with the complement of the value held in a pair of registers on it, and conditionally stores the result back to memory. Storing of the result back to memory is conditional on RCW Checks. The value initially loaded from memory is returned in the same pair of registers. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWCLRPL",
    "doc": "Read Check Write atomic bit Clear on quadword in memory atomically loads a 128-bit quadword from memory, performs a bitwise AND with the complement of the value held in a pair of registers on it, and conditionally stores the result back to memory. Storing of the result back to memory is conditional on RCW Checks. The value initially loaded from memory is returned in the same pair of registers. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSCAS",
    "doc": "Read Check Write Software Compare and Swap doubleword in memory reads a 64-bit doubleword from memory, and compares it against the value held in a register. If the comparison is equal, the value in a second register is conditionally written to memory. Storing back to memory is conditional on RCW Checks and RCWS Checks. If the write is performed, the read and the write occur atomically such that no other modification of the memory location can take place between the read and the write. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSCASA",
    "doc": "Read Check Write Software Compare and Swap doubleword in memory reads a 64-bit doubleword from memory, and compares it against the value held in a register. If the comparison is equal, the value in a second register is conditionally written to memory. Storing back to memory is conditional on RCW Checks and RCWS Checks. If the write is performed, the read and the write occur atomically such that no other modification of the memory location can take place between the read and the write. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSCASL",
    "doc": "Read Check Write Software Compare and Swap doubleword in memory reads a 64-bit doubleword from memory, and compares it against the value held in a register. If the comparison is equal, the value in a second register is conditionally written to memory. Storing back to memory is conditional on RCW Checks and RCWS Checks. If the write is performed, the read and the write occur atomically such that no other modification of the memory location can take place between the read and the write. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSCASP",
    "doc": "Read Check Write Software Compare and Swap quadword in memory reads a 128-bit quadword from memory, and compares it against the value held in a pair of registers. If the comparison is equal, the value in a second pair of registers is conditionally written to memory. Storing back to memory is conditional on RCW Checks and RCWS Checks. If the write is performed, the read and the write occur atomically such that no other modification of the memory location can take place between the read and the write. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSCASPA",
    "doc": "Read Check Write Software Compare and Swap quadword in memory reads a 128-bit quadword from memory, and compares it against the value held in a pair of registers. If the comparison is equal, the value in a second pair of registers is conditionally written to memory. Storing back to memory is conditional on RCW Checks and RCWS Checks. If the write is performed, the read and the write occur atomically such that no other modification of the memory location can take place between the read and the write. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSCASPL",
    "doc": "Read Check Write Software Compare and Swap quadword in memory reads a 128-bit quadword from memory, and compares it against the value held in a pair of registers. If the comparison is equal, the value in a second pair of registers is conditionally written to memory. Storing back to memory is conditional on RCW Checks and RCWS Checks. If the write is performed, the read and the write occur atomically such that no other modification of the memory location can take place between the read and the write. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSCLR",
    "doc": "Read Check Write Software atomic bit Clear on doubleword in memory atomically loads a 64-bit doubleword from memory, performs a bitwise AND with the complement of the value held in a register on it, and conditionally stores the result back to memory. Storing of the result back to memory is conditional on RCW Checks and RCWS Checks. The value initially loaded from memory is returned in the destination register. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSCLRA",
    "doc": "Read Check Write Software atomic bit Clear on doubleword in memory atomically loads a 64-bit doubleword from memory, performs a bitwise AND with the complement of the value held in a register on it, and conditionally stores the result back to memory. Storing of the result back to memory is conditional on RCW Checks and RCWS Checks. The value initially loaded from memory is returned in the destination register. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSCLRL",
    "doc": "Read Check Write Software atomic bit Clear on doubleword in memory atomically loads a 64-bit doubleword from memory, performs a bitwise AND with the complement of the value held in a register on it, and conditionally stores the result back to memory. Storing of the result back to memory is conditional on RCW Checks and RCWS Checks. The value initially loaded from memory is returned in the destination register. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSCLRP",
    "doc": "Read Check Write Software atomic bit Clear on quadword in memory atomically loads a 128-bit quadword from memory, performs a bitwise AND with the complement of the value held in a pair of registers on it, and conditionally stores the result back to memory. Storing of the result back to memory is conditional on RCW Checks and RCWS Checks. The value initially loaded from memory is returned in the same pair of registers. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSCLRPA",
    "doc": "Read Check Write Software atomic bit Clear on quadword in memory atomically loads a 128-bit quadword from memory, performs a bitwise AND with the complement of the value held in a pair of registers on it, and conditionally stores the result back to memory. Storing of the result back to memory is conditional on RCW Checks and RCWS Checks. The value initially loaded from memory is returned in the same pair of registers. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSCLRPL",
    "doc": "Read Check Write Software atomic bit Clear on quadword in memory atomically loads a 128-bit quadword from memory, performs a bitwise AND with the complement of the value held in a pair of registers on it, and conditionally stores the result back to memory. Storing of the result back to memory is conditional on RCW Checks and RCWS Checks. The value initially loaded from memory is returned in the same pair of registers. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSET",
    "doc": "Read Check Write atomic bit Set on doubleword in memory atomically loads a 64-bit doubleword from memory, performs a bitwise OR with the complement of the value held in a register on it, and conditionally stores the result back to memory. Storing of the result back to memory is conditional on RCW Checks. The value initially loaded from memory is returned in the destination register. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSETA",
    "doc": "Read Check Write atomic bit Set on doubleword in memory atomically loads a 64-bit doubleword from memory, performs a bitwise OR with the complement of the value held in a register on it, and conditionally stores the result back to memory. Storing of the result back to memory is conditional on RCW Checks. The value initially loaded from memory is returned in the destination register. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSETL",
    "doc": "Read Check Write atomic bit Set on doubleword in memory atomically loads a 64-bit doubleword from memory, performs a bitwise OR with the complement of the value held in a register on it, and conditionally stores the result back to memory. Storing of the result back to memory is conditional on RCW Checks. The value initially loaded from memory is returned in the destination register. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSETP",
    "doc": "Read Check Write atomic bit Set on quadword in memory atomically loads a 128-bit quadword from memory, performs a bitwise OR with the value held in a pair of registers on it, and conditionally stores the result back to memory. Storing of the result back to memory is conditional on RCW Checks. The value initially loaded from memory is returned in the same pair of registers. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSETPA",
    "doc": "Read Check Write atomic bit Set on quadword in memory atomically loads a 128-bit quadword from memory, performs a bitwise OR with the value held in a pair of registers on it, and conditionally stores the result back to memory. Storing of the result back to memory is conditional on RCW Checks. The value initially loaded from memory is returned in the same pair of registers. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSETPL",
    "doc": "Read Check Write atomic bit Set on quadword in memory atomically loads a 128-bit quadword from memory, performs a bitwise OR with the value held in a pair of registers on it, and conditionally stores the result back to memory. Storing of the result back to memory is conditional on RCW Checks. The value initially loaded from memory is returned in the same pair of registers. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSSET",
    "doc": "Read Check Write Software atomic bit Set on doubleword in memory atomically loads a 64-bit doubleword from memory, performs a bitwise OR with the complement of the value held in a register on it, and conditionally stores the result back to memory. Storing of the result back to memory is conditional on RCW Checks and RCWS Checks. The value initially loaded from memory is returned in the destination register. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSSETA",
    "doc": "Read Check Write Software atomic bit Set on doubleword in memory atomically loads a 64-bit doubleword from memory, performs a bitwise OR with the complement of the value held in a register on it, and conditionally stores the result back to memory. Storing of the result back to memory is conditional on RCW Checks and RCWS Checks. The value initially loaded from memory is returned in the destination register. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSSETL",
    "doc": "Read Check Write Software atomic bit Set on doubleword in memory atomically loads a 64-bit doubleword from memory, performs a bitwise OR with the complement of the value held in a register on it, and conditionally stores the result back to memory. Storing of the result back to memory is conditional on RCW Checks and RCWS Checks. The value initially loaded from memory is returned in the destination register. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSSETP",
    "doc": "Read Check Write Software atomic bit Set on quadword in memory atomically loads a 128-bit quadword from memory, performs a bitwise OR with the value held in a pair of registers on it, and conditionally stores the result back to memory. Storing of the result back to memory is conditional on RCW Checks and RCWS Checks. The value initially loaded from memory is returned in the same pair of registers. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSSETPA",
    "doc": "Read Check Write Software atomic bit Set on quadword in memory atomically loads a 128-bit quadword from memory, performs a bitwise OR with the value held in a pair of registers on it, and conditionally stores the result back to memory. Storing of the result back to memory is conditional on RCW Checks and RCWS Checks. The value initially loaded from memory is returned in the same pair of registers. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSSETPL",
    "doc": "Read Check Write Software atomic bit Set on quadword in memory atomically loads a 128-bit quadword from memory, performs a bitwise OR with the value held in a pair of registers on it, and conditionally stores the result back to memory. Storing of the result back to memory is conditional on RCW Checks and RCWS Checks. The value initially loaded from memory is returned in the same pair of registers. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSSWP",
    "doc": "Read Check Write Software Swap doubleword in memory atomically loads a 64-bit doubleword from a memory location, and conditionally stores the value held in a register back to the same memory location. Storing back to memory is conditional on RCW Checks and RCWS Checks. The value initially loaded from memory is returned in the destination register. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSSWPA",
    "doc": "Read Check Write Software Swap doubleword in memory atomically loads a 64-bit doubleword from a memory location, and conditionally stores the value held in a register back to the same memory location. Storing back to memory is conditional on RCW Checks and RCWS Checks. The value initially loaded from memory is returned in the destination register. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSSWPL",
    "doc": "Read Check Write Software Swap doubleword in memory atomically loads a 64-bit doubleword from a memory location, and conditionally stores the value held in a register back to the same memory location. Storing back to memory is conditional on RCW Checks and RCWS Checks. The value initially loaded from memory is returned in the destination register. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSSWPP",
    "doc": "Read Check Write Software Swap quadword in memory atomically loads a 128-bit quadword from a memory location, and conditionally stores the value held in a pair of registers back to the same memory location. Storing back to memory is conditional on RCW Checks and RCWS Checks. The value initially loaded from memory is returned in the same pair of registers. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSSWPPA",
    "doc": "Read Check Write Software Swap quadword in memory atomically loads a 128-bit quadword from a memory location, and conditionally stores the value held in a pair of registers back to the same memory location. Storing back to memory is conditional on RCW Checks and RCWS Checks. The value initially loaded from memory is returned in the same pair of registers. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSSWPPL",
    "doc": "Read Check Write Software Swap quadword in memory atomically loads a 128-bit quadword from a memory location, and conditionally stores the value held in a pair of registers back to the same memory location. Storing back to memory is conditional on RCW Checks and RCWS Checks. The value initially loaded from memory is returned in the same pair of registers. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSWP",
    "doc": "Read Check Write Swap doubleword in memory atomically loads a 64-bit doubleword from a memory location, and conditionally stores the value held in a register back to the same memory location. Storing back to memory is conditional on RCW Checks. The value initially loaded from memory is returned in the destination register. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSWPA",
    "doc": "Read Check Write Swap doubleword in memory atomically loads a 64-bit doubleword from a memory location, and conditionally stores the value held in a register back to the same memory location. Storing back to memory is conditional on RCW Checks. The value initially loaded from memory is returned in the destination register. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSWPL",
    "doc": "Read Check Write Swap doubleword in memory atomically loads a 64-bit doubleword from a memory location, and conditionally stores the value held in a register back to the same memory location. Storing back to memory is conditional on RCW Checks. The value initially loaded from memory is returned in the destination register. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSWPP",
    "doc": "Read Check Write Swap quadword in memory atomically loads a 128-bit quadword from a memory location, and conditionally stores the value held in a pair of registers back to the same memory location. Storing back to memory is conditional on RCW Checks. The value initially loaded from memory is returned in the same pair of registers. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSWPPA",
    "doc": "Read Check Write Swap quadword in memory atomically loads a 128-bit quadword from a memory location, and conditionally stores the value held in a pair of registers back to the same memory location. Storing back to memory is conditional on RCW Checks. The value initially loaded from memory is returned in the same pair of registers. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSWPPL",
    "doc": "Read Check Write Swap quadword in memory atomically loads a 128-bit quadword from a memory location, and conditionally stores the value held in a pair of registers back to the same memory location. Storing back to memory is conditional on RCW Checks. The value initially loaded from memory is returned in the same pair of registers. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RDFFR",
    "doc": "Read the first-fault register"
  },
  {
    "name": "RETAA",
    "doc": "Return from subroutine, with pointer authentication. This instruction authenticates the address that is held in LR, using SP as the modifier and the specified key, branches to the authenticated address, with a hint that this instruction is a subroutine return."
  },
  {
    "name": "REV",
    "doc": "Reverse elements in 16-bit halfwords (vector). This instruction reverses the order of 8-bit elements in each halfword of the vector in the source SIMD&amp;FP register, places the results into a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "REVB",
    "doc": "Reverse bytes / halfwords / words within elements (predicated)"
  },
  {
    "name": "REVH",
    "doc": "Reverse bytes / halfwords / words within elements (predicated)"
  },
  {
    "name": "ROR",
    "doc": "Rotate right (immediate) provides the value of the contents of a register rotated by a variable number of bits. The bits that are rotated off the right end are inserted into the vacated bit positions on the left."
  },
  {
    "name": "RSHRN",
    "doc": "Rounding Shift Right Narrow (immediate). This instruction reads each unsigned integer value from the vector in the source SIMD&amp;FP register, right shifts each result by an immediate value, writes the final result to a vector, and writes the vector to the lower or upper half of the destination SIMD&amp;FP register. The destination vector elements are half as long as the source vector elements. The results are rounded. For truncated results, see SHRN."
  },
  {
    "name": "RSUBHN",
    "doc": "Rounding Subtract returning High Narrow. This instruction subtracts each vector element of the second source SIMD&amp;FP register from the corresponding vector element of the first source SIMD&amp;FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&amp;FP register."
  },
  {
    "name": "SABAL",
    "doc": "Signed Absolute difference and Accumulate Long. This instruction subtracts the vector elements in the lower or upper half of the second source SIMD&amp;FP register from the corresponding vector elements of the first source SIMD&amp;FP register, and accumulates the absolute values of the results into the vector elements of the destination SIMD&amp;FP register. The destination vector elements are twice as long as the source vector elements."
  },
  {
    "name": "SABDL",
    "doc": "Signed Absolute Difference Long. This instruction subtracts the vector elements in the lower or upper half of the second source SIMD&amp;FP register from the corresponding vector elements of the first source SIMD&amp;FP register, places the absolute value of the results into a vector, and writes the vector to the destination SIMD&amp;FP register. The destination vector elements are twice as long as the source vector elements."
  },
  {
    "name": "SADDL",
    "doc": "Signed Add Long (vector). This instruction adds each vector element in the lower or upper half of the first source SIMD&amp;FP register to the corresponding vector element of the second source SIMD&amp;FP register, places the results into a vector, and writes the vector to the destination SIMD&amp;FP register.  The destination vector elements are twice as long as the source vector elements. All the values in this instruction are signed integer values."
  },
  {
    "name": "SADDW",
    "doc": "Signed Add Wide. This instruction adds vector elements of the first source SIMD&amp;FP register to the corresponding vector elements in the lower or upper half of the second source SIMD&amp;FP register, places the results in a vector, and writes the vector to the SIMD&amp;FP destination register."
  },
  {
    "name": "SCVTF",
    "doc": "Signed fixed-point Convert to Floating-point (vector). This instruction converts each element in a vector from fixed-point to floating-point using the rounding mode that is specified by the FPCR, and writes the result to the SIMD&amp;FP destination register."
  },
  {
    "name": "SDOT",
    "doc": "Dot Product signed arithmetic (vector, by element). This instruction performs the dot product of the four 8-bit elements in each 32-bit element of the first source register with the four 8-bit elements of an indexed 32-bit element in the second source register, accumulating the result into the corresponding 32-bit element of the destination register."
  },
  {
    "name": "SEL",
    "doc": "Conditionally select elements from two predicates"
  },
  {
    "name": "SETF",
    "doc": "Set the PSTATE.NZV flags based on the value in the specified general-purpose register. SETF8 treats the value as an 8 bit value, and SETF16 treats the value as an 16 bit value."
  },
  {
    "name": "SETGP",
    "doc": "Memory Set with tag setting. These instructions perform a memory set using the value in the bottom byte of the source register and store an Allocation Tag to memory for each Tag Granule written. The Allocation Tag is calculated from the Logical Address Tag in the register which holds the first address that the set is made to. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: SETGP, then SETGM, and then SETGE."
  },
  {
    "name": "SETGM",
    "doc": "Memory Set with tag setting. These instructions perform a memory set using the value in the bottom byte of the source register and store an Allocation Tag to memory for each Tag Granule written. The Allocation Tag is calculated from the Logical Address Tag in the register which holds the first address that the set is made to. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: SETGP, then SETGM, and then SETGE."
  },
  {
    "name": "SETGPN",
    "doc": "Memory Set with tag setting, non-temporal. These instructions perform a memory set using the value in the bottom byte of the source register and store an Allocation Tag to memory for each Tag Granule written. The Allocation Tag is calculated from the Logical Address Tag in the register which holds the first address that the set is made to. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: SETGPN, then SETGMN, and then SETGEN."
  },
  {
    "name": "SETGMN",
    "doc": "Memory Set with tag setting, non-temporal. These instructions perform a memory set using the value in the bottom byte of the source register and store an Allocation Tag to memory for each Tag Granule written. The Allocation Tag is calculated from the Logical Address Tag in the register which holds the first address that the set is made to. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: SETGPN, then SETGMN, and then SETGEN."
  },
  {
    "name": "SETGPT",
    "doc": "Memory Set with tag setting, unprivileged. These instructions perform a memory set using the value in the bottom byte of the source register and store an Allocation Tag to memory for each Tag Granule written. The Allocation Tag is calculated from the Logical Address Tag in the register which holds the first address that the set is made to. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: SETGPT, then SETGMT, and then SETGET."
  },
  {
    "name": "SETGMT",
    "doc": "Memory Set with tag setting, unprivileged. These instructions perform a memory set using the value in the bottom byte of the source register and store an Allocation Tag to memory for each Tag Granule written. The Allocation Tag is calculated from the Logical Address Tag in the register which holds the first address that the set is made to. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: SETGPT, then SETGMT, and then SETGET."
  },
  {
    "name": "SETGPTN",
    "doc": "Memory Set with tag setting, unprivileged and non-temporal. These instructions perform a memory set using the value in the bottom byte of the source register and store an Allocation Tag to memory for each Tag Granule written. The Allocation Tag is calculated from the Logical Address Tag in the register which holds the first address that the set is made to. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: SETGPTN, then SETGMTN, and then SETGETN."
  },
  {
    "name": "SETGMTN",
    "doc": "Memory Set with tag setting, unprivileged and non-temporal. These instructions perform a memory set using the value in the bottom byte of the source register and store an Allocation Tag to memory for each Tag Granule written. The Allocation Tag is calculated from the Logical Address Tag in the register which holds the first address that the set is made to. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: SETGPTN, then SETGMTN, and then SETGETN."
  },
  {
    "name": "SETP",
    "doc": "Memory Set. These instructions perform a memory set using the value in the bottom byte of the source register. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: SETP, then SETM, and then SETE."
  },
  {
    "name": "SETM",
    "doc": "Memory Set. These instructions perform a memory set using the value in the bottom byte of the source register. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: SETP, then SETM, and then SETE."
  },
  {
    "name": "SETPN",
    "doc": "Memory Set, non-temporal. These instructions perform a memory set using the value in the bottom byte of the source register. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: SETPN, then SETMN, and then SETEN."
  },
  {
    "name": "SETMN",
    "doc": "Memory Set, non-temporal. These instructions perform a memory set using the value in the bottom byte of the source register. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: SETPN, then SETMN, and then SETEN."
  },
  {
    "name": "SETPT",
    "doc": "Memory Set, unprivileged. These instructions perform a memory set using the value in the bottom byte of the source register. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: SETPT, then SETMT, and then SETET."
  },
  {
    "name": "SETMT",
    "doc": "Memory Set, unprivileged. These instructions perform a memory set using the value in the bottom byte of the source register. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: SETPT, then SETMT, and then SETET."
  },
  {
    "name": "SETPTN",
    "doc": "Memory Set, unprivileged and non-temporal. These instructions perform a memory set using the value in the bottom byte of the source register. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: SETPTN, then SETMTN, and then SETETN."
  },
  {
    "name": "SETMTN",
    "doc": "Memory Set, unprivileged and non-temporal. These instructions perform a memory set using the value in the bottom byte of the source register. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: SETPTN, then SETMTN, and then SETETN."
  },
  {
    "name": "SHA",
    "doc": "SHA1 hash update (choose)."
  },
  {
    "name": "SU",
    "doc": "SHA1 schedule update 0."
  },
  {
    "name": "SHLL",
    "doc": "Shift Left Long (by element size). This instruction reads each vector element in the lower or upper half of the source SIMD&amp;FP register, left shifts each result by the element size, writes the final result to a vector, and writes the vector to the destination SIMD&amp;FP register. The destination vector elements are twice as long as the source vector elements."
  },
  {
    "name": "SHRN",
    "doc": "Shift Right Narrow (immediate). This instruction reads each unsigned integer value from the source SIMD&amp;FP register, right shifts each result by an immediate value, puts the final result into a vector, and writes the vector to the lower or upper half of the destination SIMD&amp;FP register. The destination vector elements are half as long as the source vector elements. The results are truncated. For rounded results, see RSHRN."
  },
  {
    "name": "SM",
    "doc": "SM3PARTW1 takes three 128-bit vectors from the three source SIMD&amp;FP registers and returns a 128-bit result in the destination SIMD&amp;FP register. The result is obtained by a three-way exclusive-OR of the elements within the input vectors with some fixed rotations, see the Operation pseudocode for more information."
  },
  {
    "name": "PARTW",
    "doc": "SM3PARTW1 takes three 128-bit vectors from the three source SIMD&amp;FP registers and returns a 128-bit result in the destination SIMD&amp;FP register. The result is obtained by a three-way exclusive-OR of the elements within the input vectors with some fixed rotations, see the Operation pseudocode for more information."
  },
  {
    "name": "SS",
    "doc": "SM3SS1 rotates the top 32 bits of the 128-bit vector in the first source SIMD&amp;FP register by 12, and adds that 32-bit value to the two other 32-bit values held in the top 32 bits of each of the 128-bit vectors in the second and third source SIMD&amp;FP registers, rotating this result left by 7 and writing the final result into the top 32 bits of the vector in the destination SIMD&amp;FP register, with the bottom 96 bits of the vector being written to 0."
  },
  {
    "name": "TT",
    "doc": "SM3TT1A takes three 128-bit vectors from three source SIMD&amp;FP registers and a 2-bit immediate index value, and returns a 128-bit result in the destination SIMD&amp;FP register.  It performs a three-way exclusive-OR of the three 32-bit fields held in the upper three elements of the first source vector, and adds the resulting 32-bit value and the following three other 32-bit values:"
  },
  {
    "name": "SMAX",
    "doc": "Signed Maximum (immediate) determines the signed maximum of the source register value and immediate, and writes the result to the destination register."
  },
  {
    "name": "SMIN",
    "doc": "Signed Minimum (immediate) determines the signed minimum of the source register value and immediate, and writes the result to the destination register."
  },
  {
    "name": "SMLALB",
    "doc": "Signed multiply-add long to accumulator (bottom)"
  },
  {
    "name": "SMLALL",
    "doc": "Multi-vector signed integer multiply-add long-long by indexed element"
  },
  {
    "name": "SMLALT",
    "doc": "Signed multiply-add long to accumulator (top)"
  },
  {
    "name": "SMLAL",
    "doc": "Signed Multiply-Add Long (vector, by element). This instruction multiplies each vector element in the lower or upper half of the first source SIMD&amp;FP register by the specified vector element in the second source SIMD&amp;FP register, and accumulates the results with the vector elements of the destination SIMD&amp;FP register. The destination vector elements are twice as long as the elements that are multiplied. All the values in this instruction are signed integer values."
  },
  {
    "name": "SMLSLB",
    "doc": "Signed multiply-subtract long from accumulator (bottom)"
  },
  {
    "name": "SMLSLL",
    "doc": "Multi-vector signed integer multiply-subtract long-long by indexed element"
  },
  {
    "name": "SMLSLT",
    "doc": "Signed multiply-subtract long from accumulator (top)"
  },
  {
    "name": "SMLSL",
    "doc": "Signed Multiply-Subtract Long (vector, by element). This instruction multiplies each vector element in the lower or upper half of the first source SIMD&amp;FP register by the specified vector element of the second source SIMD&amp;FP register and subtracts the results from the vector elements of the destination SIMD&amp;FP register. The destination vector elements are twice as long as the elements that are multiplied."
  },
  {
    "name": "SMMLA",
    "doc": "Signed 8-bit integer matrix multiply-accumulate. This instruction multiplies the 2x8 matrix of signed 8-bit integer values in the first source vector by the 8x2 matrix of signed 8-bit integer values in the second source vector. The resulting 2x2 32-bit integer matrix product is destructively added to the 32-bit integer matrix accumulator in the destination vector. This is equivalent to performing an 8-way dot product per destination element."
  },
  {
    "name": "SMOPA",
    "doc": "Signed integer sum of outer products and accumulate"
  },
  {
    "name": "SMOPS",
    "doc": "Signed integer sum of outer products and subtract"
  },
  {
    "name": "SMULH",
    "doc": "Signed multiply returning high half (predicated)"
  },
  {
    "name": "SMULLB",
    "doc": "Signed multiply long (bottom)"
  },
  {
    "name": "SMULLT",
    "doc": "Signed multiply long (top)"
  },
  {
    "name": "SMULL",
    "doc": "Signed Multiply Long (vector, by element). This instruction multiplies each vector element in the lower or upper half of the first source SIMD&amp;FP register by the specified vector element of the second source SIMD&amp;FP register, places the result in a vector, and writes the vector to the destination SIMD&amp;FP register. The destination vector elements are twice as long as the elements that are multiplied."
  },
  {
    "name": "SQADD",
    "doc": "Signed saturating addition (predicated)"
  },
  {
    "name": "SQCVTU",
    "doc": "Multi-vector signed saturating unsigned extract narrow"
  },
  {
    "name": "SQCVT",
    "doc": "Multi-vector signed saturating extract narrow"
  },
  {
    "name": "SQDECD",
    "doc": "Signed saturating decrement scalar by multiple of 64-bit predicate constraint element count"
  },
  {
    "name": "SQDECH",
    "doc": "Signed saturating decrement scalar by multiple of 16-bit predicate constraint element count"
  },
  {
    "name": "SQDECP",
    "doc": "Signed saturating decrement scalar by count of true predicate elements"
  },
  {
    "name": "SQDECW",
    "doc": "Signed saturating decrement scalar by multiple of 32-bit predicate constraint element count"
  },
  {
    "name": "SQDMLALB",
    "doc": "Signed saturating doubling multiply-add long to accumulator (bottom)"
  },
  {
    "name": "SQDMLALT",
    "doc": "Signed saturating doubling multiply-add long to accumulator (top)"
  },
  {
    "name": "SQDMLAL",
    "doc": "Signed saturating Doubling Multiply-Add Long (by element). This instruction multiplies each vector element in the lower or upper half of the first source SIMD&amp;FP register by the specified vector element of the second source SIMD&amp;FP register, doubles the results, and accumulates the final results with the vector elements of the destination SIMD&amp;FP register. The destination vector elements are twice as long as the elements that are multiplied."
  },
  {
    "name": "SQDMLSLB",
    "doc": "Signed saturating doubling multiply-subtract long from accumulator (bottom)"
  },
  {
    "name": "SQDMLSLT",
    "doc": "Signed saturating doubling multiply-subtract long from accumulator (top)"
  },
  {
    "name": "SQDMLSL",
    "doc": "Signed saturating Doubling Multiply-Subtract Long (by element). This instruction multiplies each vector element in the lower or upper half of the first source SIMD&amp;FP register by the specified vector element of the second source SIMD&amp;FP register, doubles the results, and subtracts the final results from the vector elements of the destination SIMD&amp;FP register. The destination vector elements are twice as long as the elements that are multiplied. All the values in this instruction are signed integer values."
  },
  {
    "name": "SQDMULH",
    "doc": "Signed saturating Doubling Multiply returning High half (by element). This instruction multiplies each vector element in the first source SIMD&amp;FP register by the specified vector element of the second source SIMD&amp;FP register, doubles the results, places the most significant half of the final results into a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "SQDMULLB",
    "doc": "Signed saturating doubling multiply long (bottom)"
  },
  {
    "name": "SQDMULLT",
    "doc": "Signed saturating doubling multiply long (top)"
  },
  {
    "name": "SQDMULL",
    "doc": "Signed saturating Doubling Multiply Long (by element). This instruction multiplies each vector element in the lower or upper half of the first source SIMD&amp;FP register by the specified vector element of the second source SIMD&amp;FP register, doubles the results, places the final results in a vector, and writes the vector to the destination SIMD&amp;FP register. All the values in this instruction are signed integer values."
  },
  {
    "name": "SQINCD",
    "doc": "Signed saturating increment scalar by multiple of 64-bit predicate constraint element count"
  },
  {
    "name": "SQINCH",
    "doc": "Signed saturating increment scalar by multiple of 16-bit predicate constraint element count"
  },
  {
    "name": "SQINCP",
    "doc": "Signed saturating increment scalar by count of true predicate elements"
  },
  {
    "name": "SQINCW",
    "doc": "Signed saturating increment scalar by multiple of 32-bit predicate constraint element count"
  },
  {
    "name": "SQRDCMLAH",
    "doc": "Saturating rounding doubling complex integer multiply-add high with rotate"
  },
  {
    "name": "SQRDMLAH",
    "doc": "Signed Saturating Rounding Doubling Multiply Accumulate returning High Half (by element). This instruction multiplies the vector elements of the first source SIMD&amp;FP register with the value of a vector element of the second source SIMD&amp;FP register without saturating the multiply results, doubles the results, and accumulates the most significant half of the final results with the vector elements of the destination SIMD&amp;FP register. The results are rounded."
  },
  {
    "name": "SQRDMLSH",
    "doc": "Signed Saturating Rounding Doubling Multiply Subtract returning High Half (by element). This instruction multiplies the vector elements of the first source SIMD&amp;FP register with the value of a vector element of the second source SIMD&amp;FP register without saturating the multiply results, doubles the results, and subtracts the most significant half of the final results from the vector elements of the destination SIMD&amp;FP register. The results are rounded."
  },
  {
    "name": "SQRDMULH",
    "doc": "Signed saturating Rounding Doubling Multiply returning High half (by element). This instruction multiplies each vector element in the first source SIMD&amp;FP register by the specified vector element of the second source SIMD&amp;FP register, doubles the results, places the most significant half of the final results into a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "SQRSHRN",
    "doc": "Signed saturating Rounded Shift Right Narrow (immediate). This instruction reads each vector element in the source SIMD&amp;FP register, right shifts each result by an immediate value, saturates each shifted result to a value that is half the original width, puts the final result into a vector, and writes the vector to the lower or upper half of the destination SIMD&amp;FP register. All the values in this instruction are signed integer values. The destination vector elements are half as long as the source vector elements. The results are rounded. For truncated results, see SQSHRN."
  },
  {
    "name": "SQRSHRUN",
    "doc": "Signed saturating Rounded Shift Right Unsigned Narrow (immediate). This instruction reads each signed integer value in the vector of the source SIMD&amp;FP register, right shifts each value by an immediate value, saturates the result to an unsigned integer value that is half the original width, places the final result into a vector, and writes the vector to the destination SIMD&amp;FP register. The results are rounded. For truncated results, see SQSHRUN."
  },
  {
    "name": "SQRSHRU",
    "doc": "Multi-vector signed saturating rounding shift right unsigned narrow by immediate"
  },
  {
    "name": "SQRSHR",
    "doc": "Multi-vector signed saturating rounding shift right narrow by immediate"
  },
  {
    "name": "SQSHL",
    "doc": "Signed saturating Shift Left (immediate). This instruction reads each vector element in the source SIMD&amp;FP register, shifts each result by an immediate value, places the final result in a vector, and writes the vector to the destination SIMD&amp;FP register. The results are truncated. For rounded results, see UQRSHL."
  },
  {
    "name": "SQSHRN",
    "doc": "Signed saturating Shift Right Narrow (immediate). This instruction reads each vector element in the source SIMD&amp;FP register, right shifts and truncates each result by an immediate value, saturates each shifted result to a value that is half the original width, puts the final result into a vector, and writes the vector to the lower or upper half of the destination SIMD&amp;FP register. All the values in this instruction are signed integer values. The destination vector elements are half as long as the source vector elements. For rounded results, see SQRSHRN."
  },
  {
    "name": "SQSHRUN",
    "doc": "Signed saturating Shift Right Unsigned Narrow (immediate). This instruction reads each signed integer value in the vector of the source SIMD&amp;FP register, right shifts each value by an immediate value, saturates the result to an unsigned integer value that is half the original width, places the final result into a vector, and writes the vector to the destination SIMD&amp;FP register. The results are truncated. For rounded results, see SQRSHRUN."
  },
  {
    "name": "SQSUB",
    "doc": "Signed saturating subtraction (predicated)"
  },
  {
    "name": "SQXTN",
    "doc": "Signed saturating extract Narrow. This instruction reads each vector element from the source SIMD&amp;FP register, saturates the value to half the original width, places the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&amp;FP register. The destination vector elements are half as long as the source vector elements. All the values in this instruction are signed integer values."
  },
  {
    "name": "SQXTUN",
    "doc": "Signed saturating extract Unsigned Narrow. This instruction reads each signed integer value in the vector of the source SIMD&amp;FP register, saturates the value to an unsigned integer value that is half the original width, places the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&amp;FP register. The destination vector elements are half as long as the source vector elements."
  },
  {
    "name": "SRSHL",
    "doc": "Multi-vector signed rounding shift left by vector"
  },
  {
    "name": "SSHLL",
    "doc": "Signed Shift Left Long (immediate). This instruction reads each vector element from the source SIMD&amp;FP register, left shifts each vector element by the specified shift amount, places the result into a vector, and writes the vector to the destination SIMD&amp;FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are signed integer values."
  },
  {
    "name": "SSUBL",
    "doc": "Signed Subtract Long. This instruction subtracts each vector element in the lower or upper half of the second source SIMD&amp;FP register from the corresponding vector element of the first source SIMD&amp;FP register, places the results into a vector, and writes the vector to the destination SIMD&amp;FP register. All the values in this instruction are signed integer values. The destination vector elements are twice as long as the source vector elements."
  },
  {
    "name": "SSUBW",
    "doc": "Signed Subtract Wide. This instruction subtracts each vector element in the lower or upper half of the second source SIMD&amp;FP register from the corresponding vector element in the first source SIMD&amp;FP register, places the result in a vector, and writes the vector to the SIMD&amp;FP destination register. All the values in this instruction are signed integer values."
  },
  {
    "name": "ST",
    "doc": "Contiguous store of bytes from multiple strided vectors (immediate index)"
  },
  {
    "name": "BV",
    "doc": "Single-copy Atomic 64-byte EL0 Store with Return stores eight 64-bit doublewords from consecutive registers, Xt to X(t+7), to a memory location, with the bottom 32 bits taken from ACCDATA_EL1, and writes the status result of the store to a register. The data that is stored is atomic and is required to be 64-byte aligned."
  },
  {
    "name": "STADDB",
    "doc": "Atomic add on byte in memory, without return, atomically loads an 8-bit byte from memory, adds the value held in a register to it, and stores the result back to memory."
  },
  {
    "name": "STADDH",
    "doc": "Atomic add on halfword in memory, without return, atomically loads a 16-bit halfword from memory, adds the value held in a register to it, and stores the result back to memory."
  },
  {
    "name": "STADD",
    "doc": "Atomic add on word or doubleword in memory, without return, atomically loads a 32-bit word or 64-bit doubleword from memory, adds the value held in a register to it, and stores the result back to memory."
  },
  {
    "name": "STCLRB",
    "doc": "Atomic bit clear on byte in memory, without return, atomically loads an 8-bit byte from memory, performs a bitwise AND with the complement of the value held in a register on it, and stores the result back to memory."
  },
  {
    "name": "STCLRH",
    "doc": "Atomic bit clear on halfword in memory, without return, atomically loads a 16-bit halfword from memory, performs a bitwise AND with the complement of the value held in a register on it, and stores the result back to memory."
  },
  {
    "name": "STCLR",
    "doc": "Atomic bit clear on word or doubleword in memory, without return, atomically loads a 32-bit word or 64-bit doubleword from memory, performs a bitwise AND with the complement of the value held in a register on it, and stores the result back to memory."
  },
  {
    "name": "STEORB",
    "doc": "Atomic Exclusive-OR on byte in memory, without return, atomically loads an 8-bit byte from memory, performs an exclusive-OR with the value held in a register on it, and stores the result back to memory."
  },
  {
    "name": "STEORH",
    "doc": "Atomic Exclusive-OR on halfword in memory, without return, atomically loads a 16-bit halfword from memory, performs an exclusive-OR with the value held in a register on it, and stores the result back to memory."
  },
  {
    "name": "STEOR",
    "doc": "Atomic Exclusive-OR on word or doubleword in memory, without return, atomically loads a 32-bit word or 64-bit doubleword from memory, performs an exclusive-OR with the value held in a register on it, and stores the result back to memory."
  },
  {
    "name": "STL",
    "doc": "Store-Release a single-element structure from one lane of one register. This instruction stores the specified element of a SIMD&amp;FP register to memory."
  },
  {
    "name": "STLUR",
    "doc": "Store-Release SIMD&amp;FP Register (unscaled offset). This instruction stores a single SIMD&amp;FP register to memory. The address that is used for the store is calculated from a base register value and an optional immediate offset."
  },
  {
    "name": "STNP",
    "doc": "Store Pair of SIMD&amp;FP registers, with Non-temporal hint. This instruction stores a pair of SIMD&amp;FP registers to memory, issuing a hint to the memory system that the access is non-temporal. The address used for the store is calculated from an address from a base register value and an immediate offset. For information about non-temporal pair instructions, see Load/Store SIMD and Floating-point Non-temporal pair."
  },
  {
    "name": "STNT",
    "doc": "Contiguous store non-temporal of bytes from multiple strided vectors (immediate index)"
  },
  {
    "name": "STP",
    "doc": "Store Pair of SIMD&amp;FP registers. This instruction stores a pair of SIMD&amp;FP registers to memory. The address used for the store is calculated from a base register value and an immediate offset."
  },
  {
    "name": "STRB",
    "doc": "Store Register Byte (immediate) stores the least significant byte of a 32-bit register to memory. The address that is used for the store is calculated from a base register and an immediate offset. For information about memory accesses, see Load/Store addressing modes."
  },
  {
    "name": "STRH",
    "doc": "Store Register Halfword (immediate) stores the least significant halfword of a 32-bit register to memory. The address that is used for the store is calculated from a base register and an immediate offset. For information about memory accesses, see Load/Store addressing modes."
  },
  {
    "name": "STR",
    "doc": "Store SIMD&amp;FP register (immediate offset). This instruction stores a single SIMD&amp;FP register to memory. The address that is used for the store is calculated from a base register value and an immediate offset."
  },
  {
    "name": "STSETB",
    "doc": "Atomic bit set on byte in memory, without return, atomically loads an 8-bit byte from memory, performs a bitwise OR with the value held in a register on it, and stores the result back to memory."
  },
  {
    "name": "STSETH",
    "doc": "Atomic bit set on halfword in memory, without return, atomically loads a 16-bit halfword from memory, performs a bitwise OR with the value held in a register on it, and stores the result back to memory."
  },
  {
    "name": "STSET",
    "doc": "Atomic bit set on word or doubleword in memory, without return, atomically loads a 32-bit word or 64-bit doubleword from memory, performs a bitwise OR with the value held in a register on it, and stores the result back to memory."
  },
  {
    "name": "STSMAXB",
    "doc": "Atomic signed maximum on byte in memory, without return, atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as signed numbers."
  },
  {
    "name": "STSMAXH",
    "doc": "Atomic signed maximum on halfword in memory, without return, atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as signed numbers."
  },
  {
    "name": "STSMAX",
    "doc": "Atomic signed maximum on word or doubleword in memory, without return, atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as signed numbers."
  },
  {
    "name": "STSMINB",
    "doc": "Atomic signed minimum on byte in memory, without return, atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as signed numbers."
  },
  {
    "name": "STSMINH",
    "doc": "Atomic signed minimum on halfword in memory, without return, atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as signed numbers."
  },
  {
    "name": "STSMIN",
    "doc": "Atomic signed minimum on word or doubleword in memory, without return, atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as signed numbers."
  },
  {
    "name": "STUMAXB",
    "doc": "Atomic unsigned maximum on byte in memory, without return, atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as unsigned numbers."
  },
  {
    "name": "STUMAXH",
    "doc": "Atomic unsigned maximum on halfword in memory, without return, atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as unsigned numbers."
  },
  {
    "name": "STUMAX",
    "doc": "Atomic unsigned maximum on word or doubleword in memory, without return, atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as unsigned numbers."
  },
  {
    "name": "STUMINB",
    "doc": "Atomic unsigned minimum on byte in memory, without return, atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as unsigned numbers."
  },
  {
    "name": "STUMINH",
    "doc": "Atomic unsigned minimum on halfword in memory, without return, atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as unsigned numbers."
  },
  {
    "name": "STUMIN",
    "doc": "Atomic unsigned minimum on word or doubleword in memory, without return, atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as unsigned numbers."
  },
  {
    "name": "STUR",
    "doc": "Store SIMD&amp;FP register (unscaled offset). This instruction stores a single SIMD&amp;FP register to memory. The address that is used for the store is calculated from a base register value and an optional immediate offset."
  },
  {
    "name": "STZ",
    "doc": "Store Allocation Tags, Zeroing stores an Allocation Tag to two Tag granules of memory, zeroing the associated data locations. The address used for the store is calculated from the base register and an immediate signed offset scaled by the Tag granule. The Allocation Tag is calculated from the Logical Address Tag in the source register."
  },
  {
    "name": "SUBHN",
    "doc": "Subtract returning High Narrow. This instruction subtracts each vector element in the second source SIMD&amp;FP register from the corresponding vector element in the first source SIMD&amp;FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&amp;FP register. All the values in this instruction are signed integer values."
  },
  {
    "name": "SUBR",
    "doc": "Reversed subtract vectors (predicated)"
  },
  {
    "name": "SUBS",
    "doc": "Subtract (extended register), setting flags, subtracts a sign or zero-extended register value, followed by an optional left shift amount, from a register value, and writes the result to the destination register. The argument that is extended from the &lt;Rm&gt; register can be a byte, halfword, word, or doubleword. It updates the condition flags based on the result."
  },
  {
    "name": "SUB",
    "doc": "Subtract (extended register) subtracts a sign or zero-extended register value, followed by an optional left shift amount, from a register value, and writes the result to the destination register. The argument that is extended from the &lt;Rm&gt; register can be a byte, halfword, word, or doubleword."
  },
  {
    "name": "SUDOT",
    "doc": "Dot product index form with signed and unsigned integers. This instruction performs the dot product of the four signed 8-bit integer values in each 32-bit element of the first source register with the four unsigned 8-bit integer values in an indexed 32-bit element of the second source register, accumulating the result into the corresponding 32-bit element of the destination vector."
  },
  {
    "name": "SUMLALL",
    "doc": "Multi-vector signed by unsigned integer multiply-add long-long by indexed element"
  },
  {
    "name": "SUNPKHI",
    "doc": "Signed unpack and extend half of vector"
  },
  {
    "name": "SVDOT",
    "doc": "Multi-vector signed integer vertical dot-product by indexed element"
  },
  {
    "name": "SWP",
    "doc": "Swap word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from a memory location, and stores the value held in a register back to the same memory location. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "SWPA",
    "doc": "Swap word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from a memory location, and stores the value held in a register back to the same memory location. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "SWPAL",
    "doc": "Swap word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from a memory location, and stores the value held in a register back to the same memory location. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "SWPB",
    "doc": "Swap byte in memory atomically loads an 8-bit byte from a memory location, and stores the value held in a register back to the same memory location. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "SWPAB",
    "doc": "Swap byte in memory atomically loads an 8-bit byte from a memory location, and stores the value held in a register back to the same memory location. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "SWPALB",
    "doc": "Swap byte in memory atomically loads an 8-bit byte from a memory location, and stores the value held in a register back to the same memory location. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "SWPH",
    "doc": "Swap halfword in memory atomically loads a 16-bit halfword from a memory location, and stores the value held in a register back to the same memory location. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "SWPAH",
    "doc": "Swap halfword in memory atomically loads a 16-bit halfword from a memory location, and stores the value held in a register back to the same memory location. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "SWPALH",
    "doc": "Swap halfword in memory atomically loads a 16-bit halfword from a memory location, and stores the value held in a register back to the same memory location. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "SWPP",
    "doc": "Swap quadword in memory atomically loads a 128-bit quadword from a memory location, and stores the value held in a pair of registers back to the same memory location. The value initially loaded from memory is returned in the same pair of registers."
  },
  {
    "name": "SWPPA",
    "doc": "Swap quadword in memory atomically loads a 128-bit quadword from a memory location, and stores the value held in a pair of registers back to the same memory location. The value initially loaded from memory is returned in the same pair of registers."
  },
  {
    "name": "SWPPAL",
    "doc": "Swap quadword in memory atomically loads a 128-bit quadword from a memory location, and stores the value held in a pair of registers back to the same memory location. The value initially loaded from memory is returned in the same pair of registers."
  },
  {
    "name": "SXTB",
    "doc": "Signed byte / halfword / word extend (predicated)"
  },
  {
    "name": "SXTH",
    "doc": "Signed byte / halfword / word extend (predicated)"
  },
  {
    "name": "SXTL",
    "doc": "Signed extend Long. This instruction duplicates each vector element in the lower or upper half of the source SIMD&amp;FP register into a vector, and writes the vector to the destination SIMD&amp;FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are signed integer values."
  },
  {
    "name": "TRN",
    "doc": "Transpose vectors (primary). This instruction reads corresponding even-numbered vector elements from the two source SIMD&amp;FP registers, starting at zero, places each result into consecutive elements of a vector, and writes the vector to the destination SIMD&amp;FP register. Vector elements from the first source register are placed into even-numbered elements of the destination vector, starting at zero, while vector elements from the second source register are placed into odd-numbered elements of the destination vector."
  },
  {
    "name": "TSB",
    "doc": "Trace Synchronization Barrier. This instruction is a barrier that synchronizes the trace operations of instructions, see Trace Synchronization Buffer (TSB CSYNC)."
  },
  {
    "name": "TST",
    "doc": "Test bits (immediate), setting the condition flags and discarding the result\n\n: Rn AND imm."
  },
  {
    "name": "UABAL",
    "doc": "Unsigned Absolute difference and Accumulate Long. This instruction subtracts the vector elements in the lower or upper half of the second source SIMD&amp;FP register from the corresponding vector elements of the first source SIMD&amp;FP register, and accumulates the absolute values of the results into the vector elements of the destination SIMD&amp;FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are unsigned integer values."
  },
  {
    "name": "UABDL",
    "doc": "Unsigned Absolute Difference Long. This instruction subtracts the vector elements in the lower or upper half of the second source SIMD&amp;FP register from the corresponding vector elements of the first source SIMD&amp;FP register, places the absolute value of the result into a vector, and writes the vector to the destination SIMD&amp;FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are unsigned integer values."
  },
  {
    "name": "UADDL",
    "doc": "Unsigned Add Long (vector). This instruction adds each vector element in the lower or upper half of the first source SIMD&amp;FP register to the corresponding vector element of the second source SIMD&amp;FP register, places the result into a vector, and writes the vector to the destination SIMD&amp;FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are unsigned integer values."
  },
  {
    "name": "UADDW",
    "doc": "Unsigned Add Wide. This instruction adds the vector elements of the first source SIMD&amp;FP register to the corresponding vector elements in the lower or upper half of the second source SIMD&amp;FP register, places the result in a vector, and writes the vector to the SIMD&amp;FP destination register. The vector elements of the destination register and the first source register are twice as long as the vector elements of the second source register. All the values in this instruction are unsigned integer values."
  },
  {
    "name": "UCVTF",
    "doc": "Unsigned fixed-point Convert to Floating-point (vector). This instruction converts each element in a vector from fixed-point to floating-point using the rounding mode that is specified by the FPCR, and writes the result to the SIMD&amp;FP destination register."
  },
  {
    "name": "UDOT",
    "doc": "Dot Product unsigned arithmetic (vector, by element). This instruction performs the dot product of the four 8-bit elements in each 32-bit element of the first source register with the four 8-bit elements of an indexed 32-bit element in the second source register, accumulating the result into the corresponding 32-bit element of the destination register."
  },
  {
    "name": "UMAX",
    "doc": "Unsigned Maximum (immediate) determines the unsigned maximum of the source register value and immediate, and writes the result to the destination register."
  },
  {
    "name": "UMIN",
    "doc": "Unsigned Minimum (immediate) determines the unsigned minimum of the source register value and immediate, and writes the result to the destination register."
  },
  {
    "name": "UMLALB",
    "doc": "Unsigned multiply-add long to accumulator (bottom)"
  },
  {
    "name": "UMLALL",
    "doc": "Multi-vector unsigned integer multiply-add long-long by indexed element"
  },
  {
    "name": "UMLALT",
    "doc": "Unsigned multiply-add long to accumulator (top)"
  },
  {
    "name": "UMLAL",
    "doc": "Unsigned Multiply-Add Long (vector, by element). This instruction multiplies each vector element in the lower or upper half of the first source SIMD&amp;FP register by the specified vector element of the second source SIMD&amp;FP register and accumulates the results with the vector elements of the destination SIMD&amp;FP register. The destination vector elements are twice as long as the elements that are multiplied."
  },
  {
    "name": "UMLSLB",
    "doc": "Unsigned multiply-subtract long from accumulator (bottom)"
  },
  {
    "name": "UMLSLL",
    "doc": "Multi-vector unsigned integer multiply-subtract long-long by indexed element"
  },
  {
    "name": "UMLSLT",
    "doc": "Unsigned multiply-subtract long from accumulator (top)"
  },
  {
    "name": "UMLSL",
    "doc": "Unsigned Multiply-Subtract Long (vector, by element). This instruction multiplies each vector element in the lower or upper half of the first source SIMD&amp;FP register by the specified vector element of the second source SIMD&amp;FP register and subtracts the results from the vector elements of the destination SIMD&amp;FP register. The destination vector elements are twice as long as the elements that are multiplied."
  },
  {
    "name": "UMMLA",
    "doc": "Unsigned 8-bit integer matrix multiply-accumulate. This instruction multiplies the 2x8 matrix of unsigned 8-bit integer values in the first source vector by the 8x2 matrix of unsigned 8-bit integer values in the second source vector. The resulting 2x2 32-bit integer matrix product is destructively added to the 32-bit integer matrix accumulator in the destination vector. This is equivalent to performing an 8-way dot product per destination element."
  },
  {
    "name": "UMOPA",
    "doc": "Unsigned integer sum of outer products and accumulate"
  },
  {
    "name": "UMOPS",
    "doc": "Unsigned integer sum of outer products and subtract"
  },
  {
    "name": "UMULH",
    "doc": "Unsigned multiply returning high half (predicated)"
  },
  {
    "name": "UMULLB",
    "doc": "Unsigned multiply long (bottom)"
  },
  {
    "name": "UMULLT",
    "doc": "Unsigned multiply long (top)"
  },
  {
    "name": "UMULL",
    "doc": "Unsigned Multiply Long (vector, by element). This instruction multiplies each vector element in the lower or upper half of the first source SIMD&amp;FP register by the specified vector element of the second source SIMD&amp;FP register, places the results in a vector, and writes the vector to the destination SIMD&amp;FP register. The destination vector elements are twice as long as the elements that are multiplied."
  },
  {
    "name": "UQADD",
    "doc": "Unsigned saturating addition (predicated)"
  },
  {
    "name": "UQCVT",
    "doc": "Multi-vector unsigned saturating extract narrow"
  },
  {
    "name": "UQDECD",
    "doc": "Unsigned saturating decrement scalar by multiple of 64-bit predicate constraint element count"
  },
  {
    "name": "UQDECH",
    "doc": "Unsigned saturating decrement scalar by multiple of 16-bit predicate constraint element count"
  },
  {
    "name": "UQDECP",
    "doc": "Unsigned saturating decrement scalar by count of true predicate elements"
  },
  {
    "name": "UQDECW",
    "doc": "Unsigned saturating decrement scalar by multiple of 32-bit predicate constraint element count"
  },
  {
    "name": "UQINCD",
    "doc": "Unsigned saturating increment scalar by multiple of 64-bit predicate constraint element count"
  },
  {
    "name": "UQINCH",
    "doc": "Unsigned saturating increment scalar by multiple of 16-bit predicate constraint element count"
  },
  {
    "name": "UQINCP",
    "doc": "Unsigned saturating increment scalar by count of true predicate elements"
  },
  {
    "name": "UQINCW",
    "doc": "Unsigned saturating increment scalar by multiple of 32-bit predicate constraint element count"
  },
  {
    "name": "UQRSHRN",
    "doc": "Unsigned saturating Rounded Shift Right Narrow (immediate). This instruction reads each vector element in the source SIMD&amp;FP register, right shifts each result by an immediate value, puts the final result into a vector, and writes the vector to the lower or upper half of the destination SIMD&amp;FP register. All the values in this instruction are unsigned integer values. The results are rounded. For truncated results, see UQSHRN."
  },
  {
    "name": "UQRSHR",
    "doc": "Multi-vector unsigned saturating rounding shift right narrow by immediate"
  },
  {
    "name": "UQSHL",
    "doc": "Unsigned saturating Shift Left (immediate). This instruction takes each vector element in the source SIMD&amp;FP register, shifts it by an immediate value, places the results in a vector, and writes the vector to the destination SIMD&amp;FP register. The results are truncated. For rounded results, see UQRSHL."
  },
  {
    "name": "UQSHRN",
    "doc": "Unsigned saturating Shift Right Narrow (immediate). This instruction reads each vector element in the source SIMD&amp;FP register, right shifts each result by an immediate value, saturates each shifted result to a value that is half the original width, puts the final result into a vector, and writes the vector to the lower or upper half of the destination SIMD&amp;FP register. All the values in this instruction are unsigned integer values. The results are truncated. For rounded results, see UQRSHRN."
  },
  {
    "name": "UQSUB",
    "doc": "Unsigned saturating subtraction (predicated)"
  },
  {
    "name": "UQXTN",
    "doc": "Unsigned saturating extract Narrow. This instruction reads each vector element from the source SIMD&amp;FP register, saturates each value to half the original width, places the result into a vector, and writes the vector to the destination SIMD&amp;FP register. All the values in this instruction are unsigned integer values."
  },
  {
    "name": "URSHL",
    "doc": "Multi-vector unsigned rounding shift left by vector"
  },
  {
    "name": "USDOT",
    "doc": "Dot Product index form with unsigned and signed integers. This instruction performs the dot product of the four unsigned 8-bit integer values in each 32-bit element of the first source register with the four signed 8-bit integer values in an indexed 32-bit element of the second source register, accumulating the result into the corresponding 32-bit element of the destination register."
  },
  {
    "name": "USHLL",
    "doc": "Unsigned Shift Left Long (immediate). This instruction reads each vector element in the lower or upper half of the source SIMD&amp;FP register, shifts the unsigned integer value left by the specified number of bits, places the result into a vector, and writes the vector to the destination SIMD&amp;FP register. The destination vector elements are twice as long as the source vector elements."
  },
  {
    "name": "USMLALL",
    "doc": "Multi-vector unsigned by signed integer multiply-add long-long by indexed element"
  },
  {
    "name": "USMMLA",
    "doc": "Unsigned and signed 8-bit integer matrix multiply-accumulate. This instruction multiplies the 2x8 matrix of unsigned 8-bit integer values in the first source vector by the 8x2 matrix of signed 8-bit integer values in the second source vector. The resulting 2x2 32-bit integer matrix product is destructively added to the 32-bit integer matrix accumulator in the destination vector. This is equivalent to performing an 8-way dot product per destination element."
  },
  {
    "name": "USUBL",
    "doc": "Unsigned Subtract Long. This instruction subtracts each vector element in the lower or upper half of the second source SIMD&amp;FP register from the corresponding vector element of the first source SIMD&amp;FP register, places the result into a vector, and writes the vector to the destination SIMD&amp;FP register. All the values in this instruction are unsigned integer values. The destination vector elements are twice as long as the source vector elements."
  },
  {
    "name": "USUBW",
    "doc": "Unsigned Subtract Wide. This instruction subtracts each vector element of the second source SIMD&amp;FP register from the corresponding vector element in the lower or upper half of the first source SIMD&amp;FP register, places the result in a vector, and writes the vector to the SIMD&amp;FP destination register. All the values in this instruction are unsigned integer values."
  },
  {
    "name": "UUNPKHI",
    "doc": "Unsigned unpack and extend half of vector"
  },
  {
    "name": "UVDOT",
    "doc": "Multi-vector unsigned integer vertical dot-product by indexed element"
  },
  {
    "name": "UXTB",
    "doc": "Unsigned byte / halfword / word extend (predicated)"
  },
  {
    "name": "UXTH",
    "doc": "Unsigned byte / halfword / word extend (predicated)"
  },
  {
    "name": "UXTL",
    "doc": "Unsigned extend Long. This instruction copies each vector element from the lower or upper half of the source SIMD&amp;FP register into a vector, and writes the vector to the destination SIMD&amp;FP register. The destination vector elements are twice as long as the source vector elements."
  },
  {
    "name": "UZP",
    "doc": "Unzip vectors (primary). This instruction reads corresponding even-numbered vector elements from the two source SIMD&amp;FP registers, starting at zero, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "UZPQ",
    "doc": "Concatenate even elements within each pair of quadword vector segments"
  },
  {
    "name": "WHILEGE",
    "doc": "While decrementing signed scalar greater than or equal to scalar (predicate-as-counter)"
  },
  {
    "name": "WHILEGT",
    "doc": "While decrementing signed scalar greater than scalar (predicate-as-counter)"
  },
  {
    "name": "WHILEHI",
    "doc": "While decrementing unsigned scalar higher than scalar (predicate-as-counter)"
  },
  {
    "name": "WHILEHS",
    "doc": "While decrementing unsigned scalar higher or same as scalar (predicate-as-counter)"
  },
  {
    "name": "WHILELE",
    "doc": "While incrementing signed scalar less than or equal to scalar (predicate-as-counter)"
  },
  {
    "name": "WHILELO",
    "doc": "While incrementing unsigned scalar lower than scalar (predicate-as-counter)"
  },
  {
    "name": "WHILELS",
    "doc": "While incrementing unsigned scalar lower or same as scalar (predicate-as-counter)"
  },
  {
    "name": "WHILELT",
    "doc": "While incrementing signed scalar less than scalar (predicate-as-counter)"
  },
  {
    "name": "XPACD",
    "doc": "Strip Pointer Authentication Code. This instruction removes the pointer authentication code from an address. The address is in the specified general-purpose register for XPACI and XPACD, and is in LR for XPACLRI."
  },
  {
    "name": "XPACI",
    "doc": "Strip Pointer Authentication Code. This instruction removes the pointer authentication code from an address. The address is in the specified general-purpose register for XPACI and XPACD, and is in LR for XPACLRI."
  },
  {
    "name": "XTN",
    "doc": "Extract Narrow. This instruction reads each vector element from the source SIMD&amp;FP register, narrows each value to half the original width, places the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&amp;FP register. The destination vector elements are half as long as the source vector elements."
  },
  {
    "name": "ZERO",
    "doc": "Zero ZA single-vector groups"
  },
  {
    "name": "ZIP",
    "doc": "Zip vectors (primary). This instruction reads adjacent vector elements from the lower half of two source SIMD&amp;FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&amp;FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register."
  },
  {
    "name": "ZIPQ",
    "doc": "Interleave elements from low halves of each pair of quadword vector segments"
  }
]
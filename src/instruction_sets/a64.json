[
  {
    "name": "ABS",
    "doc": "Absolute value computes the absolute value of the signed integer value in the source register, and writes the result to the destination register."
  },
  {
    "name": "ADC",
    "doc": "Add with Carry adds two register values and the Carry flag value, and writes the result to the destination register."
  },
  {
    "name": "ADCLB",
    "doc": "Add with carry long (bottom)"
  },
  {
    "name": "ADCLT",
    "doc": "Add with carry long (top)"
  },
  {
    "name": "ADCS",
    "doc": "Add with Carry, setting flags, adds two register values and the Carry flag value, and writes the result to the destination register. It updates the condition flags based on the result."
  },
  {
    "name": "ADDG",
    "doc": "Add with Tag adds an immediate value scaled by the Tag granule to the address in the source register, modifies the Logical Address Tag of the address using an immediate value, and writes the result to the destination register. Tags specified in GCR_EL1.Exclude are excluded from the possible outputs when modifying the Logical Address Tag."
  },
  {
    "name": "ADDHA",
    "doc": "Add horizontally vector elements to ZA tile"
  },
  {
    "name": "ADDHNB",
    "doc": "Add narrow high part (bottom)"
  },
  {
    "name": "ADDHNT",
    "doc": "Add narrow high part (top)"
  },
  {
    "name": "ADDHN",
    "doc": "Add returning High Narrow. This instruction adds each vector element in the first source SIMD&amp;FP register to the corresponding vector element in the second source SIMD&amp;FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&amp;FP register."
  },
  {
    "name": "ADDHN2",
    "doc": "Add returning High Narrow. This instruction adds each vector element in the first source SIMD&amp;FP register to the corresponding vector element in the second source SIMD&amp;FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&amp;FP register."
  },
  {
    "name": "ADDPL",
    "doc": "Add multiple of predicate register size to scalar register"
  },
  {
    "name": "ADDP",
    "doc": "Add Pair of elements (scalar). This instruction adds two vector elements in the source SIMD&amp;FP register and writes the scalar result into the destination SIMD&amp;FP register."
  },
  {
    "name": "ADDQV",
    "doc": "Unsigned add reduction of quadword vector segments"
  },
  {
    "name": "ADDSPL",
    "doc": "Add multiple of Streaming SVE predicate register size to scalar register"
  },
  {
    "name": "ADDSVL",
    "doc": "Add multiple of Streaming SVE vector register size to scalar register"
  },
  {
    "name": "ADDS",
    "doc": "Add (extended register), setting flags, adds a register value and a sign or zero-extended register value, followed by an optional left shift amount, and writes the result to the destination register. The argument that is extended from the &lt;Rm&gt; register can be a byte, halfword, word, or doubleword. It updates the condition flags based on the result."
  },
  {
    "name": "ADDVA",
    "doc": "Add vertically vector elements to ZA tile"
  },
  {
    "name": "ADDVL",
    "doc": "Add multiple of vector register size to scalar register"
  },
  {
    "name": "ADDV",
    "doc": "Add across Vector. This instruction adds every vector element in the source SIMD&amp;FP register together, and writes the scalar result to the destination SIMD&amp;FP register."
  },
  {
    "name": "ADD",
    "doc": "Add (extended register) adds a register value and a sign or zero-extended register value, followed by an optional left shift amount, and writes the result to the destination register. The argument that is extended from the &lt;Rm&gt; register can be a byte, halfword, word, or doubleword."
  },
  {
    "name": "ADR",
    "doc": "Form PC-relative address adds an immediate value to the PC value to form a PC-relative address, and writes the result to the destination register."
  },
  {
    "name": "ADRP",
    "doc": "Form PC-relative address to 4KB page adds an immediate value that is shifted left by 12 bits, to the PC value to form a PC-relative address, with the bottom 12 bits masked out, and writes the result to the destination register."
  },
  {
    "name": "AESD",
    "doc": "AES single round decryption."
  },
  {
    "name": "AESE",
    "doc": "AES single round encryption."
  },
  {
    "name": "AESIMC",
    "doc": "AES inverse mix columns."
  },
  {
    "name": "AESMC",
    "doc": "AES mix columns."
  },
  {
    "name": "ANDQV",
    "doc": "Bitwise AND reduction of quadword vector segments"
  },
  {
    "name": "ANDS",
    "doc": "Bitwise AND (immediate), setting flags, performs a bitwise AND of a register value and an immediate value, and writes the result to the destination register. It updates the condition flags based on the result."
  },
  {
    "name": "ANDV",
    "doc": "Bitwise AND reduction to scalar"
  },
  {
    "name": "AND",
    "doc": "Bitwise AND (vector). This instruction performs a bitwise AND between the two source SIMD&amp;FP registers, and writes the result to the destination SIMD&amp;FP register."
  },
  {
    "name": "ASRD",
    "doc": "Arithmetic shift right for divide by immediate (predicated)"
  },
  {
    "name": "ASRR",
    "doc": "Reversed arithmetic shift right by vector (predicated)"
  },
  {
    "name": "ASRV",
    "doc": "Arithmetic Shift Right Variable shifts a register value right by a variable number of bits, shifting in copies of its sign bit, and writes the result to the destination register. The remainder obtained by dividing the second source register by the data size defines the number of bits by which the first source register is right-shifted."
  },
  {
    "name": "ASR",
    "doc": "Arithmetic Shift Right (register) shifts a register value right by a variable number of bits, shifting in copies of its sign bit, and writes the result to the destination register. The remainder obtained by dividing the second source register by the data size defines the number of bits by which the first source register is right-shifted."
  },
  {
    "name": "AT",
    "doc": "Address Translate. For more information, see op0==0b01, cache maintenance, TLB maintenance, and address translation instructions."
  },
  {
    "name": "AUTDA",
    "doc": "Authenticate Data address, using key A. This instruction authenticates a data address, using a modifier and key A."
  },
  {
    "name": "AUTDZA",
    "doc": "Authenticate Data address, using key A. This instruction authenticates a data address, using a modifier and key A."
  },
  {
    "name": "AUTDB",
    "doc": "Authenticate Data address, using key B. This instruction authenticates a data address, using a modifier and key B."
  },
  {
    "name": "AUTDZB",
    "doc": "Authenticate Data address, using key B. This instruction authenticates a data address, using a modifier and key B."
  },
  {
    "name": "AUTIA",
    "doc": "Authenticate Instruction address, using key A. This instruction authenticates an instruction address, using a modifier and key A."
  },
  {
    "name": "AUTIA1716",
    "doc": "Authenticate Instruction address, using key A. This instruction authenticates an instruction address, using a modifier and key A."
  },
  {
    "name": "AUTIASP",
    "doc": "Authenticate Instruction address, using key A. This instruction authenticates an instruction address, using a modifier and key A."
  },
  {
    "name": "AUTIAZ",
    "doc": "Authenticate Instruction address, using key A. This instruction authenticates an instruction address, using a modifier and key A."
  },
  {
    "name": "AUTIZA",
    "doc": "Authenticate Instruction address, using key A. This instruction authenticates an instruction address, using a modifier and key A."
  },
  {
    "name": "AUTIB",
    "doc": "Authenticate Instruction address, using key B. This instruction authenticates an instruction address, using a modifier and key B."
  },
  {
    "name": "AUTIB1716",
    "doc": "Authenticate Instruction address, using key B. This instruction authenticates an instruction address, using a modifier and key B."
  },
  {
    "name": "AUTIBSP",
    "doc": "Authenticate Instruction address, using key B. This instruction authenticates an instruction address, using a modifier and key B."
  },
  {
    "name": "AUTIBZ",
    "doc": "Authenticate Instruction address, using key B. This instruction authenticates an instruction address, using a modifier and key B."
  },
  {
    "name": "AUTIZB",
    "doc": "Authenticate Instruction address, using key B. This instruction authenticates an instruction address, using a modifier and key B."
  },
  {
    "name": "AXFLAG",
    "doc": "Convert floating-point condition flags from Arm to external format. This instruction converts the state of the PSTATE.{N,Z,C,V} flags from a form representing the result of an Arm floating-point scalar compare instruction to an alternative representation required by some software."
  },
  {
    "name": "BCAX",
    "doc": "Bit Clear and exclusive-OR performs a bitwise AND of the 128-bit vector in a source SIMD&amp;FP register and the complement of the vector in another source SIMD&amp;FP register, then performs a bitwise exclusive-OR of the resulting vector and the vector in a third source SIMD&amp;FP register, and writes the result to the destination SIMD&amp;FP register."
  },
  {
    "name": "BC",
    "doc": "Branch Consistent conditionally to a label at a PC-relative offset, with a hint that this branch will behave very consistently and is very unlikely to change direction."
  },
  {
    "name": "BDEP",
    "doc": "Scatter lower bits into positions selected by bitmask"
  },
  {
    "name": "BEXT",
    "doc": "Gather lower bits from positions selected by bitmask"
  },
  {
    "name": "BFADD",
    "doc": "BFloat16 floating-point add multi-vector to ZA array vector accumulators"
  },
  {
    "name": "BFCLAMP",
    "doc": "Multi-vector BFloat16 floating-point clamp to minimum/maximum number"
  },
  {
    "name": "BFCVTNT",
    "doc": "Floating-point down convert and narrow to BFloat16 (top, predicated)"
  },
  {
    "name": "BFCVTN",
    "doc": "Floating-point convert from single-precision to BFloat16 format (vector) reads each single-precision element in the SIMD&amp;FP source vector, converts each value to BFloat16 format, and writes the results in the lower or upper half of the SIMD&amp;FP destination vector. The result elements are half the width of the source elements."
  },
  {
    "name": "BFCVTN2",
    "doc": "Floating-point convert from single-precision to BFloat16 format (vector) reads each single-precision element in the SIMD&amp;FP source vector, converts each value to BFloat16 format, and writes the results in the lower or upper half of the SIMD&amp;FP destination vector. The result elements are half the width of the source elements."
  },
  {
    "name": "BFCVT",
    "doc": "Floating-point convert from single-precision to BFloat16 format (scalar) converts the single-precision floating-point value in the 32-bit SIMD&amp;FP source register to BFloat16 format and writes the result in the 16-bit SIMD&amp;FP destination register."
  },
  {
    "name": "BFC",
    "doc": "Bitfield Clear sets a bitfield of &lt;width&gt; bits at bit position &lt;lsb&gt; of the destination register to zero, leaving the other destination bits unchanged."
  },
  {
    "name": "BFDOT",
    "doc": "BFloat16 floating-point dot product (vector, by element). This instruction delimits the source vectors into pairs of BFloat16 elements. The BFloat16 pair within the second source vector is specified using an immediate index. The index range is from 0 to 3 inclusive."
  },
  {
    "name": "BFI",
    "doc": "Bitfield Insert copies a bitfield of &lt;width&gt; bits from the least significant bits of the source register to bit position &lt;lsb&gt; of the destination register, leaving the other destination bits unchanged."
  },
  {
    "name": "BFM",
    "doc": "Bitfield Move is usually accessed via one of its aliases, which are always preferred for disassembly."
  },
  {
    "name": "BFMAXNM",
    "doc": "Multi-vector BFloat16 floating-point maximum number by vector"
  },
  {
    "name": "BFMAX",
    "doc": "Multi-vector BFloat16 floating-point maximum by vector"
  },
  {
    "name": "BFMINNM",
    "doc": "Multi-vector BFloat16 floating-point minimum number by vector"
  },
  {
    "name": "BFMIN",
    "doc": "Multi-vector BFloat16 floating-point minimum by vector"
  },
  {
    "name": "BFMLALB",
    "doc": "BFloat16 floating-point multiply-add long to single-precision (bottom)"
  },
  {
    "name": "BFMLALT",
    "doc": "BFloat16 floating-point multiply-add long to single-precision (top)"
  },
  {
    "name": "BFMLAL",
    "doc": "Multi-vector BFloat16 floating-point multiply-add long by indexed element"
  },
  {
    "name": "BFMLA",
    "doc": "Multi-vector BFloat16 floating-point fused multiply-add by indexed element"
  },
  {
    "name": "BFMLSLB",
    "doc": "BFloat16 floating-point multiply-subtract long from single-precision (bottom)"
  },
  {
    "name": "BFMLSLT",
    "doc": "BFloat16 floating-point multiply-subtract long from single-precision (top)"
  },
  {
    "name": "BFMLSL",
    "doc": "Multi-vector BFloat16 floating-point multiply-subtract long by indexed element"
  },
  {
    "name": "BFMLS",
    "doc": "Multi-vector BFloat16 floating-point fused multiply-subtract by indexed element"
  },
  {
    "name": "BFMMLA",
    "doc": "BFloat16 floating-point matrix multiply-accumulate into 2x2 matrix."
  },
  {
    "name": "BFMOPA",
    "doc": "BFloat16 sum of outer products and accumulate"
  },
  {
    "name": "BFMOPS",
    "doc": "BFloat16 sum of outer products and subtract"
  },
  {
    "name": "BFMUL",
    "doc": "BFloat16 floating-point multiply vectors (predicated)"
  },
  {
    "name": "BFSUB",
    "doc": "BFloat16 floating-point subtract multi-vector from ZA array vector accumulators"
  },
  {
    "name": "BFVDOT",
    "doc": "Multi-vector BFloat16 floating-point vertical dot-product by indexed element"
  },
  {
    "name": "BFXIL",
    "doc": "Bitfield Extract and Insert Low copies a bitfield of &lt;width&gt; bits starting from bit position &lt;lsb&gt; in the source register to the least significant bits of the destination register, leaving the other destination bits unchanged."
  },
  {
    "name": "BGRP",
    "doc": "Group bits to right or left as selected by bitmask"
  },
  {
    "name": "BICS",
    "doc": "Bitwise Bit Clear (shifted register), setting flags, performs a bitwise AND of a register value and the complement of an optionally-shifted register value, and writes the result to the destination register. It updates the condition flags based on the result."
  },
  {
    "name": "BIC",
    "doc": "Bitwise bit Clear (vector, immediate). This instruction reads each vector element from the destination SIMD&amp;FP register, performs a bitwise AND between each result and the complement of an immediate constant, places the result into a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "BIF",
    "doc": "Bitwise Insert if False. This instruction inserts each bit from the first source SIMD&amp;FP register into the destination SIMD&amp;FP register if the corresponding bit of the second source SIMD&amp;FP register is 0, otherwise leaves the bit in the destination register unchanged."
  },
  {
    "name": "BIT",
    "doc": "Bitwise Insert if True. This instruction inserts each bit from the first source SIMD&amp;FP register into the SIMD&amp;FP destination register if the corresponding bit of the second source SIMD&amp;FP register is 1, otherwise leaves the bit in the destination register unchanged."
  },
  {
    "name": "BL",
    "doc": "Branch with Link branches to a PC-relative offset, setting the register X30 to PC+4. It provides a hint that this is a subroutine call."
  },
  {
    "name": "BLR",
    "doc": "Branch with Link to Register calls a subroutine at an address in a register, setting register X30 to PC+4."
  },
  {
    "name": "BLRAA",
    "doc": "Branch with Link to Register, with pointer authentication. This instruction authenticates the address in the general-purpose register that is specified by &lt;Xn&gt;, using a modifier and the specified key, and calls a subroutine at the authenticated address, setting register X30 to PC+4."
  },
  {
    "name": "BLRAAZ",
    "doc": "Branch with Link to Register, with pointer authentication. This instruction authenticates the address in the general-purpose register that is specified by &lt;Xn&gt;, using a modifier and the specified key, and calls a subroutine at the authenticated address, setting register X30 to PC+4."
  },
  {
    "name": "BLRAB",
    "doc": "Branch with Link to Register, with pointer authentication. This instruction authenticates the address in the general-purpose register that is specified by &lt;Xn&gt;, using a modifier and the specified key, and calls a subroutine at the authenticated address, setting register X30 to PC+4."
  },
  {
    "name": "BLRABZ",
    "doc": "Branch with Link to Register, with pointer authentication. This instruction authenticates the address in the general-purpose register that is specified by &lt;Xn&gt;, using a modifier and the specified key, and calls a subroutine at the authenticated address, setting register X30 to PC+4."
  },
  {
    "name": "BMOPA",
    "doc": "Bitwise exclusive NOR population count outer product and accumulate"
  },
  {
    "name": "BMOPS",
    "doc": "Bitwise exclusive NOR population count outer product and subtract"
  },
  {
    "name": "BR",
    "doc": "Branch to Register branches unconditionally to an address in a register, with a hint that this is not a subroutine return."
  },
  {
    "name": "BRAA",
    "doc": "Branch to Register, with pointer authentication. This instruction authenticates the address in the general-purpose register that is specified by &lt;Xn&gt;, using a modifier and the specified key, and branches to the authenticated address."
  },
  {
    "name": "BRAAZ",
    "doc": "Branch to Register, with pointer authentication. This instruction authenticates the address in the general-purpose register that is specified by &lt;Xn&gt;, using a modifier and the specified key, and branches to the authenticated address."
  },
  {
    "name": "BRAB",
    "doc": "Branch to Register, with pointer authentication. This instruction authenticates the address in the general-purpose register that is specified by &lt;Xn&gt;, using a modifier and the specified key, and branches to the authenticated address."
  },
  {
    "name": "BRABZ",
    "doc": "Branch to Register, with pointer authentication. This instruction authenticates the address in the general-purpose register that is specified by &lt;Xn&gt;, using a modifier and the specified key, and branches to the authenticated address."
  },
  {
    "name": "BRB",
    "doc": "Branch Record Buffer. For more information, see op0==0b01, cache maintenance, TLB maintenance, and address translation instructions."
  },
  {
    "name": "BRK",
    "doc": "Breakpoint instruction. A BRK instruction generates a Breakpoint Instruction exception. The PE records the exception in ESR_ELx, using the EC value 0x3c, and captures the value of the immediate argument in ESR_ELx.ISS."
  },
  {
    "name": "BRKAS",
    "doc": "Break after first true condition, setting the condition flags"
  },
  {
    "name": "BRKA",
    "doc": "Break after first true condition"
  },
  {
    "name": "BRKBS",
    "doc": "Break before first true condition, setting the condition flags"
  },
  {
    "name": "BRKB",
    "doc": "Break before first true condition"
  },
  {
    "name": "BRKNS",
    "doc": "Propagate break to next partition, setting the condition flags"
  },
  {
    "name": "BRKN",
    "doc": "Propagate break to next partition"
  },
  {
    "name": "BRKPAS",
    "doc": "Break after first true condition, propagating from previous partition and setting the condition flags"
  },
  {
    "name": "BRKPA",
    "doc": "Break after first true condition, propagating from previous partition"
  },
  {
    "name": "BRKPBS",
    "doc": "Break before first true condition, propagating from previous partition and setting the condition flags"
  },
  {
    "name": "BRKPB",
    "doc": "Break before first true condition, propagating from previous partition"
  },
  {
    "name": "BSL1N",
    "doc": "Bitwise select with first input inverted"
  },
  {
    "name": "BSL2N",
    "doc": "Bitwise select with second input inverted"
  },
  {
    "name": "BSL",
    "doc": "Bitwise Select. This instruction sets each bit in the destination SIMD&amp;FP register to the corresponding bit from the first source SIMD&amp;FP register when the original destination bit was 1, otherwise from the second source SIMD&amp;FP register."
  },
  {
    "name": "BTI",
    "doc": "Branch Target Identification. A BTI instruction is used to guard against the execution of instructions which are not the intended target of a branch."
  },
  {
    "name": "B",
    "doc": "Branch conditionally to a label at a PC-relative offset, with a hint that this is not a subroutine call or return."
  },
  {
    "name": "CADD",
    "doc": "Complex integer add with rotate"
  },
  {
    "name": "CAS",
    "doc": "Compare and Swap word or doubleword in memory reads a 32-bit word or 64-bit doubleword from memory, and compares it against the value held in a first register. If the comparison is equal, the value in a second register is written to memory. If the write is performed, the read and write occur atomically such that no other modification of the memory location can take place between the read and write."
  },
  {
    "name": "CASA",
    "doc": "Compare and Swap word or doubleword in memory reads a 32-bit word or 64-bit doubleword from memory, and compares it against the value held in a first register. If the comparison is equal, the value in a second register is written to memory. If the write is performed, the read and write occur atomically such that no other modification of the memory location can take place between the read and write."
  },
  {
    "name": "CASAL",
    "doc": "Compare and Swap word or doubleword in memory reads a 32-bit word or 64-bit doubleword from memory, and compares it against the value held in a first register. If the comparison is equal, the value in a second register is written to memory. If the write is performed, the read and write occur atomically such that no other modification of the memory location can take place between the read and write."
  },
  {
    "name": "CASL",
    "doc": "Compare and Swap word or doubleword in memory reads a 32-bit word or 64-bit doubleword from memory, and compares it against the value held in a first register. If the comparison is equal, the value in a second register is written to memory. If the write is performed, the read and write occur atomically such that no other modification of the memory location can take place between the read and write."
  },
  {
    "name": "CASB",
    "doc": "Compare and Swap byte in memory reads an 8-bit byte from memory, and compares it against the value held in a first register. If the comparison is equal, the value in a second register is written to memory. If the write is performed, the read and write occur atomically such that no other modification of the memory location can take place between the read and write."
  },
  {
    "name": "CASAB",
    "doc": "Compare and Swap byte in memory reads an 8-bit byte from memory, and compares it against the value held in a first register. If the comparison is equal, the value in a second register is written to memory. If the write is performed, the read and write occur atomically such that no other modification of the memory location can take place between the read and write."
  },
  {
    "name": "CASALB",
    "doc": "Compare and Swap byte in memory reads an 8-bit byte from memory, and compares it against the value held in a first register. If the comparison is equal, the value in a second register is written to memory. If the write is performed, the read and write occur atomically such that no other modification of the memory location can take place between the read and write."
  },
  {
    "name": "CASLB",
    "doc": "Compare and Swap byte in memory reads an 8-bit byte from memory, and compares it against the value held in a first register. If the comparison is equal, the value in a second register is written to memory. If the write is performed, the read and write occur atomically such that no other modification of the memory location can take place between the read and write."
  },
  {
    "name": "CASH",
    "doc": "Compare and Swap halfword in memory reads a 16-bit halfword from memory, and compares it against the value held in a first register. If the comparison is equal, the value in a second register is written to memory. If the write is performed, the read and write occur atomically such that no other modification of the memory location can take place between the read and write."
  },
  {
    "name": "CASAH",
    "doc": "Compare and Swap halfword in memory reads a 16-bit halfword from memory, and compares it against the value held in a first register. If the comparison is equal, the value in a second register is written to memory. If the write is performed, the read and write occur atomically such that no other modification of the memory location can take place between the read and write."
  },
  {
    "name": "CASALH",
    "doc": "Compare and Swap halfword in memory reads a 16-bit halfword from memory, and compares it against the value held in a first register. If the comparison is equal, the value in a second register is written to memory. If the write is performed, the read and write occur atomically such that no other modification of the memory location can take place between the read and write."
  },
  {
    "name": "CASLH",
    "doc": "Compare and Swap halfword in memory reads a 16-bit halfword from memory, and compares it against the value held in a first register. If the comparison is equal, the value in a second register is written to memory. If the write is performed, the read and write occur atomically such that no other modification of the memory location can take place between the read and write."
  },
  {
    "name": "CASP",
    "doc": "Compare and Swap Pair of words or doublewords in memory reads a pair of 32-bit words or 64-bit doublewords from memory, and compares them against the values held in the first pair of registers. If the comparison is equal, the values in the second pair of registers are written to memory. If the writes are performed, the reads and writes occur atomically such that no other modification of the memory location can take place between the reads and writes."
  },
  {
    "name": "CASPA",
    "doc": "Compare and Swap Pair of words or doublewords in memory reads a pair of 32-bit words or 64-bit doublewords from memory, and compares them against the values held in the first pair of registers. If the comparison is equal, the values in the second pair of registers are written to memory. If the writes are performed, the reads and writes occur atomically such that no other modification of the memory location can take place between the reads and writes."
  },
  {
    "name": "CASPAL",
    "doc": "Compare and Swap Pair of words or doublewords in memory reads a pair of 32-bit words or 64-bit doublewords from memory, and compares them against the values held in the first pair of registers. If the comparison is equal, the values in the second pair of registers are written to memory. If the writes are performed, the reads and writes occur atomically such that no other modification of the memory location can take place between the reads and writes."
  },
  {
    "name": "CASPL",
    "doc": "Compare and Swap Pair of words or doublewords in memory reads a pair of 32-bit words or 64-bit doublewords from memory, and compares them against the values held in the first pair of registers. If the comparison is equal, the values in the second pair of registers are written to memory. If the writes are performed, the reads and writes occur atomically such that no other modification of the memory location can take place between the reads and writes."
  },
  {
    "name": "CBNZ",
    "doc": "Compare and Branch on Nonzero compares the value in a register with zero, and conditionally branches to a label at a PC-relative offset if the comparison is not equal. It provides a hint that this is not a subroutine call or return. This instruction does not affect the condition flags."
  },
  {
    "name": "CBZ",
    "doc": "Compare and Branch on Zero compares the value in a register with zero, and conditionally branches to a label at a PC-relative offset if the comparison is equal. It provides a hint that this is not a subroutine call or return. This instruction does not affect condition flags."
  },
  {
    "name": "CCMN",
    "doc": "Conditional Compare Negative (immediate) sets the value of the condition flags to the result of the comparison of a register value and a negated immediate value if the condition is TRUE, and an immediate value otherwise."
  },
  {
    "name": "CCMP",
    "doc": "Conditional Compare (immediate) sets the value of the condition flags to the result of the comparison of a register value and an immediate value if the condition is TRUE, and an immediate value otherwise."
  },
  {
    "name": "CDOT",
    "doc": "Complex integer dot product"
  },
  {
    "name": "CFINV",
    "doc": "Invert Carry Flag. This instruction inverts the value of the PSTATE.C flag."
  },
  {
    "name": "CFP",
    "doc": "Control Flow Prediction Restriction by Context prevents control flow predictions that predict execution addresses based on information gathered from earlier execution within a particular execution context. Control flow predictions determined by the actions of code in the target execution context or contexts appearing in program order before the instruction cannot be used to exploitatively control speculative execution occurring after the instruction is complete and synchronized."
  },
  {
    "name": "CHKFEAT",
    "doc": "Check feature status. This instruction indicates the status of features."
  },
  {
    "name": "CINC",
    "doc": "Conditional Increment returns, in the destination register, the value of the source register incremented by 1 if the condition is TRUE, and otherwise returns the value of the source register."
  },
  {
    "name": "CINV",
    "doc": "Conditional Invert returns, in the destination register, the bitwise inversion of the value of the source register if the condition is TRUE, and otherwise returns the value of the source register."
  },
  {
    "name": "CLASTA",
    "doc": "Conditionally extract element after last to general-purpose register"
  },
  {
    "name": "SIMD",
    "doc": "Conditionally extract element after last to SIMD&amp;FP scalar register"
  },
  {
    "name": "CLASTB",
    "doc": "Conditionally extract last element to general-purpose register"
  },
  {
    "name": "CLRBHB",
    "doc": "Clear Branch History clears the branch history for the current context to the extent that branch history information created before the CLRBHB instruction cannot be used by code before the CLRBHB instruction to exploitatively control the execution of any indirect branches in code in the current context that appear in program order after the instruction."
  },
  {
    "name": "CLREX",
    "doc": "Clear Exclusive clears the local monitor of the executing PE."
  },
  {
    "name": "CLS",
    "doc": "Count Leading Sign bits (vector). This instruction counts the number of consecutive bits following the most significant bit that are the same as the most significant bit in each vector element in the source SIMD&amp;FP register, places the result into a vector, and writes the vector to the destination SIMD&amp;FP register. The count does not include the most significant bit itself."
  },
  {
    "name": "CLZ",
    "doc": "Count Leading Zero bits (vector). This instruction counts the number of consecutive zeros, starting from the most significant bit, in each vector element in the source SIMD&amp;FP register, places the result into a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "CMEQ",
    "doc": "Compare bitwise Equal (vector). This instruction compares each vector element from the first source SIMD&amp;FP register with the corresponding vector element from the second source SIMD&amp;FP register, and if the comparison is equal sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to zero."
  },
  {
    "name": "CMGE",
    "doc": "Compare signed Greater than or Equal (vector). This instruction compares each vector element in the first source SIMD&amp;FP register with the corresponding vector element in the second source SIMD&amp;FP register and if the first signed integer value is greater than or equal to the second signed integer value sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to zero."
  },
  {
    "name": "CMGT",
    "doc": "Compare signed Greater than (vector). This instruction compares each vector element in the first source SIMD&amp;FP register with the corresponding vector element in the second source SIMD&amp;FP register and if the first signed integer value is greater than the second signed integer value sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to zero."
  },
  {
    "name": "CMHI",
    "doc": "Compare unsigned Higher (vector). This instruction compares each vector element in the first source SIMD&amp;FP register with the corresponding vector element in the second source SIMD&amp;FP register and if the first unsigned integer value is greater than the second unsigned integer value sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to zero."
  },
  {
    "name": "CMHS",
    "doc": "Compare unsigned Higher or Same (vector). This instruction compares each vector element in the first source SIMD&amp;FP register with the corresponding vector element in the second source SIMD&amp;FP register and if the first unsigned integer value is greater than or equal to the second unsigned integer value sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to zero."
  },
  {
    "name": "CMLA",
    "doc": "Complex integer multiply-add with rotate"
  },
  {
    "name": "CMLE",
    "doc": "Compare signed Less than or Equal to zero (vector). This instruction reads each vector element in the source SIMD&amp;FP register and if the signed integer value is less than or equal to zero sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to zero."
  },
  {
    "name": "CMLT",
    "doc": "Compare signed Less than zero (vector). This instruction reads each vector element in the source SIMD&amp;FP register and if the signed integer value is less than zero sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to zero."
  },
  {
    "name": "CMN",
    "doc": "Compare Negative (extended register) adds a register value and a sign or zero-extended register value, followed by an optional left shift amount. The argument that is extended from the &lt;Rm&gt; register can be a byte, halfword, word, or doubleword. It updates the condition flags based on the result, and discards the result."
  },
  {
    "name": "CMP",
    "doc": "Compare vector to immediate"
  },
  {
    "name": "CMPLE",
    "doc": "Compare signed less than or equal to vector, setting the condition flags"
  },
  {
    "name": "CMPLO",
    "doc": "Compare unsigned lower than vector, setting the condition flags"
  },
  {
    "name": "CMPLS",
    "doc": "Compare unsigned lower or same as vector, setting the condition flags"
  },
  {
    "name": "CMPLT",
    "doc": "Compare signed less than vector, setting the condition flags"
  },
  {
    "name": "CMPP",
    "doc": "Compare with Tag subtracts the 56-bit address held in the second source register from the 56-bit address held in the first source register, updates the condition flags based on the result of the subtraction, and discards the result."
  },
  {
    "name": "CMTST",
    "doc": "Compare bitwise Test bits nonzero (vector). This instruction reads each vector element in the first source SIMD&amp;FP register, performs an AND with the corresponding vector element in the second source SIMD&amp;FP register, and if the result is not zero, sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to zero."
  },
  {
    "name": "CNEG",
    "doc": "Conditional Negate returns, in the destination register, the negated value of the source register if the condition is TRUE, and otherwise returns the value of the source register."
  },
  {
    "name": "CNOT",
    "doc": "Logically invert boolean condition in vector (predicated)"
  },
  {
    "name": "CNT",
    "doc": "Count bits counts the number of binary one bits in the value of the source register, and writes the result to the destination register."
  },
  {
    "name": "CNTB",
    "doc": "Set scalar to multiple of predicate constraint element count"
  },
  {
    "name": "CNTD",
    "doc": "Set scalar to multiple of predicate constraint element count"
  },
  {
    "name": "CNTH",
    "doc": "Set scalar to multiple of predicate constraint element count"
  },
  {
    "name": "CNTW",
    "doc": "Set scalar to multiple of predicate constraint element count"
  },
  {
    "name": "CNTP",
    "doc": "Set scalar to count from predicate-as-counter"
  },
  {
    "name": "COMPACT",
    "doc": "Shuffle active elements of vector to the right and fill with zero"
  },
  {
    "name": "COSP",
    "doc": "Clear Other Speculative Prediction Restriction by Context prevents predictions, other than Cache prefetch, Control flow, and Data Value predictions, that predict execution addresses based on information gathered from earlier execution within a particular execution context. Predictions, other than Cache prefetch, Control flow, and Data Value predictions, determined by the actions of code in the target execution context or contexts appearing in program order before the instruction cannot exploitatively control any speculative access occurring after the instruction is complete and synchronized."
  },
  {
    "name": "CPP",
    "doc": "Cache Prefetch Prediction Restriction by Context prevents cache allocation predictions that predict execution addresses based on information gathered from earlier execution within a particular execution context. The actions of code in the target execution context or contexts appearing in program order before the instruction cannot exploitatively control cache prefetch predictions occurring after the instruction is complete and synchronized."
  },
  {
    "name": "CPYFP",
    "doc": "Memory Copy Forward-only. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFP, then CPYFM, and then CPYFE."
  },
  {
    "name": "CPYFM",
    "doc": "Memory Copy Forward-only. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFP, then CPYFM, and then CPYFE."
  },
  {
    "name": "CPYFE",
    "doc": "Memory Copy Forward-only. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFP, then CPYFM, and then CPYFE."
  },
  {
    "name": "CPYFPN",
    "doc": "Memory Copy Forward-only, reads and writes non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPN, then CPYFMN, and then CPYFEN."
  },
  {
    "name": "CPYFMN",
    "doc": "Memory Copy Forward-only, reads and writes non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPN, then CPYFMN, and then CPYFEN."
  },
  {
    "name": "CPYFEN",
    "doc": "Memory Copy Forward-only, reads and writes non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPN, then CPYFMN, and then CPYFEN."
  },
  {
    "name": "CPYFPRN",
    "doc": "Memory Copy Forward-only, reads non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPRN, then CPYFMRN, and then CPYFERN."
  },
  {
    "name": "CPYFMRN",
    "doc": "Memory Copy Forward-only, reads non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPRN, then CPYFMRN, and then CPYFERN."
  },
  {
    "name": "CPYFERN",
    "doc": "Memory Copy Forward-only, reads non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPRN, then CPYFMRN, and then CPYFERN."
  },
  {
    "name": "CPYFPRT",
    "doc": "Memory Copy Forward-only, reads unprivileged. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPRT, then CPYFMRT, and then CPYFERT."
  },
  {
    "name": "CPYFMRT",
    "doc": "Memory Copy Forward-only, reads unprivileged. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPRT, then CPYFMRT, and then CPYFERT."
  },
  {
    "name": "CPYFERT",
    "doc": "Memory Copy Forward-only, reads unprivileged. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPRT, then CPYFMRT, and then CPYFERT."
  },
  {
    "name": "CPYFPRTN",
    "doc": "Memory Copy Forward-only, reads unprivileged, reads and writes non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPRTN, then CPYFMRTN, and then CPYFERTN."
  },
  {
    "name": "CPYFMRTN",
    "doc": "Memory Copy Forward-only, reads unprivileged, reads and writes non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPRTN, then CPYFMRTN, and then CPYFERTN."
  },
  {
    "name": "CPYFERTN",
    "doc": "Memory Copy Forward-only, reads unprivileged, reads and writes non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPRTN, then CPYFMRTN, and then CPYFERTN."
  },
  {
    "name": "CPYFPRTRN",
    "doc": "Memory Copy Forward-only, reads unprivileged and non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPRTRN, then CPYFMRTRN, and then CPYFERTRN."
  },
  {
    "name": "CPYFMRTRN",
    "doc": "Memory Copy Forward-only, reads unprivileged and non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPRTRN, then CPYFMRTRN, and then CPYFERTRN."
  },
  {
    "name": "CPYFERTRN",
    "doc": "Memory Copy Forward-only, reads unprivileged and non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPRTRN, then CPYFMRTRN, and then CPYFERTRN."
  },
  {
    "name": "CPYFPRTWN",
    "doc": "Memory Copy Forward-only, reads unprivileged, writes non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPRTWN, then CPYFMRTWN, and then CPYFERTWN."
  },
  {
    "name": "CPYFMRTWN",
    "doc": "Memory Copy Forward-only, reads unprivileged, writes non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPRTWN, then CPYFMRTWN, and then CPYFERTWN."
  },
  {
    "name": "CPYFERTWN",
    "doc": "Memory Copy Forward-only, reads unprivileged, writes non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPRTWN, then CPYFMRTWN, and then CPYFERTWN."
  },
  {
    "name": "CPYFPT",
    "doc": "Memory Copy Forward-only, reads and writes unprivileged. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPT, then CPYFMT, and then CPYFET."
  },
  {
    "name": "CPYFMT",
    "doc": "Memory Copy Forward-only, reads and writes unprivileged. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPT, then CPYFMT, and then CPYFET."
  },
  {
    "name": "CPYFET",
    "doc": "Memory Copy Forward-only, reads and writes unprivileged. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPT, then CPYFMT, and then CPYFET."
  },
  {
    "name": "CPYFPTN",
    "doc": "Memory Copy Forward-only, reads and writes unprivileged and non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPTN, then CPYFMTN, and then CPYFETN."
  },
  {
    "name": "CPYFMTN",
    "doc": "Memory Copy Forward-only, reads and writes unprivileged and non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPTN, then CPYFMTN, and then CPYFETN."
  },
  {
    "name": "CPYFETN",
    "doc": "Memory Copy Forward-only, reads and writes unprivileged and non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPTN, then CPYFMTN, and then CPYFETN."
  },
  {
    "name": "CPYFPTRN",
    "doc": "Memory Copy Forward-only, reads and writes unprivileged, reads non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPTRN, then CPYFMTRN, and then CPYFETRN."
  },
  {
    "name": "CPYFMTRN",
    "doc": "Memory Copy Forward-only, reads and writes unprivileged, reads non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPTRN, then CPYFMTRN, and then CPYFETRN."
  },
  {
    "name": "CPYFETRN",
    "doc": "Memory Copy Forward-only, reads and writes unprivileged, reads non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPTRN, then CPYFMTRN, and then CPYFETRN."
  },
  {
    "name": "CPYFPTWN",
    "doc": "Memory Copy Forward-only, reads and writes unprivileged, writes non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPTWN, then CPYFMTWN, and then CPYFETWN."
  },
  {
    "name": "CPYFMTWN",
    "doc": "Memory Copy Forward-only, reads and writes unprivileged, writes non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPTWN, then CPYFMTWN, and then CPYFETWN."
  },
  {
    "name": "CPYFETWN",
    "doc": "Memory Copy Forward-only, reads and writes unprivileged, writes non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPTWN, then CPYFMTWN, and then CPYFETWN."
  },
  {
    "name": "CPYFPWN",
    "doc": "Memory Copy Forward-only, writes non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPWN, then CPYFMWN, and then CPYFEWN."
  },
  {
    "name": "CPYFMWN",
    "doc": "Memory Copy Forward-only, writes non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPWN, then CPYFMWN, and then CPYFEWN."
  },
  {
    "name": "CPYFEWN",
    "doc": "Memory Copy Forward-only, writes non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPWN, then CPYFMWN, and then CPYFEWN."
  },
  {
    "name": "CPYFPWT",
    "doc": "Memory Copy Forward-only, writes unprivileged. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPWT, then CPYFMWT, and then CPYFEWT."
  },
  {
    "name": "CPYFMWT",
    "doc": "Memory Copy Forward-only, writes unprivileged. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPWT, then CPYFMWT, and then CPYFEWT."
  },
  {
    "name": "CPYFEWT",
    "doc": "Memory Copy Forward-only, writes unprivileged. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPWT, then CPYFMWT, and then CPYFEWT."
  },
  {
    "name": "CPYFPWTN",
    "doc": "Memory Copy Forward-only, writes unprivileged, reads and writes non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPWTN, then CPYFMWTN, and then CPYFEWTN."
  },
  {
    "name": "CPYFMWTN",
    "doc": "Memory Copy Forward-only, writes unprivileged, reads and writes non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPWTN, then CPYFMWTN, and then CPYFEWTN."
  },
  {
    "name": "CPYFEWTN",
    "doc": "Memory Copy Forward-only, writes unprivileged, reads and writes non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPWTN, then CPYFMWTN, and then CPYFEWTN."
  },
  {
    "name": "CPYFPWTRN",
    "doc": "Memory Copy Forward-only, writes unprivileged, reads non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPWTRN, then CPYFMWTRN, and then CPYFEWTRN."
  },
  {
    "name": "CPYFMWTRN",
    "doc": "Memory Copy Forward-only, writes unprivileged, reads non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPWTRN, then CPYFMWTRN, and then CPYFEWTRN."
  },
  {
    "name": "CPYFEWTRN",
    "doc": "Memory Copy Forward-only, writes unprivileged, reads non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPWTRN, then CPYFMWTRN, and then CPYFEWTRN."
  },
  {
    "name": "CPYFPWTWN",
    "doc": "Memory Copy Forward-only, writes unprivileged and non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPWTWN, then CPYFMWTWN, and then CPYFEWTWN."
  },
  {
    "name": "CPYFMWTWN",
    "doc": "Memory Copy Forward-only, writes unprivileged and non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPWTWN, then CPYFMWTWN, and then CPYFEWTWN."
  },
  {
    "name": "CPYFEWTWN",
    "doc": "Memory Copy Forward-only, writes unprivileged and non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYFPWTWN, then CPYFMWTWN, and then CPYFEWTWN."
  },
  {
    "name": "CPYP",
    "doc": "Memory Copy. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYP, then CPYM, and then CPYE."
  },
  {
    "name": "CPYM",
    "doc": "Memory Copy. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYP, then CPYM, and then CPYE."
  },
  {
    "name": "CPYE",
    "doc": "Memory Copy. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYP, then CPYM, and then CPYE."
  },
  {
    "name": "CPYPN",
    "doc": "Memory Copy, reads and writes non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPN, then CPYMN, and then CPYEN."
  },
  {
    "name": "CPYMN",
    "doc": "Memory Copy, reads and writes non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPN, then CPYMN, and then CPYEN."
  },
  {
    "name": "CPYEN",
    "doc": "Memory Copy, reads and writes non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPN, then CPYMN, and then CPYEN."
  },
  {
    "name": "CPYPRN",
    "doc": "Memory Copy, reads non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPRN, then CPYMRN, and then CPYERN."
  },
  {
    "name": "CPYMRN",
    "doc": "Memory Copy, reads non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPRN, then CPYMRN, and then CPYERN."
  },
  {
    "name": "CPYERN",
    "doc": "Memory Copy, reads non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPRN, then CPYMRN, and then CPYERN."
  },
  {
    "name": "CPYPRT",
    "doc": "Memory Copy, reads unprivileged. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPRT, then CPYMRT, and then CPYERT."
  },
  {
    "name": "CPYMRT",
    "doc": "Memory Copy, reads unprivileged. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPRT, then CPYMRT, and then CPYERT."
  },
  {
    "name": "CPYERT",
    "doc": "Memory Copy, reads unprivileged. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPRT, then CPYMRT, and then CPYERT."
  },
  {
    "name": "CPYPRTN",
    "doc": "Memory Copy, reads unprivileged, reads and writes non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPRTN, then CPYMRTN, and then CPYERTN."
  },
  {
    "name": "CPYMRTN",
    "doc": "Memory Copy, reads unprivileged, reads and writes non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPRTN, then CPYMRTN, and then CPYERTN."
  },
  {
    "name": "CPYERTN",
    "doc": "Memory Copy, reads unprivileged, reads and writes non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPRTN, then CPYMRTN, and then CPYERTN."
  },
  {
    "name": "CPYPRTRN",
    "doc": "Memory Copy, reads unprivileged and non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPRTRN, then CPYMRTRN, and then CPYERTRN."
  },
  {
    "name": "CPYMRTRN",
    "doc": "Memory Copy, reads unprivileged and non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPRTRN, then CPYMRTRN, and then CPYERTRN."
  },
  {
    "name": "CPYERTRN",
    "doc": "Memory Copy, reads unprivileged and non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPRTRN, then CPYMRTRN, and then CPYERTRN."
  },
  {
    "name": "CPYPRTWN",
    "doc": "Memory Copy, reads unprivileged, writes non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPRTWN, then CPYMRTWN, and then CPYERTWN."
  },
  {
    "name": "CPYMRTWN",
    "doc": "Memory Copy, reads unprivileged, writes non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPRTWN, then CPYMRTWN, and then CPYERTWN."
  },
  {
    "name": "CPYERTWN",
    "doc": "Memory Copy, reads unprivileged, writes non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPRTWN, then CPYMRTWN, and then CPYERTWN."
  },
  {
    "name": "CPYPT",
    "doc": "Memory Copy, reads and writes unprivileged. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPT, then CPYMT, and then CPYET."
  },
  {
    "name": "CPYMT",
    "doc": "Memory Copy, reads and writes unprivileged. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPT, then CPYMT, and then CPYET."
  },
  {
    "name": "CPYET",
    "doc": "Memory Copy, reads and writes unprivileged. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPT, then CPYMT, and then CPYET."
  },
  {
    "name": "CPYPTN",
    "doc": "Memory Copy, reads and writes unprivileged and non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPTN, then CPYMTN, and then CPYETN."
  },
  {
    "name": "CPYMTN",
    "doc": "Memory Copy, reads and writes unprivileged and non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPTN, then CPYMTN, and then CPYETN."
  },
  {
    "name": "CPYETN",
    "doc": "Memory Copy, reads and writes unprivileged and non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPTN, then CPYMTN, and then CPYETN."
  },
  {
    "name": "CPYPTRN",
    "doc": "Memory Copy, reads and writes unprivileged, reads non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPTRN, then CPYMTRN, and then CPYETRN."
  },
  {
    "name": "CPYMTRN",
    "doc": "Memory Copy, reads and writes unprivileged, reads non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPTRN, then CPYMTRN, and then CPYETRN."
  },
  {
    "name": "CPYETRN",
    "doc": "Memory Copy, reads and writes unprivileged, reads non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPTRN, then CPYMTRN, and then CPYETRN."
  },
  {
    "name": "CPYPTWN",
    "doc": "Memory Copy, reads and writes unprivileged, writes non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPTWN, then CPYMTWN, and then CPYETWN."
  },
  {
    "name": "CPYMTWN",
    "doc": "Memory Copy, reads and writes unprivileged, writes non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPTWN, then CPYMTWN, and then CPYETWN."
  },
  {
    "name": "CPYETWN",
    "doc": "Memory Copy, reads and writes unprivileged, writes non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPTWN, then CPYMTWN, and then CPYETWN."
  },
  {
    "name": "CPYPWN",
    "doc": "Memory Copy, writes non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPWN, then CPYMWN, and then CPYEWN."
  },
  {
    "name": "CPYMWN",
    "doc": "Memory Copy, writes non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPWN, then CPYMWN, and then CPYEWN."
  },
  {
    "name": "CPYEWN",
    "doc": "Memory Copy, writes non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPWN, then CPYMWN, and then CPYEWN."
  },
  {
    "name": "CPYPWT",
    "doc": "Memory Copy, writes unprivileged. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPWT, then CPYMWT, and then CPYEWT."
  },
  {
    "name": "CPYMWT",
    "doc": "Memory Copy, writes unprivileged. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPWT, then CPYMWT, and then CPYEWT."
  },
  {
    "name": "CPYEWT",
    "doc": "Memory Copy, writes unprivileged. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPWT, then CPYMWT, and then CPYEWT."
  },
  {
    "name": "CPYPWTN",
    "doc": "Memory Copy, writes unprivileged, reads and writes non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPWTN, then CPYMWTN, and then CPYEWTN."
  },
  {
    "name": "CPYMWTN",
    "doc": "Memory Copy, writes unprivileged, reads and writes non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPWTN, then CPYMWTN, and then CPYEWTN."
  },
  {
    "name": "CPYEWTN",
    "doc": "Memory Copy, writes unprivileged, reads and writes non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPWTN, then CPYMWTN, and then CPYEWTN."
  },
  {
    "name": "CPYPWTRN",
    "doc": "Memory Copy, writes unprivileged, reads non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPWTRN, then CPYMWTRN, and then CPYEWTRN."
  },
  {
    "name": "CPYMWTRN",
    "doc": "Memory Copy, writes unprivileged, reads non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPWTRN, then CPYMWTRN, and then CPYEWTRN."
  },
  {
    "name": "CPYEWTRN",
    "doc": "Memory Copy, writes unprivileged, reads non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPWTRN, then CPYMWTRN, and then CPYEWTRN."
  },
  {
    "name": "CPYPWTWN",
    "doc": "Memory Copy, writes unprivileged and non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPWTWN, then CPYMWTWN, and then CPYEWTWN."
  },
  {
    "name": "CPYMWTWN",
    "doc": "Memory Copy, writes unprivileged and non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPWTWN, then CPYMWTWN, and then CPYEWTWN."
  },
  {
    "name": "CPYEWTWN",
    "doc": "Memory Copy, writes unprivileged and non-temporal. These instructions perform a memory copy. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: CPYPWTWN, then CPYMWTWN, and then CPYEWTWN."
  },
  {
    "name": "CPY",
    "doc": "Copy signed integer immediate to vector elements (zeroing)"
  },
  {
    "name": "CRC32B",
    "doc": "CRC32 checksum performs a cyclic redundancy check (CRC) calculation on a value held in a general-purpose register. It takes an input CRC value in the first source operand, performs a CRC on the input value in the second source operand, and returns the output CRC value. The second source operand can be 8, 16, 32, or 64 bits. To align with common usage, the bit order of the values is reversed as part of the operation, and the polynomial 0x04C11DB7 is used for the CRC calculation."
  },
  {
    "name": "CRC32H",
    "doc": "CRC32 checksum performs a cyclic redundancy check (CRC) calculation on a value held in a general-purpose register. It takes an input CRC value in the first source operand, performs a CRC on the input value in the second source operand, and returns the output CRC value. The second source operand can be 8, 16, 32, or 64 bits. To align with common usage, the bit order of the values is reversed as part of the operation, and the polynomial 0x04C11DB7 is used for the CRC calculation."
  },
  {
    "name": "CRC32W",
    "doc": "CRC32 checksum performs a cyclic redundancy check (CRC) calculation on a value held in a general-purpose register. It takes an input CRC value in the first source operand, performs a CRC on the input value in the second source operand, and returns the output CRC value. The second source operand can be 8, 16, 32, or 64 bits. To align with common usage, the bit order of the values is reversed as part of the operation, and the polynomial 0x04C11DB7 is used for the CRC calculation."
  },
  {
    "name": "CRC32X",
    "doc": "CRC32 checksum performs a cyclic redundancy check (CRC) calculation on a value held in a general-purpose register. It takes an input CRC value in the first source operand, performs a CRC on the input value in the second source operand, and returns the output CRC value. The second source operand can be 8, 16, 32, or 64 bits. To align with common usage, the bit order of the values is reversed as part of the operation, and the polynomial 0x04C11DB7 is used for the CRC calculation."
  },
  {
    "name": "CRC32CB",
    "doc": "CRC32C checksum performs a cyclic redundancy check (CRC) calculation on a value held in a general-purpose register. It takes an input CRC value in the first source operand, performs a CRC on the input value in the second source operand, and returns the output CRC value. The second source operand can be 8, 16, 32, or 64 bits. To align with common usage, the bit order of the values is reversed as part of the operation, and the polynomial 0x1EDC6F41 is used for the CRC calculation."
  },
  {
    "name": "CRC32CH",
    "doc": "CRC32C checksum performs a cyclic redundancy check (CRC) calculation on a value held in a general-purpose register. It takes an input CRC value in the first source operand, performs a CRC on the input value in the second source operand, and returns the output CRC value. The second source operand can be 8, 16, 32, or 64 bits. To align with common usage, the bit order of the values is reversed as part of the operation, and the polynomial 0x1EDC6F41 is used for the CRC calculation."
  },
  {
    "name": "CRC32CW",
    "doc": "CRC32C checksum performs a cyclic redundancy check (CRC) calculation on a value held in a general-purpose register. It takes an input CRC value in the first source operand, performs a CRC on the input value in the second source operand, and returns the output CRC value. The second source operand can be 8, 16, 32, or 64 bits. To align with common usage, the bit order of the values is reversed as part of the operation, and the polynomial 0x1EDC6F41 is used for the CRC calculation."
  },
  {
    "name": "CRC32CX",
    "doc": "CRC32C checksum performs a cyclic redundancy check (CRC) calculation on a value held in a general-purpose register. It takes an input CRC value in the first source operand, performs a CRC on the input value in the second source operand, and returns the output CRC value. The second source operand can be 8, 16, 32, or 64 bits. To align with common usage, the bit order of the values is reversed as part of the operation, and the polynomial 0x1EDC6F41 is used for the CRC calculation."
  },
  {
    "name": "CSDB",
    "doc": "Consumption of Speculative Data Barrier is a memory barrier that controls speculative execution and data value prediction."
  },
  {
    "name": "CSEL",
    "doc": "If the condition is true, Conditional Select writes the value of the first source register to the destination register. If the condition is false, it writes the value of the second source register to the destination register."
  },
  {
    "name": "CSETM",
    "doc": "Conditional Set Mask sets all bits of the destination register to 1 if the condition is TRUE, and otherwise sets all bits to 0."
  },
  {
    "name": "CSET",
    "doc": "Conditional Set sets the destination register to 1 if the condition is TRUE, and otherwise sets it to 0."
  },
  {
    "name": "CSINC",
    "doc": "Conditional Select Increment returns, in the destination register, the value of the first source register if the condition is TRUE, and otherwise returns the value of the second source register incremented by 1."
  },
  {
    "name": "CSINV",
    "doc": "Conditional Select Invert returns, in the destination register, the value of the first source register if the condition is TRUE, and otherwise returns the bitwise inversion value of the second source register."
  },
  {
    "name": "CSNEG",
    "doc": "Conditional Select Negation returns, in the destination register, the value of the first source register if the condition is TRUE, and otherwise returns the negated value of the second source register."
  },
  {
    "name": "CTERMEQ",
    "doc": "Compare and terminate loop"
  },
  {
    "name": "CTERMNE",
    "doc": "Compare and terminate loop"
  },
  {
    "name": "CTZ",
    "doc": "Count Trailing Zeros counts the number of consecutive binary zero bits, starting from the least significant bit in the source register, and places the count in the destination register."
  },
  {
    "name": "DCPS1",
    "doc": "Debug Change PE State to EL1, when executed in Debug state:"
  },
  {
    "name": "DCPS2",
    "doc": "Debug Change PE State to EL2, when executed in Debug state:"
  },
  {
    "name": "DCPS3",
    "doc": "Debug Change PE State to EL3, when executed in Debug state:"
  },
  {
    "name": "DC",
    "doc": "Data Cache operation. For more information, see op0==0b01, cache maintenance, TLB maintenance, and address translation instructions."
  },
  {
    "name": "DECB",
    "doc": "Decrement scalar by multiple of predicate constraint element count"
  },
  {
    "name": "DECD",
    "doc": "Decrement scalar by multiple of predicate constraint element count"
  },
  {
    "name": "DECH",
    "doc": "Decrement scalar by multiple of predicate constraint element count"
  },
  {
    "name": "DECW",
    "doc": "Decrement scalar by multiple of predicate constraint element count"
  },
  {
    "name": "DECP",
    "doc": "Decrement scalar by count of true predicate elements"
  },
  {
    "name": "DGH",
    "doc": "Data Gathering Hint is a hint instruction that indicates that it is not expected to be performance optimal to merge memory accesses with Normal Non-cacheable or Device-GRE attributes appearing in program order before the hint instruction with any memory accesses appearing after the hint instruction into a single memory transaction on an interconnect."
  },
  {
    "name": "DMB",
    "doc": "Data Memory Barrier is a memory barrier that ensures the ordering of observations of memory accesses, see Data Memory Barrier."
  },
  {
    "name": "DRPS",
    "doc": "Debug restore process state"
  },
  {
    "name": "DSB",
    "doc": "Data Synchronization Barrier is a memory barrier that ensures the completion of memory accesses, see Data Synchronization Barrier."
  },
  {
    "name": "DUPM",
    "doc": "Broadcast logical bitmask immediate to vector (unpredicated)"
  },
  {
    "name": "DUPQ",
    "doc": "Broadcast indexed element within each quadword vector segment (unpredicated)"
  },
  {
    "name": "DUP",
    "doc": "Duplicate vector element to vector or scalar. This instruction duplicates the vector element at the specified element index in the source SIMD&amp;FP register into a scalar or each element in a vector, and writes the result to the destination SIMD&amp;FP register."
  },
  {
    "name": "DVP",
    "doc": "Data Value Prediction Restriction by Context prevents data value predictions that predict execution addresses based on information gathered from earlier execution within a particular execution context. Data value predictions determined by the actions of code in the target execution context or contexts appearing in program order before the instruction cannot be used to exploitatively control speculative execution occurring after the instruction is complete and synchronized."
  },
  {
    "name": "EON",
    "doc": "Bitwise Exclusive-OR NOT (shifted register) performs a bitwise exclusive-OR NOT of a register value and an optionally-shifted register value, and writes the result to the destination register."
  },
  {
    "name": "EOR3",
    "doc": "Three-way Exclusive-OR performs a three-way exclusive-OR of the values in the three source SIMD&amp;FP registers, and writes the result to the destination SIMD&amp;FP register."
  },
  {
    "name": "EORBT",
    "doc": "Interleaving exclusive OR (bottom, top)"
  },
  {
    "name": "EORQV",
    "doc": "Bitwise exclusive OR reduction of quadword vector segments"
  },
  {
    "name": "EORS",
    "doc": "Bitwise exclusive OR predicates, setting the condition flags"
  },
  {
    "name": "EORTB",
    "doc": "Interleaving exclusive OR (top, bottom)"
  },
  {
    "name": "EORV",
    "doc": "Bitwise exclusive OR reduction to scalar"
  },
  {
    "name": "EOR",
    "doc": "Bitwise Exclusive-OR (vector). This instruction performs a bitwise exclusive-OR operation between the two source SIMD&amp;FP registers, and places the result in the destination SIMD&amp;FP register."
  },
  {
    "name": "ERET",
    "doc": "Exception Return using the ELR and SPSR for the current Exception level. When executed, the PE restores PSTATE from the SPSR, and branches to the address held in the ELR."
  },
  {
    "name": "ERETAA",
    "doc": "Exception Return, with pointer authentication. This instruction authenticates the address in ELR, using SP as the modifier and the specified key, the PE restores PSTATE from the SPSR for the current Exception level, and branches to the authenticated address."
  },
  {
    "name": "ERETAB",
    "doc": "Exception Return, with pointer authentication. This instruction authenticates the address in ELR, using SP as the modifier and the specified key, the PE restores PSTATE from the SPSR for the current Exception level, and branches to the authenticated address."
  },
  {
    "name": "ESB",
    "doc": "Error Synchronization Barrier is an error synchronization event that might also update DISR_EL1 and VDISR_EL2."
  },
  {
    "name": "EXTQ",
    "doc": "Extract vector segment from each pair of quadword vector segments"
  },
  {
    "name": "EXTR",
    "doc": "Extract register extracts a register from a pair of registers."
  },
  {
    "name": "EXT",
    "doc": "Extract vector from pair of vectors. This instruction extracts the lowest vector elements from the second source SIMD&amp;FP register and the highest vector elements from the first source SIMD&amp;FP register, concatenates the results into a vector, and writes the vector to the destination SIMD&amp;FP register vector. The index value specifies the lowest vector element to extract from the first source register, and consecutive elements are extracted from the first, then second, source registers until the destination vector is filled."
  },
  {
    "name": "FABD",
    "doc": "Floating-point Absolute Difference (vector). This instruction subtracts the floating-point values in the elements of the second source SIMD&amp;FP register, from the corresponding floating-point values in the elements of the first source SIMD&amp;FP register, places the absolute value of each result in a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "FABS",
    "doc": "Floating-point Absolute value (vector). This instruction calculates the absolute value of each vector element in the source SIMD&amp;FP register, writes the result to a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "FACGE",
    "doc": "Floating-point Absolute Compare Greater than or Equal (vector). This instruction compares the absolute value of each floating-point value in the first source SIMD&amp;FP register with the absolute value of the corresponding floating-point value in the second source SIMD&amp;FP register and if the first value is greater than or equal to the second value sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to zero."
  },
  {
    "name": "FAC",
    "doc": "Floating-point absolute compare vectors"
  },
  {
    "name": "FACGT",
    "doc": "Floating-point Absolute Compare Greater than (vector). This instruction compares the absolute value of each vector element in the first source SIMD&amp;FP register with the absolute value of the corresponding vector element in the second source SIMD&amp;FP register and if the first value is greater than the second value sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to zero."
  },
  {
    "name": "FACLE",
    "doc": "Floating-point absolute compare less than or equal"
  },
  {
    "name": "FACLT",
    "doc": "Floating-point absolute compare less than"
  },
  {
    "name": "FADDA",
    "doc": "Floating-point add strictly-ordered reduction, accumulating in scalar"
  },
  {
    "name": "FADDP",
    "doc": "Floating-point Add Pair of elements (scalar). This instruction adds two floating-point vector elements in the source SIMD&amp;FP register and writes the scalar result into the destination SIMD&amp;FP register."
  },
  {
    "name": "FADDQV",
    "doc": "Floating-point add recursive reduction of quadword vector segments"
  },
  {
    "name": "FADDV",
    "doc": "Floating-point add recursive reduction to scalar"
  },
  {
    "name": "FADD",
    "doc": "Floating-point Add (vector). This instruction adds corresponding vector elements in the two source SIMD&amp;FP registers, writes the result into a vector, and writes the vector to the destination SIMD&amp;FP register. All the values in this instruction are floating-point values."
  },
  {
    "name": "FCADD",
    "doc": "Floating-point Complex Add."
  },
  {
    "name": "FCCMPE",
    "doc": "Floating-point Conditional signaling Compare (scalar). This instruction compares the two SIMD&amp;FP source register values and writes the result to the PSTATE.{N, Z, C, V} flags. If the condition does not pass then the PSTATE.{N, Z, C, V} flags are set to the flag bit specifier."
  },
  {
    "name": "FCCMP",
    "doc": "Floating-point Conditional quiet Compare (scalar). This instruction compares the two SIMD&amp;FP source register values and writes the result to the PSTATE.{N, Z, C, V} flags. If the condition does not pass then the PSTATE.{N, Z, C, V} flags are set to the flag bit specifier."
  },
  {
    "name": "FCLAMP",
    "doc": "Multi-vector floating-point clamp to minimum/maximum number"
  },
  {
    "name": "FCMEQ",
    "doc": "Floating-point Compare Equal (vector). This instruction compares each floating-point value from the first source SIMD&amp;FP register, with the corresponding floating-point value from the second source SIMD&amp;FP register, and if the comparison is equal sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to zero."
  },
  {
    "name": "FCM",
    "doc": "Floating-point compare vector with zero"
  },
  {
    "name": "FCMGE",
    "doc": "Floating-point Compare Greater than or Equal (vector). This instruction reads each floating-point value in the first source SIMD&amp;FP register and if the value is greater than or equal to the corresponding floating-point value in the second source SIMD&amp;FP register sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to zero."
  },
  {
    "name": "FCMGT",
    "doc": "Floating-point Compare Greater than (vector). This instruction reads each floating-point value in the first source SIMD&amp;FP register and if the value is greater than the corresponding floating-point value in the second source SIMD&amp;FP register sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to zero."
  },
  {
    "name": "FCMLA",
    "doc": "Floating-point Complex Multiply Accumulate (by element)."
  },
  {
    "name": "FCMLE",
    "doc": "Floating-point Compare Less than or Equal to zero (vector). This instruction reads each floating-point value in the source SIMD&amp;FP register and if the value is less than or equal to zero sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to zero."
  },
  {
    "name": "FCMLT",
    "doc": "Floating-point Compare Less than zero (vector). This instruction reads each floating-point value in the source SIMD&amp;FP register and if the value is less than zero sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to one, otherwise sets every bit of the corresponding vector element in the destination SIMD&amp;FP register to zero."
  },
  {
    "name": "FCMPE",
    "doc": "Floating-point signaling Compare (scalar). This instruction compares the two SIMD&amp;FP source register values, or the first SIMD&amp;FP source register value and zero. It writes the result to the PSTATE.{N, Z, C, V} flags."
  },
  {
    "name": "FCMP",
    "doc": "Floating-point quiet Compare (scalar). This instruction compares the two SIMD&amp;FP source register values, or the first SIMD&amp;FP source register value and zero. It writes the result to the PSTATE.{N, Z, C, V} flags."
  },
  {
    "name": "FCPY",
    "doc": "Copy 8-bit floating-point immediate to vector elements (predicated)"
  },
  {
    "name": "FCSEL",
    "doc": "Floating-point Conditional Select (scalar). This instruction allows the SIMD&amp;FP destination register to take the value from either one or the other of two SIMD&amp;FP source registers. If the condition passes, the first SIMD&amp;FP source register value is taken, otherwise the second SIMD&amp;FP source register value is taken."
  },
  {
    "name": "FCVTAS",
    "doc": "Floating-point Convert to Signed integer, rounding to nearest with ties to Away (vector). This instruction converts each element in a vector from a floating-point value to a signed integer value using the Round to Nearest with Ties to Away rounding mode and writes the result to the SIMD&amp;FP destination register."
  },
  {
    "name": "FCVTAU",
    "doc": "Floating-point Convert to Unsigned integer, rounding to nearest with ties to Away (vector). This instruction converts each element in a vector from a floating-point value to an unsigned integer value using the Round to Nearest with Ties to Away rounding mode and writes the result to the SIMD&amp;FP destination register."
  },
  {
    "name": "FCVTLT",
    "doc": "Floating-point up convert long (top, predicated)"
  },
  {
    "name": "FCVTL",
    "doc": "Floating-point Convert to higher precision Long (vector). This instruction reads each element in a vector in the SIMD&amp;FP source register, converts each value to double the precision of the source element using the rounding mode that is determined by the FPCR, and writes each result to the equivalent element of the vector in the SIMD&amp;FP destination register."
  },
  {
    "name": "FCVTL2",
    "doc": "Floating-point Convert to higher precision Long (vector). This instruction reads each element in a vector in the SIMD&amp;FP source register, converts each value to double the precision of the source element using the rounding mode that is determined by the FPCR, and writes each result to the equivalent element of the vector in the SIMD&amp;FP destination register."
  },
  {
    "name": "FCVTMS",
    "doc": "Floating-point Convert to Signed integer, rounding toward Minus infinity (vector). This instruction converts a scalar or each element in a vector from a floating-point value to a signed integer value using the Round towards Minus Infinity rounding mode, and writes the result to the SIMD&amp;FP destination register."
  },
  {
    "name": "FCVTMU",
    "doc": "Floating-point Convert to Unsigned integer, rounding toward Minus infinity (vector). This instruction converts a scalar or each element in a vector from a floating-point value to an unsigned integer value using the Round towards Minus Infinity rounding mode, and writes the result to the SIMD&amp;FP destination register."
  },
  {
    "name": "FCVTNS",
    "doc": "Floating-point Convert to Signed integer, rounding to nearest with ties to even (vector). This instruction converts a scalar or each element in a vector from a floating-point value to a signed integer value using the Round to Nearest rounding mode, and writes the result to the SIMD&amp;FP destination register."
  },
  {
    "name": "FCVTNT",
    "doc": "Floating-point down convert and narrow (top, predicated)"
  },
  {
    "name": "FCVTNU",
    "doc": "Floating-point Convert to Unsigned integer, rounding to nearest with ties to even (vector). This instruction converts a scalar or each element in a vector from a floating-point value to an unsigned integer value using the Round to Nearest rounding mode, and writes the result to the SIMD&amp;FP destination register."
  },
  {
    "name": "FCVTN",
    "doc": "Floating-point Convert to lower precision Narrow (vector). This instruction reads each vector element in the SIMD&amp;FP source register, converts each result to half the precision of the source element, writes the final result to a vector, and writes the vector to the lower or upper half of the destination SIMD&amp;FP register. The destination vector elements are half as long as the source vector elements. The rounding mode is determined by the FPCR."
  },
  {
    "name": "FCVTN2",
    "doc": "Floating-point Convert to lower precision Narrow (vector). This instruction reads each vector element in the SIMD&amp;FP source register, converts each result to half the precision of the source element, writes the final result to a vector, and writes the vector to the lower or upper half of the destination SIMD&amp;FP register. The destination vector elements are half as long as the source vector elements. The rounding mode is determined by the FPCR."
  },
  {
    "name": "FCVTPS",
    "doc": "Floating-point Convert to Signed integer, rounding toward Plus infinity (vector). This instruction converts a scalar or each element in a vector from a floating-point value to a signed integer value using the Round towards Plus Infinity rounding mode, and writes the result to the SIMD&amp;FP destination register."
  },
  {
    "name": "FCVTPU",
    "doc": "Floating-point Convert to Unsigned integer, rounding toward Plus infinity (vector). This instruction converts a scalar or each element in a vector from a floating-point value to an unsigned integer value using the Round towards Plus Infinity rounding mode, and writes the result to the SIMD&amp;FP destination register."
  },
  {
    "name": "FCVTXNT",
    "doc": "Floating-point down convert, rounding to odd (top, predicated)"
  },
  {
    "name": "FCVTXN",
    "doc": "Floating-point Convert to lower precision Narrow, rounding to odd (vector). This instruction reads each vector element in the source SIMD&amp;FP register, narrows each value to half the precision of the source element using the Round to Odd rounding mode, writes the result to a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "FCVTXN2",
    "doc": "Floating-point Convert to lower precision Narrow, rounding to odd (vector). This instruction reads each vector element in the source SIMD&amp;FP register, narrows each value to half the precision of the source element using the Round to Odd rounding mode, writes the result to a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "FCVTX",
    "doc": "Floating-point down convert, rounding to odd (predicated)"
  },
  {
    "name": "FCVTZS",
    "doc": "Floating-point Convert to Signed fixed-point, rounding toward Zero (vector). This instruction converts a scalar or each element in a vector from floating-point to fixed-point signed integer using the Round towards Zero rounding mode, and writes the result to the SIMD&amp;FP destination register."
  },
  {
    "name": "FCVTZU",
    "doc": "Floating-point Convert to Unsigned fixed-point, rounding toward Zero (vector). This instruction converts a scalar or each element in a vector from floating-point to fixed-point unsigned integer using the Round towards Zero rounding mode, and writes the result to the general-purpose destination register."
  },
  {
    "name": "FCVT",
    "doc": "Floating-point Convert precision (scalar). This instruction converts the floating-point value in the SIMD&amp;FP source register to the precision for the destination register data type using the rounding mode that is determined by the FPCR and writes the result to the SIMD&amp;FP destination register."
  },
  {
    "name": "FDIVR",
    "doc": "Floating-point reversed divide by vector (predicated)"
  },
  {
    "name": "FDIV",
    "doc": "Floating-point Divide (vector). This instruction divides the floating-point values in the elements in the first source SIMD&amp;FP register, by the floating-point values in the corresponding elements in the second source SIMD&amp;FP register, places the results in a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "FDOT",
    "doc": "Multi-vector half-precision floating-point dot-product by indexed element"
  },
  {
    "name": "FDUP",
    "doc": "Broadcast 8-bit floating-point immediate to vector elements (unpredicated)"
  },
  {
    "name": "FEXPA",
    "doc": "Floating-point exponential accelerator"
  },
  {
    "name": "FJCVTZS",
    "doc": "Floating-point Javascript Convert to Signed fixed-point, rounding toward Zero. This instruction converts the double-precision floating-point value in the SIMD&amp;FP source register to a 32-bit signed integer using the Round towards Zero rounding mode, and writes the result to the general-purpose destination register. If the result is too large to be represented as a signed 32-bit integer, then the result is the integer modulo 232, as held in a 32-bit signed integer."
  },
  {
    "name": "FLOGB",
    "doc": "Floating-point base 2 logarithm as integer"
  },
  {
    "name": "FMADD",
    "doc": "Floating-point fused Multiply-Add (scalar). This instruction multiplies the values of the first two SIMD&amp;FP source registers, adds the product to the value of the third SIMD&amp;FP source register, and writes the result to the SIMD&amp;FP destination register."
  },
  {
    "name": "FMAD",
    "doc": "Floating-point fused multiply-add vectors (predicated), writing multiplicand [Zdn = Za + Zdn * Zm]"
  },
  {
    "name": "FMAXNMP",
    "doc": "Floating-point Maximum Number of Pair of elements (scalar). This instruction compares two vector elements in the source SIMD&amp;FP register and writes the largest of the floating-point values as a scalar to the destination SIMD&amp;FP register."
  },
  {
    "name": "FMAXNMQV",
    "doc": "Floating-point maximum number recursive reduction of quadword vector segments"
  },
  {
    "name": "FMAXNMV",
    "doc": "Floating-point Maximum Number across Vector. This instruction compares all the vector elements in the source SIMD&amp;FP register, and writes the largest of the values as a scalar to the destination SIMD&amp;FP register. All the values in this instruction are floating-point values."
  },
  {
    "name": "FMAXNM",
    "doc": "Floating-point Maximum Number (vector). This instruction compares corresponding vector elements in the two source SIMD&amp;FP registers, writes the larger of the two floating-point values into a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "FMAXP",
    "doc": "Floating-point Maximum of Pair of elements (scalar). This instruction compares two vector elements in the source SIMD&amp;FP register and writes the largest of the floating-point values as a scalar to the destination SIMD&amp;FP register."
  },
  {
    "name": "FMAXQV",
    "doc": "Floating-point maximum reduction of quadword vector segments"
  },
  {
    "name": "FMAXV",
    "doc": "Floating-point Maximum across Vector. This instruction compares all the vector elements in the source SIMD&amp;FP register, and writes the largest of the values as a scalar to the destination SIMD&amp;FP register. All the values in this instruction are floating-point values."
  },
  {
    "name": "FMAX",
    "doc": "Floating-point Maximum (vector). This instruction compares corresponding vector elements in the two source SIMD&amp;FP registers, places the larger of each of the two floating-point values into a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "FMINNMP",
    "doc": "Floating-point Minimum Number of Pair of elements (scalar). This instruction compares two vector elements in the source SIMD&amp;FP register and writes the smallest of the floating-point values as a scalar to the destination SIMD&amp;FP register."
  },
  {
    "name": "FMINNMQV",
    "doc": "Floating-point minimum number recursive reduction of quadword vector segments"
  },
  {
    "name": "FMINNMV",
    "doc": "Floating-point Minimum Number across Vector. This instruction compares all the vector elements in the source SIMD&amp;FP register, and writes the smallest of the values as a scalar to the destination SIMD&amp;FP register. All the values in this instruction are floating-point values."
  },
  {
    "name": "FMINNM",
    "doc": "Floating-point Minimum Number (vector). This instruction compares corresponding vector elements in the two source SIMD&amp;FP registers, writes the smaller of the two floating-point values into a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "FMINP",
    "doc": "Floating-point Minimum of Pair of elements (scalar). This instruction compares two vector elements in the source SIMD&amp;FP register and writes the smallest of the floating-point values as a scalar to the destination SIMD&amp;FP register."
  },
  {
    "name": "FMINQV",
    "doc": "Floating-point minimum recursive reduction of quadword vector segments"
  },
  {
    "name": "FMINV",
    "doc": "Floating-point Minimum across Vector. This instruction compares all the vector elements in the source SIMD&amp;FP register, and writes the smallest of the values as a scalar to the destination SIMD&amp;FP register. All the values in this instruction are floating-point values."
  },
  {
    "name": "FMIN",
    "doc": "Floating-point minimum (vector). This instruction compares corresponding elements in the vectors in the two source SIMD&amp;FP registers, places the smaller of each of the two floating-point values into a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "FMLALB",
    "doc": "Half-precision floating-point multiply-add long to single-precision (bottom)"
  },
  {
    "name": "FMLALT",
    "doc": "Half-precision floating-point multiply-add long to single-precision (top)"
  },
  {
    "name": "FMLAL",
    "doc": "Floating-point fused Multiply-Add Long to accumulator (by element). This instruction multiplies the vector elements in the first source SIMD&amp;FP register by the specified value in the second source SIMD&amp;FP register, and accumulates the product to the corresponding vector element of the destination SIMD&amp;FP register. The instruction does not round the result of the multiply before the accumulation."
  },
  {
    "name": "FMLAL2",
    "doc": "Floating-point fused Multiply-Add Long to accumulator (by element). This instruction multiplies the vector elements in the first source SIMD&amp;FP register by the specified value in the second source SIMD&amp;FP register, and accumulates the product to the corresponding vector element of the destination SIMD&amp;FP register. The instruction does not round the result of the multiply before the accumulation."
  },
  {
    "name": "FMLA",
    "doc": "Floating-point fused Multiply-Add to accumulator (by element). This instruction multiplies the vector elements in the first source SIMD&amp;FP register by the specified value in the second source SIMD&amp;FP register, and accumulates the results in the vector elements of the destination SIMD&amp;FP register. All the values in this instruction are floating-point values."
  },
  {
    "name": "FMLSLB",
    "doc": "Half-precision floating-point multiply-subtract long from single-precision (bottom)"
  },
  {
    "name": "FMLSLT",
    "doc": "Half-precision floating-point multiply-subtract long from single-precision (top)"
  },
  {
    "name": "FMLSL",
    "doc": "Floating-point fused Multiply-Subtract Long from accumulator (by element). This instruction multiplies the negated vector elements in the first source SIMD&amp;FP register by the specified value in the second source SIMD&amp;FP register, and accumulates the product to the corresponding vector element of the destination SIMD&amp;FP register. The instruction does not round the result of the multiply before the accumulation."
  },
  {
    "name": "FMLSL2",
    "doc": "Floating-point fused Multiply-Subtract Long from accumulator (by element). This instruction multiplies the negated vector elements in the first source SIMD&amp;FP register by the specified value in the second source SIMD&amp;FP register, and accumulates the product to the corresponding vector element of the destination SIMD&amp;FP register. The instruction does not round the result of the multiply before the accumulation."
  },
  {
    "name": "FMLS",
    "doc": "Floating-point fused Multiply-Subtract from accumulator (by element). This instruction multiplies the vector elements in the first source SIMD&amp;FP register by the specified value in the second source SIMD&amp;FP register, and subtracts the results from the vector elements of the destination SIMD&amp;FP register. All the values in this instruction are floating-point values."
  },
  {
    "name": "FMMLA",
    "doc": "Floating-point matrix multiply-accumulate"
  },
  {
    "name": "FMOPA",
    "doc": "Half-precision floating-point sum of outer products and accumulate"
  },
  {
    "name": "FMOPS",
    "doc": "Half-precision floating-point sum of outer products and subtract"
  },
  {
    "name": "FMOV",
    "doc": "Floating-point move immediate (vector). This instruction copies an immediate floating-point constant into every element of the SIMD&amp;FP destination register."
  },
  {
    "name": "FMSB",
    "doc": "Floating-point fused multiply-subtract vectors (predicated), writing multiplicand [Zdn = Za + -Zdn * Zm]"
  },
  {
    "name": "FMSUB",
    "doc": "Floating-point Fused Multiply-Subtract (scalar). This instruction multiplies the values of the first two SIMD&amp;FP source registers, negates the product, adds that to the value of the third SIMD&amp;FP source register, and writes the result to the SIMD&amp;FP destination register."
  },
  {
    "name": "FMULX",
    "doc": "Floating-point Multiply extended (by element). This instruction multiplies the floating-point values in the vector elements in the first source SIMD&amp;FP register by the specified floating-point value in the second source SIMD&amp;FP register, places the results in a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "FMUL",
    "doc": "Floating-point Multiply (by element). This instruction multiplies the vector elements in the first source SIMD&amp;FP register by the specified value in the second source SIMD&amp;FP register, places the results in a vector, and writes the vector to the destination SIMD&amp;FP register. All the values in this instruction are floating-point values."
  },
  {
    "name": "FNEG",
    "doc": "Floating-point Negate (vector). This instruction negates the value of each vector element in the source SIMD&amp;FP register, writes the result to a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "FNMADD",
    "doc": "Floating-point Negated fused Multiply-Add (scalar). This instruction multiplies the values of the first two SIMD&amp;FP source registers, negates the product, subtracts the value of the third SIMD&amp;FP source register, and writes the result to the destination SIMD&amp;FP register."
  },
  {
    "name": "FNMAD",
    "doc": "Floating-point negated fused multiply-add vectors (predicated), writing multiplicand [Zdn = -Za + -Zdn * Zm]"
  },
  {
    "name": "FNMLA",
    "doc": "Floating-point negated fused multiply-add vectors (predicated), writing addend [Zda = -Zda + -Zn * Zm]"
  },
  {
    "name": "FNMLS",
    "doc": "Floating-point negated fused multiply-subtract vectors (predicated), writing addend [Zda = -Zda + Zn * Zm]"
  },
  {
    "name": "FNMSB",
    "doc": "Floating-point negated fused multiply-subtract vectors (predicated), writing multiplicand [Zdn = -Za + Zdn * Zm]"
  },
  {
    "name": "FNMSUB",
    "doc": "Floating-point Negated fused Multiply-Subtract (scalar). This instruction multiplies the values of the first two SIMD&amp;FP source registers, subtracts the value of the third SIMD&amp;FP source register, and writes the result to the destination SIMD&amp;FP register."
  },
  {
    "name": "FNMUL",
    "doc": "Floating-point Multiply-Negate (scalar). This instruction multiplies the floating-point values of the two source SIMD&amp;FP registers, and writes the negation of the result to the destination SIMD&amp;FP register."
  },
  {
    "name": "FRECPE",
    "doc": "Floating-point Reciprocal Estimate. This instruction finds an approximate reciprocal estimate for each vector element in the source SIMD&amp;FP register, places the result in a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "FRECPS",
    "doc": "Floating-point Reciprocal Step. This instruction multiplies the corresponding floating-point values in the vectors of the two source SIMD&amp;FP registers, subtracts each of the products from 2.0, places the resulting floating-point values in a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "FRECPX",
    "doc": "Floating-point Reciprocal exponent (scalar). This instruction finds an approximate reciprocal exponent for the source SIMD&amp;FP register and writes the result to the destination SIMD&amp;FP register."
  },
  {
    "name": "FRINT32X",
    "doc": "Floating-point Round to 32-bit Integer, using current rounding mode (vector). This instruction rounds a vector of floating-point values in the SIMD&amp;FP source register to integral floating-point values that fit into a 32-bit integer size using the rounding mode that is determined by the FPCR, and writes the result to the SIMD&amp;FP destination register."
  },
  {
    "name": "FRINT32Z",
    "doc": "Floating-point Round to 32-bit Integer toward Zero (vector). This instruction rounds a vector of floating-point values in the SIMD&amp;FP source register to integral floating-point values that fit into a 32-bit integer size using the Round towards Zero rounding mode, and writes the result to the SIMD&amp;FP destination register."
  },
  {
    "name": "FRINT64X",
    "doc": "Floating-point Round to 64-bit Integer, using current rounding mode (vector). This instruction rounds a vector of floating-point values in the SIMD&amp;FP source register to integral floating-point values that fit into a 64-bit integer size using the rounding mode that is determined by the FPCR, and writes the result to the SIMD&amp;FP destination register."
  },
  {
    "name": "FRINT64Z",
    "doc": "Floating-point Round to 64-bit Integer toward Zero (vector). This instruction rounds a vector of floating-point values in the SIMD&amp;FP source register to integral floating-point values that fit into a 64-bit integer size using the Round towards Zero rounding mode, and writes the result to the SIMD&amp;FP destination register."
  },
  {
    "name": "FRINTA",
    "doc": "Floating-point Round to Integral, to nearest with ties to Away (vector). This instruction rounds a vector of floating-point values in the SIMD&amp;FP source register to integral floating-point values of the same size using the Round to Nearest with Ties to Away rounding mode, and writes the result to the SIMD&amp;FP destination register."
  },
  {
    "name": "FRINT",
    "doc": "Floating-point round to integral value (predicated)"
  },
  {
    "name": "FRINTI",
    "doc": "Floating-point Round to Integral, using current rounding mode (vector). This instruction rounds a vector of floating-point values in the SIMD&amp;FP source register to integral floating-point values of the same size using the rounding mode that is determined by the FPCR, and writes the result to the SIMD&amp;FP destination register."
  },
  {
    "name": "FRINTM",
    "doc": "Floating-point Round to Integral, toward Minus infinity (vector). This instruction rounds a vector of floating-point values in the SIMD&amp;FP source register to integral floating-point values of the same size using the Round towards Minus Infinity rounding mode, and writes the result to the SIMD&amp;FP destination register."
  },
  {
    "name": "FRINTN",
    "doc": "Floating-point Round to Integral, to nearest with ties to even (vector). This instruction rounds a vector of floating-point values in the SIMD&amp;FP source register to integral floating-point values of the same size using the Round to Nearest rounding mode, and writes the result to the SIMD&amp;FP destination register."
  },
  {
    "name": "FRINTP",
    "doc": "Floating-point Round to Integral, toward Plus infinity (vector). This instruction rounds a vector of floating-point values in the SIMD&amp;FP source register to integral floating-point values of the same size using the Round towards Plus Infinity rounding mode, and writes the result to the SIMD&amp;FP destination register."
  },
  {
    "name": "FRINTX",
    "doc": "Floating-point Round to Integral exact, using current rounding mode (vector). This instruction rounds a vector of floating-point values in the SIMD&amp;FP source register to integral floating-point values of the same size using the rounding mode that is determined by the FPCR, and writes the result to the SIMD&amp;FP destination register."
  },
  {
    "name": "FRINTZ",
    "doc": "Floating-point Round to Integral, toward Zero (vector). This instruction rounds a vector of floating-point values in the SIMD&amp;FP source register to integral floating-point values of the same size using the Round towards Zero rounding mode, and writes the result to the SIMD&amp;FP destination register."
  },
  {
    "name": "FRSQRTE",
    "doc": "Floating-point Reciprocal Square Root Estimate. This instruction calculates an approximate square root for each vector element in the source SIMD&amp;FP register, places the result in a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "FRSQRTS",
    "doc": "Floating-point Reciprocal Square Root Step. This instruction multiplies corresponding floating-point values in the vectors of the two source SIMD&amp;FP registers, subtracts each of the products from 3.0, divides these results by 2.0, places the results into a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "FSCALE",
    "doc": "Floating-point adjust exponent by vector (predicated)"
  },
  {
    "name": "FSQRT",
    "doc": "Floating-point Square Root (vector). This instruction calculates the square root for each vector element in the source SIMD&amp;FP register, places the result in a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "FSUBR",
    "doc": "Floating-point reversed subtract from immediate (predicated)"
  },
  {
    "name": "FSUB",
    "doc": "Floating-point Subtract (vector). This instruction subtracts the elements in the vector in the second source SIMD&amp;FP register, from the corresponding elements in the vector in the first source SIMD&amp;FP register, places each result into elements of a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "FTMAD",
    "doc": "Floating-point trigonometric multiply-add coefficient"
  },
  {
    "name": "FTSMUL",
    "doc": "Floating-point trigonometric starting value"
  },
  {
    "name": "FTSSEL",
    "doc": "Floating-point trigonometric select coefficient"
  },
  {
    "name": "FVDOT",
    "doc": "Multi-vector half-precision floating-point vertical dot-product by indexed element"
  },
  {
    "name": "GCSB",
    "doc": "Guarded Control Stack Barrier. This instruction generates a Guarded control stack data synchronization event."
  },
  {
    "name": "DSYNC",
    "doc": "Guarded Control Stack Barrier. This instruction generates a Guarded control stack data synchronization event."
  },
  {
    "name": "GCSPOPCX",
    "doc": "Guarded Control Stack Pop and Compare exception return record loads an exception return record from the location indicated by the current Guarded control stack pointer register, compares the loaded values with the current ELR_ELx, SPSR_ELx, and LR, and increments the pointer by the size of a Guarded control stack exception return record."
  },
  {
    "name": "GCSPOPM",
    "doc": "Guarded Control Stack Pop loads the 64-bit doubleword that is pointed to by the current Guarded control stack pointer, writes it to the destination register, and increments the current Guarded control stack pointer register by the size of a Guarded control stack procedure return record."
  },
  {
    "name": "GCSPOPX",
    "doc": "Guarded Control Stack Pop exception return record loads an exception return record from the location indicated by the current Guarded control stack pointer register, checks that the record is an exception return record, and increments the pointer by the size of a Guarded control stack exception return record."
  },
  {
    "name": "GCSPUSHM",
    "doc": "Guarded Control Stack Push decrements the current Guarded control stack pointer register by the size of a Guarded control procedure return record and stores an entry to the Guarded control stack."
  },
  {
    "name": "GCSPUSHX",
    "doc": "Guarded Control Stack Push exception return record decrements the current Guarded control stack pointer register by the size of a Guarded control stack exception return record and stores an exception return record to the Guarded control stack."
  },
  {
    "name": "GCSSS1",
    "doc": "Guarded Control Stack Switch Stack 1 validates that the stack being switched to contains a Valid cap entry, stores an In-progress cap entry to the stack that is being switched to, and sets the current Guarded control stack pointer to the stack that is being switched to."
  },
  {
    "name": "GCSSS2",
    "doc": "Guarded Control Stack Switch Stack 2 validates that the most recent entry of the Guarded control stack being switched to contains an In-progress cap entry, stores a Valid cap entry to the Guarded control stack that is being switched from, and sets Xt to the Guarded control stack pointer that is being switched from."
  },
  {
    "name": "GCSSTR",
    "doc": "Guarded Control Stack Store stores a doubleword from a register to memory. The address that is used for the store is calculated from a base register."
  },
  {
    "name": "GCSSTTR",
    "doc": "Guarded Control Stack unprivileged Store stores a doubleword from a register to memory. The address that is used for the store is calculated from a base register."
  },
  {
    "name": "GMI",
    "doc": "Tag Mask Insert inserts the tag in the first source register into the excluded set specified in the second source register, writing the new excluded set to the destination register."
  },
  {
    "name": "HINT",
    "doc": "Hint instruction is for the instruction set space that is reserved for architectural hint instructions."
  },
  {
    "name": "HISTCNT",
    "doc": "Count matching elements in vector"
  },
  {
    "name": "HISTSEG",
    "doc": "Count matching elements in vector segments"
  },
  {
    "name": "HLT",
    "doc": "Halt instruction. An HLT instruction can generate a Halt Instruction debug event, which causes entry into Debug state."
  },
  {
    "name": "HVC",
    "doc": "Hypervisor Call causes an exception to EL2. Software executing at EL1 can use this instruction to call the hypervisor to request a service."
  },
  {
    "name": "IC",
    "doc": "Instruction Cache operation. For more information, see op0==0b01, cache maintenance, TLB maintenance, and address translation instructions."
  },
  {
    "name": "INCB",
    "doc": "Increment scalar by multiple of predicate constraint element count"
  },
  {
    "name": "INCD",
    "doc": "Increment scalar by multiple of predicate constraint element count"
  },
  {
    "name": "INCH",
    "doc": "Increment scalar by multiple of predicate constraint element count"
  },
  {
    "name": "INCW",
    "doc": "Increment scalar by multiple of predicate constraint element count"
  },
  {
    "name": "INCP",
    "doc": "Increment scalar by count of true predicate elements"
  },
  {
    "name": "INDEX",
    "doc": "Create index starting from and incremented by immediate"
  },
  {
    "name": "INSR",
    "doc": "Insert general-purpose register in shifted vector"
  },
  {
    "name": "INS",
    "doc": "Insert vector element from another vector element. This instruction copies the vector element of the source SIMD&amp;FP register to the specified vector element of the destination SIMD&amp;FP register."
  },
  {
    "name": "IRG",
    "doc": "Insert Random Tag inserts a random Logical Address Tag into the address in the first source register, and writes the result to the destination register. Any tags specified in the optional second source register or in GCR_EL1.Exclude are excluded from the selection of the random Logical Address Tag."
  },
  {
    "name": "ISB",
    "doc": "Instruction Synchronization Barrier flushes the pipeline in the PE and is a context synchronization event. For more information, see Instruction Synchronization Barrier (ISB)."
  },
  {
    "name": "LASTA",
    "doc": "Extract element after last to general-purpose register"
  },
  {
    "name": "LASTB",
    "doc": "Extract last element to general-purpose register"
  },
  {
    "name": "LD1B",
    "doc": "Contiguous load of bytes to multiple strided vectors (immediate index)"
  },
  {
    "name": "LD1D",
    "doc": "Contiguous load of doublewords to multiple strided vectors (immediate index)"
  },
  {
    "name": "LD1H",
    "doc": "Contiguous load of halfwords to multiple strided vectors (immediate index)"
  },
  {
    "name": "LD1Q",
    "doc": "Contiguous load of quadwords to 128-bit element ZA tile slice"
  },
  {
    "name": "LD1RB",
    "doc": "Load and broadcast unsigned byte to vector"
  },
  {
    "name": "LD1RD",
    "doc": "Load and broadcast doubleword to vector"
  },
  {
    "name": "LD1RH",
    "doc": "Load and broadcast unsigned halfword to vector"
  },
  {
    "name": "LD1ROB",
    "doc": "Contiguous load and replicate thirty-two bytes (immediate index)"
  },
  {
    "name": "LD1ROD",
    "doc": "Contiguous load and replicate four doublewords (immediate index)"
  },
  {
    "name": "LD1ROH",
    "doc": "Contiguous load and replicate sixteen halfwords (immediate index)"
  },
  {
    "name": "LD1ROW",
    "doc": "Contiguous load and replicate eight words (immediate index)"
  },
  {
    "name": "LD1RQB",
    "doc": "Contiguous load and replicate sixteen bytes (immediate index)"
  },
  {
    "name": "LD1RQD",
    "doc": "Contiguous load and replicate two doublewords (immediate index)"
  },
  {
    "name": "LD1RQH",
    "doc": "Contiguous load and replicate eight halfwords (immediate index)"
  },
  {
    "name": "LD1RQW",
    "doc": "Contiguous load and replicate four words (immediate index)"
  },
  {
    "name": "LD1RSB",
    "doc": "Load and broadcast signed byte to vector"
  },
  {
    "name": "LD1RSH",
    "doc": "Load and broadcast signed halfword to vector"
  },
  {
    "name": "LD1RSW",
    "doc": "Load and broadcast signed word to vector"
  },
  {
    "name": "LD1RW",
    "doc": "Load and broadcast unsigned word to vector"
  },
  {
    "name": "LD1R",
    "doc": "Load one single-element structure and Replicate to all lanes (of one register). This instruction loads a single-element structure from memory and replicates the structure to all the lanes of the SIMD&amp;FP register."
  },
  {
    "name": "LD1SB",
    "doc": "Gather load signed bytes to vector (immediate index)"
  },
  {
    "name": "LD1SH",
    "doc": "Gather load signed halfwords to vector (immediate index)"
  },
  {
    "name": "LD1SW",
    "doc": "Gather load signed words to vector (immediate index)"
  },
  {
    "name": "LD1W",
    "doc": "Contiguous load of words to multiple strided vectors (immediate index)"
  },
  {
    "name": "LD1",
    "doc": "Load multiple single-element structures to one, two, three, or four registers. This instruction loads multiple single-element structures from memory and writes the result to one, two, three, or four SIMD&amp;FP registers."
  },
  {
    "name": "LD2B",
    "doc": "Contiguous load two-byte structures to two vectors (immediate index)"
  },
  {
    "name": "LD2D",
    "doc": "Contiguous load two-doubleword structures to two vectors (immediate index)"
  },
  {
    "name": "LD2H",
    "doc": "Contiguous load two-halfword structures to two vectors (immediate index)"
  },
  {
    "name": "LD2Q",
    "doc": "Contiguous load two-quadword structures to two vectors (immediate index)"
  },
  {
    "name": "LD2R",
    "doc": "Load single 2-element structure and Replicate to all lanes of two registers. This instruction loads a 2-element structure from memory and replicates the structure to all the lanes of the two SIMD&amp;FP registers."
  },
  {
    "name": "LD2W",
    "doc": "Contiguous load two-word structures to two vectors (immediate index)"
  },
  {
    "name": "LD2",
    "doc": "Load multiple 2-element structures to two registers. This instruction loads multiple 2-element structures from memory and writes the result to the two SIMD&amp;FP registers, with de-interleaving."
  },
  {
    "name": "LD3B",
    "doc": "Contiguous load three-byte structures to three vectors (immediate index)"
  },
  {
    "name": "LD3D",
    "doc": "Contiguous load three-doubleword structures to three vectors (immediate index)"
  },
  {
    "name": "LD3H",
    "doc": "Contiguous load three-halfword structures to three vectors (immediate index)"
  },
  {
    "name": "LD3Q",
    "doc": "Contiguous load three-quadword structures to three vectors (immediate index)"
  },
  {
    "name": "LD3R",
    "doc": "Load single 3-element structure and Replicate to all lanes of three registers. This instruction loads a 3-element structure from memory and replicates the structure to all the lanes of the three SIMD&amp;FP registers."
  },
  {
    "name": "LD3W",
    "doc": "Contiguous load three-word structures to three vectors (immediate index)"
  },
  {
    "name": "LD3",
    "doc": "Load multiple 3-element structures to three registers. This instruction loads multiple 3-element structures from memory and writes the result to the three SIMD&amp;FP registers, with de-interleaving."
  },
  {
    "name": "LD4B",
    "doc": "Contiguous load four-byte structures to four vectors (immediate index)"
  },
  {
    "name": "LD4D",
    "doc": "Contiguous load four-doubleword structures to four vectors (immediate index)"
  },
  {
    "name": "LD4H",
    "doc": "Contiguous load four-halfword structures to four vectors (immediate index)"
  },
  {
    "name": "LD4Q",
    "doc": "Contiguous load four-quadword structures to four vectors (immediate index)"
  },
  {
    "name": "LD4R",
    "doc": "Load single 4-element structure and Replicate to all lanes of four registers. This instruction loads a 4-element structure from memory and replicates the structure to all the lanes of the four SIMD&amp;FP registers."
  },
  {
    "name": "LD4W",
    "doc": "Contiguous load four-word structures to four vectors (immediate index)"
  },
  {
    "name": "LD4",
    "doc": "Load multiple 4-element structures to four registers. This instruction loads multiple 4-element structures from memory and writes the result to the four SIMD&amp;FP registers, with de-interleaving."
  },
  {
    "name": "LD64B",
    "doc": "Single-copy Atomic 64-byte Load derives an address from a base register value, loads eight 64-bit doublewords from a memory location, and writes them to consecutive registers, Xt to X(t+7). The data that is loaded is atomic and is required to be 64-byte aligned."
  },
  {
    "name": "LDADD",
    "doc": "Atomic add on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, adds the value held in a register to it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDADDA",
    "doc": "Atomic add on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, adds the value held in a register to it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDADDAL",
    "doc": "Atomic add on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, adds the value held in a register to it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDADDL",
    "doc": "Atomic add on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, adds the value held in a register to it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDADDB",
    "doc": "Atomic add on byte in memory atomically loads an 8-bit byte from memory, adds the value held in a register to it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDADDAB",
    "doc": "Atomic add on byte in memory atomically loads an 8-bit byte from memory, adds the value held in a register to it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDADDALB",
    "doc": "Atomic add on byte in memory atomically loads an 8-bit byte from memory, adds the value held in a register to it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDADDLB",
    "doc": "Atomic add on byte in memory atomically loads an 8-bit byte from memory, adds the value held in a register to it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDADDH",
    "doc": "Atomic add on halfword in memory atomically loads a 16-bit halfword from memory, adds the value held in a register to it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDADDAH",
    "doc": "Atomic add on halfword in memory atomically loads a 16-bit halfword from memory, adds the value held in a register to it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDADDALH",
    "doc": "Atomic add on halfword in memory atomically loads a 16-bit halfword from memory, adds the value held in a register to it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDADDLH",
    "doc": "Atomic add on halfword in memory atomically loads a 16-bit halfword from memory, adds the value held in a register to it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDAP1",
    "doc": "Load-Acquire RCpc one single-element structure to one lane of one register. This instruction loads a single-element structure from memory and writes the result to the specified lane of the SIMD&amp;FP register without affecting the other bits of the register."
  },
  {
    "name": "LDAPR",
    "doc": "Load-Acquire RCpc Register derives an address from a base register value, loads a 32-bit word or 64-bit doubleword from the derived address in memory, and writes it to a register."
  },
  {
    "name": "LDAPRB",
    "doc": "Load-Acquire RCpc Register Byte derives an address from a base register value, loads a byte from the derived address in memory, zero-extends it and writes it to a register."
  },
  {
    "name": "LDAPRH",
    "doc": "Load-Acquire RCpc Register Halfword derives an address from a base register value, loads a halfword from the derived address in memory, zero-extends it and writes it to a register."
  },
  {
    "name": "LDAPURB",
    "doc": "Load-Acquire RCpc Register Byte (unscaled) calculates an address from a base register and an immediate offset, loads a byte from memory, zero-extends it, and writes it to a register."
  },
  {
    "name": "LDAPURH",
    "doc": "Load-Acquire RCpc Register Halfword (unscaled) calculates an address from a base register and an immediate offset, loads a halfword from memory, zero-extends it, and writes it to a register."
  },
  {
    "name": "LDAPURSB",
    "doc": "Load-Acquire RCpc Register Signed Byte (unscaled) calculates an address from a base register and an immediate offset, loads a signed byte from memory, sign-extends it, and writes it to a register."
  },
  {
    "name": "LDAPURSH",
    "doc": "Load-Acquire RCpc Register Signed Halfword (unscaled) calculates an address from a base register and an immediate offset, loads a signed halfword from memory, sign-extends it, and writes it to a register."
  },
  {
    "name": "LDAPURSW",
    "doc": "Load-Acquire RCpc Register Signed Word (unscaled) calculates an address from a base register and an immediate offset, loads a signed word from memory, sign-extends it, and writes it to a register."
  },
  {
    "name": "LDAPUR",
    "doc": "Load-Acquire RCpc SIMD&amp;FP Register (unscaled offset). This instruction loads a SIMD&amp;FP register from memory. The address that is used for the load is calculated from a base register value and an optional immediate offset."
  },
  {
    "name": "LDAR",
    "doc": "Load-Acquire Register derives an address from a base register value, loads a 32-bit word or 64-bit doubleword from memory, and writes it to a register. The instruction also has memory ordering semantics as described in Load-Acquire, Store-Release. For information about memory accesses, see Load/Store addressing modes."
  },
  {
    "name": "LDARB",
    "doc": "Load-Acquire Register Byte derives an address from a base register value, loads a byte from memory, zero-extends it and writes it to a register. The instruction also has memory ordering semantics as described in Load-Acquire, Store-Release. For information about memory accesses, see Load/Store addressing modes."
  },
  {
    "name": "LDARH",
    "doc": "Load-Acquire Register Halfword derives an address from a base register value, loads a halfword from memory, zero-extends it, and writes it to a register. The instruction also has memory ordering semantics as described in Load-Acquire, Store-Release. For information about memory accesses, see Load/Store addressing modes."
  },
  {
    "name": "LDAXP",
    "doc": "Load-Acquire Exclusive Pair of Registers derives an address from a base register value, loads two 32-bit words or two 64-bit doublewords from memory, and writes them to two registers. For information on single-copy atomicity and alignment requirements, see Requirements for single-copy atomicity and Alignment of data accesses. The PE marks the physical address being accessed as an exclusive access. This exclusive access mark is checked by Store Exclusive instructions. See Synchronization and semaphores. The instruction also has memory ordering semantics, as described in Load-Acquire, Store-Release. For information about memory accesses, see Load/Store addressing modes."
  },
  {
    "name": "LDAXR",
    "doc": "Load-Acquire Exclusive Register derives an address from a base register value, loads a 32-bit word or 64-bit doubleword from memory, and writes it to a register. The memory access is atomic. The PE marks the physical address being accessed as an exclusive access. This exclusive access mark is checked by Store Exclusive instructions. See Synchronization and semaphores. The instruction also has memory ordering semantics as described in Load-Acquire, Store-Release. For information about memory accesses, see Load/Store addressing modes."
  },
  {
    "name": "LDAXRB",
    "doc": "Load-Acquire Exclusive Register Byte derives an address from a base register value, loads a byte from memory, zero-extends it and writes it to a register. The memory access is atomic. The PE marks the physical address being accessed as an exclusive access. This exclusive access mark is checked by Store Exclusive instructions. See Synchronization and semaphores. The instruction also has memory ordering semantics as described in Load-Acquire, Store-Release. For information about memory accesses, see Load/Store addressing modes."
  },
  {
    "name": "LDAXRH",
    "doc": "Load-Acquire Exclusive Register Halfword derives an address from a base register value, loads a halfword from memory, zero-extends it and writes it to a register. The memory access is atomic. The PE marks the physical address being accessed as an exclusive access. This exclusive access mark is checked by Store Exclusive instructions. See Synchronization and semaphores. The instruction also has memory ordering semantics as described in Load-Acquire, Store-Release. For information about memory accesses, see Load/Store addressing modes."
  },
  {
    "name": "LDCLR",
    "doc": "Atomic bit clear on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, performs a bitwise AND with the complement of the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDCLRA",
    "doc": "Atomic bit clear on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, performs a bitwise AND with the complement of the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDCLRAL",
    "doc": "Atomic bit clear on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, performs a bitwise AND with the complement of the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDCLRL",
    "doc": "Atomic bit clear on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, performs a bitwise AND with the complement of the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDCLRB",
    "doc": "Atomic bit clear on byte in memory atomically loads an 8-bit byte from memory, performs a bitwise AND with the complement of the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDCLRAB",
    "doc": "Atomic bit clear on byte in memory atomically loads an 8-bit byte from memory, performs a bitwise AND with the complement of the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDCLRALB",
    "doc": "Atomic bit clear on byte in memory atomically loads an 8-bit byte from memory, performs a bitwise AND with the complement of the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDCLRLB",
    "doc": "Atomic bit clear on byte in memory atomically loads an 8-bit byte from memory, performs a bitwise AND with the complement of the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDCLRH",
    "doc": "Atomic bit clear on halfword in memory atomically loads a 16-bit halfword from memory, performs a bitwise AND with the complement of the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDCLRAH",
    "doc": "Atomic bit clear on halfword in memory atomically loads a 16-bit halfword from memory, performs a bitwise AND with the complement of the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDCLRALH",
    "doc": "Atomic bit clear on halfword in memory atomically loads a 16-bit halfword from memory, performs a bitwise AND with the complement of the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDCLRLH",
    "doc": "Atomic bit clear on halfword in memory atomically loads a 16-bit halfword from memory, performs a bitwise AND with the complement of the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDCLRP",
    "doc": "Atomic bit clear on quadword in memory atomically loads a 128-bit quadword from memory, performs a bitwise AND with the complement of the value held in a pair of registers on it, and stores the result back to memory. The value initially loaded from memory is returned in the same pair of registers."
  },
  {
    "name": "LDCLRPA",
    "doc": "Atomic bit clear on quadword in memory atomically loads a 128-bit quadword from memory, performs a bitwise AND with the complement of the value held in a pair of registers on it, and stores the result back to memory. The value initially loaded from memory is returned in the same pair of registers."
  },
  {
    "name": "LDCLRPAL",
    "doc": "Atomic bit clear on quadword in memory atomically loads a 128-bit quadword from memory, performs a bitwise AND with the complement of the value held in a pair of registers on it, and stores the result back to memory. The value initially loaded from memory is returned in the same pair of registers."
  },
  {
    "name": "LDCLRPL",
    "doc": "Atomic bit clear on quadword in memory atomically loads a 128-bit quadword from memory, performs a bitwise AND with the complement of the value held in a pair of registers on it, and stores the result back to memory. The value initially loaded from memory is returned in the same pair of registers."
  },
  {
    "name": "LDEOR",
    "doc": "Atomic Exclusive-OR on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, performs an exclusive-OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDEORA",
    "doc": "Atomic Exclusive-OR on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, performs an exclusive-OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDEORAL",
    "doc": "Atomic Exclusive-OR on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, performs an exclusive-OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDEORL",
    "doc": "Atomic Exclusive-OR on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, performs an exclusive-OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDEORB",
    "doc": "Atomic Exclusive-OR on byte in memory atomically loads an 8-bit byte from memory, performs an exclusive-OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDEORAB",
    "doc": "Atomic Exclusive-OR on byte in memory atomically loads an 8-bit byte from memory, performs an exclusive-OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDEORALB",
    "doc": "Atomic Exclusive-OR on byte in memory atomically loads an 8-bit byte from memory, performs an exclusive-OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDEORLB",
    "doc": "Atomic Exclusive-OR on byte in memory atomically loads an 8-bit byte from memory, performs an exclusive-OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDEORH",
    "doc": "Atomic Exclusive-OR on halfword in memory atomically loads a 16-bit halfword from memory, performs an exclusive-OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDEORAH",
    "doc": "Atomic Exclusive-OR on halfword in memory atomically loads a 16-bit halfword from memory, performs an exclusive-OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDEORALH",
    "doc": "Atomic Exclusive-OR on halfword in memory atomically loads a 16-bit halfword from memory, performs an exclusive-OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDEORLH",
    "doc": "Atomic Exclusive-OR on halfword in memory atomically loads a 16-bit halfword from memory, performs an exclusive-OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDFF1B",
    "doc": "Gather load first-fault unsigned bytes to vector (immediate index)"
  },
  {
    "name": "LDFF1D",
    "doc": "Gather load first-fault doublewords to vector (immediate index)"
  },
  {
    "name": "LDFF1H",
    "doc": "Gather load first-fault unsigned halfwords to vector (immediate index)"
  },
  {
    "name": "LDFF1SB",
    "doc": "Gather load first-fault signed bytes to vector (immediate index)"
  },
  {
    "name": "LDFF1SH",
    "doc": "Gather load first-fault signed halfwords to vector (immediate index)"
  },
  {
    "name": "LDFF1SW",
    "doc": "Gather load first-fault signed words to vector (immediate index)"
  },
  {
    "name": "LDFF1W",
    "doc": "Gather load first-fault unsigned words to vector (immediate index)"
  },
  {
    "name": "LDG",
    "doc": "Load Allocation Tag loads an Allocation Tag from a memory address, generates a Logical Address Tag from the Allocation Tag and merges it into the destination register. The address used for the load is calculated from the base register and an immediate signed offset scaled by the Tag granule."
  },
  {
    "name": "LDGM",
    "doc": "Load Tag Multiple reads a naturally aligned block of N Allocation Tags, where the size of N is identified in GMID_EL1.BS, and writes the Allocation Tag read from address A to the destination register at 4*A&lt;7:4&gt;+3:4*A&lt;7:4&gt;. Bits of the destination register not written with an Allocation Tag are set to 0."
  },
  {
    "name": "LDIAPP",
    "doc": "Load-Acquire RCpc ordered Pair of registers calculates an address from a base register value and an optional offset, loads two 32-bit words or two 64-bit doublewords from memory, and writes them to two registers. For information on single-copy atomicity and alignment requirements, see Requirements for single-copy atomicity and Alignment of data accesses. The instruction also has memory ordering semantics, as described in Load-Acquire, Load-AcquirePC, and Store-Release, except that:"
  },
  {
    "name": "LDLAR",
    "doc": "Load LOAcquire Register loads a 32-bit word or 64-bit doubleword from memory, and writes it to a register. The instruction also has memory ordering semantics as described in Load LOAcquire, Store LORelease. For information about memory accesses, see Load/Store addressing modes."
  },
  {
    "name": "LDLARB",
    "doc": "Load LOAcquire Register Byte loads a byte from memory, zero-extends it and writes it to a register. The instruction also has memory ordering semantics as described in Load LOAcquire, Store LORelease. For information about memory accesses, see Load/Store addressing modes."
  },
  {
    "name": "LDLARH",
    "doc": "Load LOAcquire Register Halfword loads a halfword from memory, zero-extends it, and writes it to a register. The instruction also has memory ordering semantics as described in Load LOAcquire, Store LORelease. For information about memory accesses, see Load/Store addressing modes."
  },
  {
    "name": "LDNF1B",
    "doc": "Contiguous load non-fault unsigned bytes to vector (immediate index)"
  },
  {
    "name": "LDNF1D",
    "doc": "Contiguous load non-fault doublewords to vector (immediate index)"
  },
  {
    "name": "LDNF1H",
    "doc": "Contiguous load non-fault unsigned halfwords to vector (immediate index)"
  },
  {
    "name": "LDNF1SB",
    "doc": "Contiguous load non-fault signed bytes to vector (immediate index)"
  },
  {
    "name": "LDNF1SH",
    "doc": "Contiguous load non-fault signed halfwords to vector (immediate index)"
  },
  {
    "name": "LDNF1SW",
    "doc": "Contiguous load non-fault signed words to vector (immediate index)"
  },
  {
    "name": "LDNF1W",
    "doc": "Contiguous load non-fault unsigned words to vector (immediate index)"
  },
  {
    "name": "LDNP",
    "doc": "Load Pair of SIMD&amp;FP registers, with Non-temporal hint. This instruction loads a pair of SIMD&amp;FP registers from memory, issuing a hint to the memory system that the access is non-temporal. The address that is used for the load is calculated from a base register value and an optional immediate offset."
  },
  {
    "name": "LDNT1B",
    "doc": "Contiguous load non-temporal of bytes to multiple strided vectors (immediate index)"
  },
  {
    "name": "LDNT1D",
    "doc": "Contiguous load non-temporal of doublewords to multiple strided vectors (immediate index)"
  },
  {
    "name": "LDNT1H",
    "doc": "Contiguous load non-temporal of halfwords to multiple strided vectors (immediate index)"
  },
  {
    "name": "LDNT1SB",
    "doc": "Gather load non-temporal signed bytes"
  },
  {
    "name": "LDNT1SH",
    "doc": "Gather load non-temporal signed halfwords"
  },
  {
    "name": "LDNT1SW",
    "doc": "Gather load non-temporal signed words"
  },
  {
    "name": "LDNT1W",
    "doc": "Contiguous load non-temporal of words to multiple strided vectors (immediate index)"
  },
  {
    "name": "LDPSW",
    "doc": "Load Pair of Registers Signed Word calculates an address from a base register value and an immediate offset, loads two 32-bit words from memory, sign-extends them, and writes them to two registers. For information about memory accesses, see Load/Store addressing modes."
  },
  {
    "name": "LDP",
    "doc": "Load Pair of SIMD&amp;FP registers. This instruction loads a pair of SIMD&amp;FP registers from memory. The address that is used for the load is calculated from a base register value and an optional immediate offset."
  },
  {
    "name": "LDRAA",
    "doc": "Load Register, with pointer authentication. This instruction authenticates an address from a base register using a modifier of zero and the specified key, adds an immediate offset to the authenticated address, and loads a 64-bit doubleword from memory at this resulting address into a register."
  },
  {
    "name": "LDRAB",
    "doc": "Load Register, with pointer authentication. This instruction authenticates an address from a base register using a modifier of zero and the specified key, adds an immediate offset to the authenticated address, and loads a 64-bit doubleword from memory at this resulting address into a register."
  },
  {
    "name": "LDRB",
    "doc": "Load Register Byte (immediate) loads a byte from memory, zero-extends it, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset. For information about memory accesses, see Load/Store addressing modes."
  },
  {
    "name": "LDRH",
    "doc": "Load Register Halfword (immediate) loads a halfword from memory, zero-extends it, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset. For information about memory accesses, see Load/Store addressing modes."
  },
  {
    "name": "LDRSB",
    "doc": "Load Register Signed Byte (immediate) loads a byte from memory, sign-extends it to either 32 bits or 64 bits, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset. For information about memory accesses, see Load/Store addressing modes."
  },
  {
    "name": "LDRSH",
    "doc": "Load Register Signed Halfword (immediate) loads a halfword from memory, sign-extends it to 32 bits or 64 bits, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset. For information about memory accesses, see Load/Store addressing modes."
  },
  {
    "name": "LDRSW",
    "doc": "Load Register Signed Word (immediate) loads a word from memory, sign-extends it to 64 bits, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset. For information about memory accesses, see Load/Store addressing modes."
  },
  {
    "name": "LDR",
    "doc": "Load SIMD&amp;FP Register (immediate offset). This instruction loads an element from memory, and writes the result as a scalar to the SIMD&amp;FP register. The address that is used for the load is calculated from a base register value, a signed immediate offset, and an optional offset that is a multiple of the element size."
  },
  {
    "name": "ZT0",
    "doc": "Load ZT0 register"
  },
  {
    "name": "LDSET",
    "doc": "Atomic bit set on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, performs a bitwise OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDSETA",
    "doc": "Atomic bit set on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, performs a bitwise OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDSETAL",
    "doc": "Atomic bit set on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, performs a bitwise OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDSETL",
    "doc": "Atomic bit set on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, performs a bitwise OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDSETB",
    "doc": "Atomic bit set on byte in memory atomically loads an 8-bit byte from memory, performs a bitwise OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDSETAB",
    "doc": "Atomic bit set on byte in memory atomically loads an 8-bit byte from memory, performs a bitwise OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDSETALB",
    "doc": "Atomic bit set on byte in memory atomically loads an 8-bit byte from memory, performs a bitwise OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDSETLB",
    "doc": "Atomic bit set on byte in memory atomically loads an 8-bit byte from memory, performs a bitwise OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDSETH",
    "doc": "Atomic bit set on halfword in memory atomically loads a 16-bit halfword from memory, performs a bitwise OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDSETAH",
    "doc": "Atomic bit set on halfword in memory atomically loads a 16-bit halfword from memory, performs a bitwise OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDSETALH",
    "doc": "Atomic bit set on halfword in memory atomically loads a 16-bit halfword from memory, performs a bitwise OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDSETLH",
    "doc": "Atomic bit set on halfword in memory atomically loads a 16-bit halfword from memory, performs a bitwise OR with the value held in a register on it, and stores the result back to memory. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDSETP",
    "doc": "Atomic bit set on quadword in memory atomically loads a 128-bit quadword from memory, performs a bitwise OR with the value held in a pair of registers on it, and stores the result back to memory. The value initially loaded from memory is returned in the same pair of registers."
  },
  {
    "name": "LDSETPA",
    "doc": "Atomic bit set on quadword in memory atomically loads a 128-bit quadword from memory, performs a bitwise OR with the value held in a pair of registers on it, and stores the result back to memory. The value initially loaded from memory is returned in the same pair of registers."
  },
  {
    "name": "LDSETPAL",
    "doc": "Atomic bit set on quadword in memory atomically loads a 128-bit quadword from memory, performs a bitwise OR with the value held in a pair of registers on it, and stores the result back to memory. The value initially loaded from memory is returned in the same pair of registers."
  },
  {
    "name": "LDSETPL",
    "doc": "Atomic bit set on quadword in memory atomically loads a 128-bit quadword from memory, performs a bitwise OR with the value held in a pair of registers on it, and stores the result back to memory. The value initially loaded from memory is returned in the same pair of registers."
  },
  {
    "name": "LDSMAX",
    "doc": "Atomic signed maximum on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDSMAXA",
    "doc": "Atomic signed maximum on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDSMAXAL",
    "doc": "Atomic signed maximum on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDSMAXL",
    "doc": "Atomic signed maximum on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDSMAXB",
    "doc": "Atomic signed maximum on byte in memory atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDSMAXAB",
    "doc": "Atomic signed maximum on byte in memory atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDSMAXALB",
    "doc": "Atomic signed maximum on byte in memory atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDSMAXLB",
    "doc": "Atomic signed maximum on byte in memory atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDSMAXH",
    "doc": "Atomic signed maximum on halfword in memory atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDSMAXAH",
    "doc": "Atomic signed maximum on halfword in memory atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDSMAXALH",
    "doc": "Atomic signed maximum on halfword in memory atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDSMAXLH",
    "doc": "Atomic signed maximum on halfword in memory atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDSMIN",
    "doc": "Atomic signed minimum on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDSMINA",
    "doc": "Atomic signed minimum on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDSMINAL",
    "doc": "Atomic signed minimum on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDSMINL",
    "doc": "Atomic signed minimum on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDSMINB",
    "doc": "Atomic signed minimum on byte in memory atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDSMINAB",
    "doc": "Atomic signed minimum on byte in memory atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDSMINALB",
    "doc": "Atomic signed minimum on byte in memory atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDSMINLB",
    "doc": "Atomic signed minimum on byte in memory atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDSMINH",
    "doc": "Atomic signed minimum on halfword in memory atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDSMINAH",
    "doc": "Atomic signed minimum on halfword in memory atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDSMINALH",
    "doc": "Atomic signed minimum on halfword in memory atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDSMINLH",
    "doc": "Atomic signed minimum on halfword in memory atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as signed numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDTR",
    "doc": "Load Register (unprivileged) loads a word or doubleword from memory, and writes it to a register. The address that is used for the load is calculated from a base register and an immediate offset."
  },
  {
    "name": "LDTRB",
    "doc": "Load Register Byte (unprivileged) loads a byte from memory, zero-extends it, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset."
  },
  {
    "name": "LDTRH",
    "doc": "Load Register Halfword (unprivileged) loads a halfword from memory, zero-extends it, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset."
  },
  {
    "name": "LDTRSB",
    "doc": "Load Register Signed Byte (unprivileged) loads a byte from memory, sign-extends it to 32 bits or 64 bits, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset."
  },
  {
    "name": "LDTRSH",
    "doc": "Load Register Signed Halfword (unprivileged) loads a halfword from memory, sign-extends it to 32 bits or 64 bits, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset."
  },
  {
    "name": "LDTRSW",
    "doc": "Load Register Signed Word (unprivileged) loads a word from memory, sign-extends it to 64 bits, and writes the result to a register. The address that is used for the load is calculated from a base register and an immediate offset."
  },
  {
    "name": "LDUMAX",
    "doc": "Atomic unsigned maximum on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDUMAXA",
    "doc": "Atomic unsigned maximum on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDUMAXAL",
    "doc": "Atomic unsigned maximum on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDUMAXL",
    "doc": "Atomic unsigned maximum on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDUMAXB",
    "doc": "Atomic unsigned maximum on byte in memory atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDUMAXAB",
    "doc": "Atomic unsigned maximum on byte in memory atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDUMAXALB",
    "doc": "Atomic unsigned maximum on byte in memory atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDUMAXLB",
    "doc": "Atomic unsigned maximum on byte in memory atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDUMAXH",
    "doc": "Atomic unsigned maximum on halfword in memory atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDUMAXAH",
    "doc": "Atomic unsigned maximum on halfword in memory atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDUMAXALH",
    "doc": "Atomic unsigned maximum on halfword in memory atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDUMAXLH",
    "doc": "Atomic unsigned maximum on halfword in memory atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDUMIN",
    "doc": "Atomic unsigned minimum on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDUMINA",
    "doc": "Atomic unsigned minimum on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDUMINAL",
    "doc": "Atomic unsigned minimum on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDUMINL",
    "doc": "Atomic unsigned minimum on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDUMINB",
    "doc": "Atomic unsigned minimum on byte in memory atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDUMINAB",
    "doc": "Atomic unsigned minimum on byte in memory atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDUMINALB",
    "doc": "Atomic unsigned minimum on byte in memory atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDUMINLB",
    "doc": "Atomic unsigned minimum on byte in memory atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDUMINH",
    "doc": "Atomic unsigned minimum on halfword in memory atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDUMINAH",
    "doc": "Atomic unsigned minimum on halfword in memory atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDUMINALH",
    "doc": "Atomic unsigned minimum on halfword in memory atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDUMINLH",
    "doc": "Atomic unsigned minimum on halfword in memory atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "LDURB",
    "doc": "Load Register Byte (unscaled) calculates an address from a base register and an immediate offset, loads a byte from memory, zero-extends it, and writes it to a register. For information about memory accesses, see Load/Store addressing modes."
  },
  {
    "name": "LDURH",
    "doc": "Load Register Halfword (unscaled) calculates an address from a base register and an immediate offset, loads a halfword from memory, zero-extends it, and writes it to a register. For information about memory accesses, see Load/Store addressing modes."
  },
  {
    "name": "LDURSB",
    "doc": "Load Register Signed Byte (unscaled) calculates an address from a base register and an immediate offset, loads a signed byte from memory, sign-extends it, and writes it to a register. For information about memory accesses, see Load/Store addressing modes."
  },
  {
    "name": "LDURSH",
    "doc": "Load Register Signed Halfword (unscaled) calculates an address from a base register and an immediate offset, loads a signed halfword from memory, sign-extends it, and writes it to a register. For information about memory accesses, see Load/Store addressing modes."
  },
  {
    "name": "LDURSW",
    "doc": "Load Register Signed Word (unscaled) calculates an address from a base register and an immediate offset, loads a signed word from memory, sign-extends it, and writes it to a register. For information about memory accesses, see Load/Store addressing modes."
  },
  {
    "name": "LDUR",
    "doc": "Load SIMD&amp;FP Register (unscaled offset). This instruction loads a SIMD&amp;FP register from memory. The address that is used for the load is calculated from a base register value and an optional immediate offset."
  },
  {
    "name": "LDXP",
    "doc": "Load Exclusive Pair of Registers derives an address from a base register value, loads two 32-bit words or two 64-bit doublewords from memory, and writes them to two registers. For information on single-copy atomicity and alignment requirements, see Requirements for single-copy atomicity and Alignment of data accesses. The PE marks the physical address being accessed as an exclusive access. This exclusive access mark is checked by Store Exclusive instructions. See Synchronization and semaphores. For information about memory accesses, see Load/Store addressing modes."
  },
  {
    "name": "LDXR",
    "doc": "Load Exclusive Register derives an address from a base register value, loads a 32-bit word or a 64-bit doubleword from memory, and writes it to a register. The memory access is atomic. The PE marks the physical address being accessed as an exclusive access. This exclusive access mark is checked by Store Exclusive instructions. See Synchronization and semaphores. For information about memory accesses, see Load/Store addressing modes."
  },
  {
    "name": "LDXRB",
    "doc": "Load Exclusive Register Byte derives an address from a base register value, loads a byte from memory, zero-extends it and writes it to a register. The memory access is atomic. The PE marks the physical address being accessed as an exclusive access. This exclusive access mark is checked by Store Exclusive instructions. See Synchronization and semaphores. For information about memory accesses, see Load/Store addressing modes."
  },
  {
    "name": "LDXRH",
    "doc": "Load Exclusive Register Halfword derives an address from a base register value, loads a halfword from memory, zero-extends it and writes it to a register. The memory access is atomic. The PE marks the physical address being accessed as an exclusive access. This exclusive access mark is checked by Store Exclusive instructions. See Synchronization and semaphores. For information about memory accesses, see Load/Store addressing modes."
  },
  {
    "name": "LSLR",
    "doc": "Reversed logical shift left by vector (predicated)"
  },
  {
    "name": "LSLV",
    "doc": "Logical Shift Left Variable shifts a register value left by a variable number of bits, shifting in zeros, and writes the result to the destination register. The remainder obtained by dividing the second source register by the data size defines the number of bits by which the first source register is left-shifted."
  },
  {
    "name": "LSL",
    "doc": "Logical Shift Left (register) shifts a register value left by a variable number of bits, shifting in zeros, and writes the result to the destination register. The remainder obtained by dividing the second source register by the data size defines the number of bits by which the first source register is left-shifted."
  },
  {
    "name": "LSRR",
    "doc": "Reversed logical shift right by vector (predicated)"
  },
  {
    "name": "LSRV",
    "doc": "Logical Shift Right Variable shifts a register value right by a variable number of bits, shifting in zeros, and writes the result to the destination register. The remainder obtained by dividing the second source register by the data size defines the number of bits by which the first source register is right-shifted."
  },
  {
    "name": "LSR",
    "doc": "Logical Shift Right (register) shifts a register value right by a variable number of bits, shifting in zeros, and writes the result to the destination register. The remainder obtained by dividing the second source register by the data size defines the number of bits by which the first source register is right-shifted."
  },
  {
    "name": "LUTI2",
    "doc": "Lookup table read with 2-bit indexes"
  },
  {
    "name": "LUTI4",
    "doc": "Lookup table read with 4-bit indexes"
  },
  {
    "name": "MADD",
    "doc": "Multiply-Add multiplies two register values, adds a third register value, and writes the result to the destination register."
  },
  {
    "name": "MAD",
    "doc": "Multiply-add vectors (predicated), writing multiplicand [Zdn = Za + Zdn * Zm]"
  },
  {
    "name": "MATCH",
    "doc": "Detect any matching elements, setting the condition flags"
  },
  {
    "name": "MLA",
    "doc": "Multiply-Add to accumulator (vector, by element). This instruction multiplies the vector elements in the first source SIMD&amp;FP register by the specified value in the second source SIMD&amp;FP register, and accumulates the results with the vector elements of the destination SIMD&amp;FP register. All the values in this instruction are unsigned integer values."
  },
  {
    "name": "MLS",
    "doc": "Multiply-Subtract from accumulator (vector, by element). This instruction multiplies the vector elements in the first source SIMD&amp;FP register by the specified value in the second source SIMD&amp;FP register, and subtracts the results from the vector elements of the destination SIMD&amp;FP register. All the values in this instruction are unsigned integer values."
  },
  {
    "name": "MNEG",
    "doc": "Multiply-Negate multiplies two register values, negates the product, and writes the result to the destination register."
  },
  {
    "name": "MOVAZ",
    "doc": "Move and zero two ZA tile slices to vector registers"
  },
  {
    "name": "MOVA",
    "doc": "Move two ZA tile slices to two vector registers"
  },
  {
    "name": "MOVI",
    "doc": "Move Immediate (vector). This instruction places an immediate constant into every vector element of the destination SIMD&amp;FP register."
  },
  {
    "name": "MOVK",
    "doc": "Move wide with keep moves an optionally-shifted 16-bit immediate value into a register, keeping other bits unchanged."
  },
  {
    "name": "MOVN",
    "doc": "Move wide with NOT moves the inverse of an optionally-shifted 16-bit immediate value to a register."
  },
  {
    "name": "MOVPRFX",
    "doc": "Move prefix (predicated)"
  },
  {
    "name": "MOVS",
    "doc": "Move predicates (zeroing), setting the condition flags"
  },
  {
    "name": "MOVT",
    "doc": "Move 8 bytes from ZT0 to general-purpose register"
  },
  {
    "name": "MOVZ",
    "doc": "Move wide with zero moves an optionally-shifted 16-bit immediate value to a register."
  },
  {
    "name": "MOV",
    "doc": "Move between register and stack pointer"
  },
  {
    "name": "MRRS",
    "doc": "Move System Register to two adjacent general-purpose registers allows the PE to read an AArch64 128-bit System register into two adjacent 64-bit general-purpose registers."
  },
  {
    "name": "MRS",
    "doc": "Move System Register to general-purpose register allows the PE to read an AArch64 System register into a general-purpose register."
  },
  {
    "name": "MSB",
    "doc": "Multiply-subtract vectors (predicated), writing multiplicand [Zdn = Za - Zdn * Zm]"
  },
  {
    "name": "MSRR",
    "doc": "Move two adjacent general-purpose registers to System Register allows the PE to write an AArch64 128-bit System register from two adjacent 64-bit general-purpose registers."
  },
  {
    "name": "MSR",
    "doc": "Move immediate value to Special Register moves an immediate value to selected bits of the PSTATE. For more information, see Process state, PSTATE."
  },
  {
    "name": "MSUB",
    "doc": "Multiply-Subtract multiplies two register values, subtracts the product from a third register value, and writes the result to the destination register."
  },
  {
    "name": "MUL",
    "doc": "Multiply (vector, by element). This instruction multiplies the vector elements in the first source SIMD&amp;FP register by the specified value in the second source SIMD&amp;FP register, places the results in a vector, and writes the vector to the destination SIMD&amp;FP register. All the values in this instruction are unsigned integer values."
  },
  {
    "name": "MVNI",
    "doc": "Move inverted Immediate (vector). This instruction places the inverse of an immediate constant into every vector element of the destination SIMD&amp;FP register."
  },
  {
    "name": "MVN",
    "doc": "Bitwise NOT (vector). This instruction reads each vector element from the source SIMD&amp;FP register, places the inverse of each value into a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "NANDS",
    "doc": "Bitwise NAND predicates, setting the condition flags"
  },
  {
    "name": "NAND",
    "doc": "Bitwise NAND predicates"
  },
  {
    "name": "NBSL",
    "doc": "Bitwise inverted select"
  },
  {
    "name": "NEGS",
    "doc": "Negate, setting flags, negates an optionally-shifted register value, and writes the result to the destination register. It updates the condition flags based on the result."
  },
  {
    "name": "NEG",
    "doc": "Negate (vector). This instruction reads each vector element from the source SIMD&amp;FP register, negates each value, puts the result into a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "NGCS",
    "doc": "Negate with Carry, setting flags, negates the sum of a register value and the value of NOT (Carry flag), and writes the result to the destination register. It updates the condition flags based on the result."
  },
  {
    "name": "NGC",
    "doc": "Negate with Carry negates the sum of a register value and the value of NOT (Carry flag), and writes the result to the destination register."
  },
  {
    "name": "NMATCH",
    "doc": "Detect no matching elements, setting the condition flags"
  },
  {
    "name": "NOP",
    "doc": "No Operation does nothing, other than advance the value of the program counter by 4. This instruction can be used for instruction alignment purposes."
  },
  {
    "name": "NORS",
    "doc": "Bitwise NOR predicates, setting the condition flags"
  },
  {
    "name": "NOR",
    "doc": "Bitwise NOR predicates"
  },
  {
    "name": "NOTS",
    "doc": "Bitwise invert predicate, setting the condition flags"
  },
  {
    "name": "NOT",
    "doc": "Bitwise NOT (vector). This instruction reads each vector element from the source SIMD&amp;FP register, places the inverse of each value into a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "ORNS",
    "doc": "Bitwise inclusive OR inverted predicate, setting the condition flags"
  },
  {
    "name": "ORN",
    "doc": "Bitwise inclusive OR NOT (vector). This instruction performs a bitwise OR NOT between the two source SIMD&amp;FP registers, and writes the result to the destination SIMD&amp;FP register."
  },
  {
    "name": "ORQV",
    "doc": "Bitwise inclusive OR reduction of quadword vector segments"
  },
  {
    "name": "ORRS",
    "doc": "Bitwise inclusive OR predicates, setting the condition flags"
  },
  {
    "name": "ORR",
    "doc": "Bitwise inclusive OR (vector, immediate). This instruction reads each vector element from the destination SIMD&amp;FP register, performs a bitwise OR between each result and an immediate constant, places the result into a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "ORV",
    "doc": "Bitwise inclusive OR reduction to scalar"
  },
  {
    "name": "PACDA",
    "doc": "Pointer Authentication Code for Data address, using key A. This instruction computes and inserts a pointer authentication code for a data address, using a modifier and key A."
  },
  {
    "name": "PACDZA",
    "doc": "Pointer Authentication Code for Data address, using key A. This instruction computes and inserts a pointer authentication code for a data address, using a modifier and key A."
  },
  {
    "name": "PACDB",
    "doc": "Pointer Authentication Code for Data address, using key B. This instruction computes and inserts a pointer authentication code for a data address, using a modifier and key B."
  },
  {
    "name": "PACDZB",
    "doc": "Pointer Authentication Code for Data address, using key B. This instruction computes and inserts a pointer authentication code for a data address, using a modifier and key B."
  },
  {
    "name": "PACGA",
    "doc": "Pointer Authentication Code, using Generic key. This instruction computes the pointer authentication code for a 64-bit value in the first source register, using a modifier in the second source register, and the Generic key. The computed pointer authentication code is written to the most significant 32 bits of the destination register, and the least significant 32 bits of the destination register are set to zero."
  },
  {
    "name": "PACIA",
    "doc": "Pointer Authentication Code for Instruction address, using key A. This instruction computes and inserts a pointer authentication code for an instruction address, using a modifier and key A."
  },
  {
    "name": "PACIA1716",
    "doc": "Pointer Authentication Code for Instruction address, using key A. This instruction computes and inserts a pointer authentication code for an instruction address, using a modifier and key A."
  },
  {
    "name": "PACIASP",
    "doc": "Pointer Authentication Code for Instruction address, using key A. This instruction computes and inserts a pointer authentication code for an instruction address, using a modifier and key A."
  },
  {
    "name": "PACIAZ",
    "doc": "Pointer Authentication Code for Instruction address, using key A. This instruction computes and inserts a pointer authentication code for an instruction address, using a modifier and key A."
  },
  {
    "name": "PACIZA",
    "doc": "Pointer Authentication Code for Instruction address, using key A. This instruction computes and inserts a pointer authentication code for an instruction address, using a modifier and key A."
  },
  {
    "name": "PACIB",
    "doc": "Pointer Authentication Code for Instruction address, using key B. This instruction computes and inserts a pointer authentication code for an instruction address, using a modifier and key B."
  },
  {
    "name": "PACIB1716",
    "doc": "Pointer Authentication Code for Instruction address, using key B. This instruction computes and inserts a pointer authentication code for an instruction address, using a modifier and key B."
  },
  {
    "name": "PACIBSP",
    "doc": "Pointer Authentication Code for Instruction address, using key B. This instruction computes and inserts a pointer authentication code for an instruction address, using a modifier and key B."
  },
  {
    "name": "PACIBZ",
    "doc": "Pointer Authentication Code for Instruction address, using key B. This instruction computes and inserts a pointer authentication code for an instruction address, using a modifier and key B."
  },
  {
    "name": "PACIZB",
    "doc": "Pointer Authentication Code for Instruction address, using key B. This instruction computes and inserts a pointer authentication code for an instruction address, using a modifier and key B."
  },
  {
    "name": "PEXT",
    "doc": "Set predicate from predicate-as-counter"
  },
  {
    "name": "PFALSE",
    "doc": "Set all predicate elements to false"
  },
  {
    "name": "PFIRST",
    "doc": "Set the first active predicate element to true"
  },
  {
    "name": "PMOV",
    "doc": "Move predicate from vector"
  },
  {
    "name": "PMULLB",
    "doc": "Polynomial multiply long (bottom)"
  },
  {
    "name": "PMULLT",
    "doc": "Polynomial multiply long (top)"
  },
  {
    "name": "PMULL",
    "doc": "Polynomial Multiply Long. This instruction multiplies corresponding elements in the lower or upper half of the vectors of the two source SIMD&amp;FP registers, places the results in a vector, and writes the vector to the destination SIMD&amp;FP register. The destination vector elements are twice as long as the elements that are multiplied."
  },
  {
    "name": "PMULL2",
    "doc": "Polynomial Multiply Long. This instruction multiplies corresponding elements in the lower or upper half of the vectors of the two source SIMD&amp;FP registers, places the results in a vector, and writes the vector to the destination SIMD&amp;FP register. The destination vector elements are twice as long as the elements that are multiplied."
  },
  {
    "name": "PMUL",
    "doc": "Polynomial Multiply. This instruction multiplies corresponding elements in the vectors of the two source SIMD&amp;FP registers, places the results in a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "PNEXT",
    "doc": "Find next active predicate"
  },
  {
    "name": "PRFB",
    "doc": "Gather prefetch bytes (vector plus immediate)"
  },
  {
    "name": "PRFD",
    "doc": "Gather prefetch doublewords (vector plus immediate)"
  },
  {
    "name": "PRFH",
    "doc": "Gather prefetch halfwords (vector plus immediate)"
  },
  {
    "name": "PRFM",
    "doc": "Prefetch Memory (immediate) signals the memory system that data memory accesses from a specified address are likely to occur in the near future. The memory system can respond by taking actions that are expected to speed up the memory accesses when they do occur, such as preloading the cache line containing the specified address into one or more caches."
  },
  {
    "name": "PRFUM",
    "doc": "Prefetch Memory (unscaled offset) signals the memory system that data memory accesses from a specified address are likely to occur in the near future. The memory system can respond by taking actions that are expected to speed up the memory accesses when they do occur, such as preloading the cache line containing the specified address into one or more caches."
  },
  {
    "name": "PRFW",
    "doc": "Gather prefetch words (vector plus immediate)"
  },
  {
    "name": "PSB",
    "doc": "Profiling Synchronization Barrier. This instruction is a barrier that ensures that all existing profiling data for the current PE has been formatted, and profiling buffer addresses have been translated such that all writes to the profiling buffer have been initiated.  A following DSB instruction completes when the writes to the profiling buffer have completed."
  },
  {
    "name": "CSYNC",
    "doc": "Profiling Synchronization Barrier. This instruction is a barrier that ensures that all existing profiling data for the current PE has been formatted, and profiling buffer addresses have been translated such that all writes to the profiling buffer have been initiated.  A following DSB instruction completes when the writes to the profiling buffer have completed."
  },
  {
    "name": "PSEL",
    "doc": "Predicate select between predicate register or all-false"
  },
  {
    "name": "PSSBB",
    "doc": "Physical Speculative Store Bypass Barrier is a memory barrier that prevents speculative loads from bypassing earlier stores to the same physical address under certain conditions. For more information and details of the semantics, see Physical Speculative Store Bypass Barrier (PSSBB)."
  },
  {
    "name": "PTEST",
    "doc": "Set condition flags for predicate"
  },
  {
    "name": "PTRUES",
    "doc": "Initialise predicate from named constraint and set the condition flags"
  },
  {
    "name": "PTRUE",
    "doc": "Initialise predicate-as-counter to all active"
  },
  {
    "name": "PUNPKHI",
    "doc": "Unpack and widen half of predicate"
  },
  {
    "name": "PUNPKLO",
    "doc": "Unpack and widen half of predicate"
  },
  {
    "name": "RADDHNB",
    "doc": "Rounding add narrow high part (bottom)"
  },
  {
    "name": "RADDHNT",
    "doc": "Rounding add narrow high part (top)"
  },
  {
    "name": "RADDHN",
    "doc": "Rounding Add returning High Narrow. This instruction adds each vector element in the first source SIMD&amp;FP register to the corresponding vector element in the second source SIMD&amp;FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&amp;FP register."
  },
  {
    "name": "RADDHN2",
    "doc": "Rounding Add returning High Narrow. This instruction adds each vector element in the first source SIMD&amp;FP register to the corresponding vector element in the second source SIMD&amp;FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&amp;FP register."
  },
  {
    "name": "RAX1",
    "doc": "Rotate and Exclusive-OR rotates each 64-bit element of the 128-bit vector in a source SIMD&amp;FP register left by 1, performs a bitwise exclusive-OR of the resulting 128-bit vector and the vector in another source SIMD&amp;FP register, and writes the result to the destination SIMD&amp;FP register."
  },
  {
    "name": "RBIT",
    "doc": "Reverse Bit order (vector). This instruction reads each vector element from the source SIMD&amp;FP register, reverses the bits of the element, places the results into a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "RCWCAS",
    "doc": "Read Check Write Compare and Swap doubleword in memory reads a 64-bit doubleword from memory, and compares it against the value held in a register. If the comparison is equal, the value in a second register is conditionally written to memory. Storing back to memory is conditional on RCW Checks. If the write is performed, the read and the write occur atomically such that no other modification of the memory location can take place between the read and the write. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWCASA",
    "doc": "Read Check Write Compare and Swap doubleword in memory reads a 64-bit doubleword from memory, and compares it against the value held in a register. If the comparison is equal, the value in a second register is conditionally written to memory. Storing back to memory is conditional on RCW Checks. If the write is performed, the read and the write occur atomically such that no other modification of the memory location can take place between the read and the write. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWCASL",
    "doc": "Read Check Write Compare and Swap doubleword in memory reads a 64-bit doubleword from memory, and compares it against the value held in a register. If the comparison is equal, the value in a second register is conditionally written to memory. Storing back to memory is conditional on RCW Checks. If the write is performed, the read and the write occur atomically such that no other modification of the memory location can take place between the read and the write. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWCASAL",
    "doc": "Read Check Write Compare and Swap doubleword in memory reads a 64-bit doubleword from memory, and compares it against the value held in a register. If the comparison is equal, the value in a second register is conditionally written to memory. Storing back to memory is conditional on RCW Checks. If the write is performed, the read and the write occur atomically such that no other modification of the memory location can take place between the read and the write. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWCASP",
    "doc": "Read Check Write Compare and Swap quadword in memory reads a 128-bit quadword from memory, and compares it against the value held in a pair of registers. If the comparison is equal, the value in a second pair of registers is conditionally written to memory. Storing back to memory is conditional on RCW Checks. If the write is performed, the read and the write occur atomically such that no other modification of the memory location can take place between the read and the write. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWCASPA",
    "doc": "Read Check Write Compare and Swap quadword in memory reads a 128-bit quadword from memory, and compares it against the value held in a pair of registers. If the comparison is equal, the value in a second pair of registers is conditionally written to memory. Storing back to memory is conditional on RCW Checks. If the write is performed, the read and the write occur atomically such that no other modification of the memory location can take place between the read and the write. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWCASPL",
    "doc": "Read Check Write Compare and Swap quadword in memory reads a 128-bit quadword from memory, and compares it against the value held in a pair of registers. If the comparison is equal, the value in a second pair of registers is conditionally written to memory. Storing back to memory is conditional on RCW Checks. If the write is performed, the read and the write occur atomically such that no other modification of the memory location can take place between the read and the write. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWCASPAL",
    "doc": "Read Check Write Compare and Swap quadword in memory reads a 128-bit quadword from memory, and compares it against the value held in a pair of registers. If the comparison is equal, the value in a second pair of registers is conditionally written to memory. Storing back to memory is conditional on RCW Checks. If the write is performed, the read and the write occur atomically such that no other modification of the memory location can take place between the read and the write. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWCLR",
    "doc": "Read Check Write atomic bit Clear on doubleword in memory atomically loads a 64-bit doubleword from memory, performs a bitwise AND with the complement of the value held in a register on it, and conditionally stores the result back to memory. Storing of the result back to memory is conditional on RCW Checks. The value initially loaded from memory is returned in the destination register. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWCLRA",
    "doc": "Read Check Write atomic bit Clear on doubleword in memory atomically loads a 64-bit doubleword from memory, performs a bitwise AND with the complement of the value held in a register on it, and conditionally stores the result back to memory. Storing of the result back to memory is conditional on RCW Checks. The value initially loaded from memory is returned in the destination register. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWCLRL",
    "doc": "Read Check Write atomic bit Clear on doubleword in memory atomically loads a 64-bit doubleword from memory, performs a bitwise AND with the complement of the value held in a register on it, and conditionally stores the result back to memory. Storing of the result back to memory is conditional on RCW Checks. The value initially loaded from memory is returned in the destination register. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWCLRAL",
    "doc": "Read Check Write atomic bit Clear on doubleword in memory atomically loads a 64-bit doubleword from memory, performs a bitwise AND with the complement of the value held in a register on it, and conditionally stores the result back to memory. Storing of the result back to memory is conditional on RCW Checks. The value initially loaded from memory is returned in the destination register. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWCLRP",
    "doc": "Read Check Write atomic bit Clear on quadword in memory atomically loads a 128-bit quadword from memory, performs a bitwise AND with the complement of the value held in a pair of registers on it, and conditionally stores the result back to memory. Storing of the result back to memory is conditional on RCW Checks. The value initially loaded from memory is returned in the same pair of registers. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWCLRPA",
    "doc": "Read Check Write atomic bit Clear on quadword in memory atomically loads a 128-bit quadword from memory, performs a bitwise AND with the complement of the value held in a pair of registers on it, and conditionally stores the result back to memory. Storing of the result back to memory is conditional on RCW Checks. The value initially loaded from memory is returned in the same pair of registers. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWCLRPL",
    "doc": "Read Check Write atomic bit Clear on quadword in memory atomically loads a 128-bit quadword from memory, performs a bitwise AND with the complement of the value held in a pair of registers on it, and conditionally stores the result back to memory. Storing of the result back to memory is conditional on RCW Checks. The value initially loaded from memory is returned in the same pair of registers. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWCLRPAL",
    "doc": "Read Check Write atomic bit Clear on quadword in memory atomically loads a 128-bit quadword from memory, performs a bitwise AND with the complement of the value held in a pair of registers on it, and conditionally stores the result back to memory. Storing of the result back to memory is conditional on RCW Checks. The value initially loaded from memory is returned in the same pair of registers. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSCAS",
    "doc": "Read Check Write Software Compare and Swap doubleword in memory reads a 64-bit doubleword from memory, and compares it against the value held in a register. If the comparison is equal, the value in a second register is conditionally written to memory. Storing back to memory is conditional on RCW Checks and RCWS Checks. If the write is performed, the read and the write occur atomically such that no other modification of the memory location can take place between the read and the write. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSCASA",
    "doc": "Read Check Write Software Compare and Swap doubleword in memory reads a 64-bit doubleword from memory, and compares it against the value held in a register. If the comparison is equal, the value in a second register is conditionally written to memory. Storing back to memory is conditional on RCW Checks and RCWS Checks. If the write is performed, the read and the write occur atomically such that no other modification of the memory location can take place between the read and the write. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSCASL",
    "doc": "Read Check Write Software Compare and Swap doubleword in memory reads a 64-bit doubleword from memory, and compares it against the value held in a register. If the comparison is equal, the value in a second register is conditionally written to memory. Storing back to memory is conditional on RCW Checks and RCWS Checks. If the write is performed, the read and the write occur atomically such that no other modification of the memory location can take place between the read and the write. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSCASAL",
    "doc": "Read Check Write Software Compare and Swap doubleword in memory reads a 64-bit doubleword from memory, and compares it against the value held in a register. If the comparison is equal, the value in a second register is conditionally written to memory. Storing back to memory is conditional on RCW Checks and RCWS Checks. If the write is performed, the read and the write occur atomically such that no other modification of the memory location can take place between the read and the write. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSCASP",
    "doc": "Read Check Write Software Compare and Swap quadword in memory reads a 128-bit quadword from memory, and compares it against the value held in a pair of registers. If the comparison is equal, the value in a second pair of registers is conditionally written to memory. Storing back to memory is conditional on RCW Checks and RCWS Checks. If the write is performed, the read and the write occur atomically such that no other modification of the memory location can take place between the read and the write. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSCASPA",
    "doc": "Read Check Write Software Compare and Swap quadword in memory reads a 128-bit quadword from memory, and compares it against the value held in a pair of registers. If the comparison is equal, the value in a second pair of registers is conditionally written to memory. Storing back to memory is conditional on RCW Checks and RCWS Checks. If the write is performed, the read and the write occur atomically such that no other modification of the memory location can take place between the read and the write. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSCASPL",
    "doc": "Read Check Write Software Compare and Swap quadword in memory reads a 128-bit quadword from memory, and compares it against the value held in a pair of registers. If the comparison is equal, the value in a second pair of registers is conditionally written to memory. Storing back to memory is conditional on RCW Checks and RCWS Checks. If the write is performed, the read and the write occur atomically such that no other modification of the memory location can take place between the read and the write. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSCASPAL",
    "doc": "Read Check Write Software Compare and Swap quadword in memory reads a 128-bit quadword from memory, and compares it against the value held in a pair of registers. If the comparison is equal, the value in a second pair of registers is conditionally written to memory. Storing back to memory is conditional on RCW Checks and RCWS Checks. If the write is performed, the read and the write occur atomically such that no other modification of the memory location can take place between the read and the write. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSCLR",
    "doc": "Read Check Write Software atomic bit Clear on doubleword in memory atomically loads a 64-bit doubleword from memory, performs a bitwise AND with the complement of the value held in a register on it, and conditionally stores the result back to memory. Storing of the result back to memory is conditional on RCW Checks and RCWS Checks. The value initially loaded from memory is returned in the destination register. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSCLRA",
    "doc": "Read Check Write Software atomic bit Clear on doubleword in memory atomically loads a 64-bit doubleword from memory, performs a bitwise AND with the complement of the value held in a register on it, and conditionally stores the result back to memory. Storing of the result back to memory is conditional on RCW Checks and RCWS Checks. The value initially loaded from memory is returned in the destination register. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSCLRL",
    "doc": "Read Check Write Software atomic bit Clear on doubleword in memory atomically loads a 64-bit doubleword from memory, performs a bitwise AND with the complement of the value held in a register on it, and conditionally stores the result back to memory. Storing of the result back to memory is conditional on RCW Checks and RCWS Checks. The value initially loaded from memory is returned in the destination register. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSCLRAL",
    "doc": "Read Check Write Software atomic bit Clear on doubleword in memory atomically loads a 64-bit doubleword from memory, performs a bitwise AND with the complement of the value held in a register on it, and conditionally stores the result back to memory. Storing of the result back to memory is conditional on RCW Checks and RCWS Checks. The value initially loaded from memory is returned in the destination register. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSCLRP",
    "doc": "Read Check Write Software atomic bit Clear on quadword in memory atomically loads a 128-bit quadword from memory, performs a bitwise AND with the complement of the value held in a pair of registers on it, and conditionally stores the result back to memory. Storing of the result back to memory is conditional on RCW Checks and RCWS Checks. The value initially loaded from memory is returned in the same pair of registers. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSCLRPA",
    "doc": "Read Check Write Software atomic bit Clear on quadword in memory atomically loads a 128-bit quadword from memory, performs a bitwise AND with the complement of the value held in a pair of registers on it, and conditionally stores the result back to memory. Storing of the result back to memory is conditional on RCW Checks and RCWS Checks. The value initially loaded from memory is returned in the same pair of registers. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSCLRPL",
    "doc": "Read Check Write Software atomic bit Clear on quadword in memory atomically loads a 128-bit quadword from memory, performs a bitwise AND with the complement of the value held in a pair of registers on it, and conditionally stores the result back to memory. Storing of the result back to memory is conditional on RCW Checks and RCWS Checks. The value initially loaded from memory is returned in the same pair of registers. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSCLRPAL",
    "doc": "Read Check Write Software atomic bit Clear on quadword in memory atomically loads a 128-bit quadword from memory, performs a bitwise AND with the complement of the value held in a pair of registers on it, and conditionally stores the result back to memory. Storing of the result back to memory is conditional on RCW Checks and RCWS Checks. The value initially loaded from memory is returned in the same pair of registers. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSET",
    "doc": "Read Check Write atomic bit Set on doubleword in memory atomically loads a 64-bit doubleword from memory, performs a bitwise OR with the complement of the value held in a register on it, and conditionally stores the result back to memory. Storing of the result back to memory is conditional on RCW Checks. The value initially loaded from memory is returned in the destination register. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSETA",
    "doc": "Read Check Write atomic bit Set on doubleword in memory atomically loads a 64-bit doubleword from memory, performs a bitwise OR with the complement of the value held in a register on it, and conditionally stores the result back to memory. Storing of the result back to memory is conditional on RCW Checks. The value initially loaded from memory is returned in the destination register. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSETL",
    "doc": "Read Check Write atomic bit Set on doubleword in memory atomically loads a 64-bit doubleword from memory, performs a bitwise OR with the complement of the value held in a register on it, and conditionally stores the result back to memory. Storing of the result back to memory is conditional on RCW Checks. The value initially loaded from memory is returned in the destination register. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSETAL",
    "doc": "Read Check Write atomic bit Set on doubleword in memory atomically loads a 64-bit doubleword from memory, performs a bitwise OR with the complement of the value held in a register on it, and conditionally stores the result back to memory. Storing of the result back to memory is conditional on RCW Checks. The value initially loaded from memory is returned in the destination register. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSETP",
    "doc": "Read Check Write atomic bit Set on quadword in memory atomically loads a 128-bit quadword from memory, performs a bitwise OR with the value held in a pair of registers on it, and conditionally stores the result back to memory. Storing of the result back to memory is conditional on RCW Checks. The value initially loaded from memory is returned in the same pair of registers. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSETPA",
    "doc": "Read Check Write atomic bit Set on quadword in memory atomically loads a 128-bit quadword from memory, performs a bitwise OR with the value held in a pair of registers on it, and conditionally stores the result back to memory. Storing of the result back to memory is conditional on RCW Checks. The value initially loaded from memory is returned in the same pair of registers. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSETPL",
    "doc": "Read Check Write atomic bit Set on quadword in memory atomically loads a 128-bit quadword from memory, performs a bitwise OR with the value held in a pair of registers on it, and conditionally stores the result back to memory. Storing of the result back to memory is conditional on RCW Checks. The value initially loaded from memory is returned in the same pair of registers. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSETPAL",
    "doc": "Read Check Write atomic bit Set on quadword in memory atomically loads a 128-bit quadword from memory, performs a bitwise OR with the value held in a pair of registers on it, and conditionally stores the result back to memory. Storing of the result back to memory is conditional on RCW Checks. The value initially loaded from memory is returned in the same pair of registers. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSSET",
    "doc": "Read Check Write Software atomic bit Set on doubleword in memory atomically loads a 64-bit doubleword from memory, performs a bitwise OR with the complement of the value held in a register on it, and conditionally stores the result back to memory. Storing of the result back to memory is conditional on RCW Checks and RCWS Checks. The value initially loaded from memory is returned in the destination register. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSSETA",
    "doc": "Read Check Write Software atomic bit Set on doubleword in memory atomically loads a 64-bit doubleword from memory, performs a bitwise OR with the complement of the value held in a register on it, and conditionally stores the result back to memory. Storing of the result back to memory is conditional on RCW Checks and RCWS Checks. The value initially loaded from memory is returned in the destination register. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSSETL",
    "doc": "Read Check Write Software atomic bit Set on doubleword in memory atomically loads a 64-bit doubleword from memory, performs a bitwise OR with the complement of the value held in a register on it, and conditionally stores the result back to memory. Storing of the result back to memory is conditional on RCW Checks and RCWS Checks. The value initially loaded from memory is returned in the destination register. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSSETAL",
    "doc": "Read Check Write Software atomic bit Set on doubleword in memory atomically loads a 64-bit doubleword from memory, performs a bitwise OR with the complement of the value held in a register on it, and conditionally stores the result back to memory. Storing of the result back to memory is conditional on RCW Checks and RCWS Checks. The value initially loaded from memory is returned in the destination register. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSSETP",
    "doc": "Read Check Write Software atomic bit Set on quadword in memory atomically loads a 128-bit quadword from memory, performs a bitwise OR with the value held in a pair of registers on it, and conditionally stores the result back to memory. Storing of the result back to memory is conditional on RCW Checks and RCWS Checks. The value initially loaded from memory is returned in the same pair of registers. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSSETPA",
    "doc": "Read Check Write Software atomic bit Set on quadword in memory atomically loads a 128-bit quadword from memory, performs a bitwise OR with the value held in a pair of registers on it, and conditionally stores the result back to memory. Storing of the result back to memory is conditional on RCW Checks and RCWS Checks. The value initially loaded from memory is returned in the same pair of registers. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSSETPL",
    "doc": "Read Check Write Software atomic bit Set on quadword in memory atomically loads a 128-bit quadword from memory, performs a bitwise OR with the value held in a pair of registers on it, and conditionally stores the result back to memory. Storing of the result back to memory is conditional on RCW Checks and RCWS Checks. The value initially loaded from memory is returned in the same pair of registers. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSSETPAL",
    "doc": "Read Check Write Software atomic bit Set on quadword in memory atomically loads a 128-bit quadword from memory, performs a bitwise OR with the value held in a pair of registers on it, and conditionally stores the result back to memory. Storing of the result back to memory is conditional on RCW Checks and RCWS Checks. The value initially loaded from memory is returned in the same pair of registers. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSSWP",
    "doc": "Read Check Write Software Swap doubleword in memory atomically loads a 64-bit doubleword from a memory location, and conditionally stores the value held in a register back to the same memory location. Storing back to memory is conditional on RCW Checks and RCWS Checks. The value initially loaded from memory is returned in the destination register. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSSWPA",
    "doc": "Read Check Write Software Swap doubleword in memory atomically loads a 64-bit doubleword from a memory location, and conditionally stores the value held in a register back to the same memory location. Storing back to memory is conditional on RCW Checks and RCWS Checks. The value initially loaded from memory is returned in the destination register. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSSWPL",
    "doc": "Read Check Write Software Swap doubleword in memory atomically loads a 64-bit doubleword from a memory location, and conditionally stores the value held in a register back to the same memory location. Storing back to memory is conditional on RCW Checks and RCWS Checks. The value initially loaded from memory is returned in the destination register. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSSWPAL",
    "doc": "Read Check Write Software Swap doubleword in memory atomically loads a 64-bit doubleword from a memory location, and conditionally stores the value held in a register back to the same memory location. Storing back to memory is conditional on RCW Checks and RCWS Checks. The value initially loaded from memory is returned in the destination register. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSSWPP",
    "doc": "Read Check Write Software Swap quadword in memory atomically loads a 128-bit quadword from a memory location, and conditionally stores the value held in a pair of registers back to the same memory location. Storing back to memory is conditional on RCW Checks and RCWS Checks. The value initially loaded from memory is returned in the same pair of registers. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSSWPPA",
    "doc": "Read Check Write Software Swap quadword in memory atomically loads a 128-bit quadword from a memory location, and conditionally stores the value held in a pair of registers back to the same memory location. Storing back to memory is conditional on RCW Checks and RCWS Checks. The value initially loaded from memory is returned in the same pair of registers. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSSWPPL",
    "doc": "Read Check Write Software Swap quadword in memory atomically loads a 128-bit quadword from a memory location, and conditionally stores the value held in a pair of registers back to the same memory location. Storing back to memory is conditional on RCW Checks and RCWS Checks. The value initially loaded from memory is returned in the same pair of registers. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSSWPPAL",
    "doc": "Read Check Write Software Swap quadword in memory atomically loads a 128-bit quadword from a memory location, and conditionally stores the value held in a pair of registers back to the same memory location. Storing back to memory is conditional on RCW Checks and RCWS Checks. The value initially loaded from memory is returned in the same pair of registers. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSWP",
    "doc": "Read Check Write Swap doubleword in memory atomically loads a 64-bit doubleword from a memory location, and conditionally stores the value held in a register back to the same memory location. Storing back to memory is conditional on RCW Checks. The value initially loaded from memory is returned in the destination register. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSWPA",
    "doc": "Read Check Write Swap doubleword in memory atomically loads a 64-bit doubleword from a memory location, and conditionally stores the value held in a register back to the same memory location. Storing back to memory is conditional on RCW Checks. The value initially loaded from memory is returned in the destination register. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSWPL",
    "doc": "Read Check Write Swap doubleword in memory atomically loads a 64-bit doubleword from a memory location, and conditionally stores the value held in a register back to the same memory location. Storing back to memory is conditional on RCW Checks. The value initially loaded from memory is returned in the destination register. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSWPAL",
    "doc": "Read Check Write Swap doubleword in memory atomically loads a 64-bit doubleword from a memory location, and conditionally stores the value held in a register back to the same memory location. Storing back to memory is conditional on RCW Checks. The value initially loaded from memory is returned in the destination register. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSWPP",
    "doc": "Read Check Write Swap quadword in memory atomically loads a 128-bit quadword from a memory location, and conditionally stores the value held in a pair of registers back to the same memory location. Storing back to memory is conditional on RCW Checks. The value initially loaded from memory is returned in the same pair of registers. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSWPPA",
    "doc": "Read Check Write Swap quadword in memory atomically loads a 128-bit quadword from a memory location, and conditionally stores the value held in a pair of registers back to the same memory location. Storing back to memory is conditional on RCW Checks. The value initially loaded from memory is returned in the same pair of registers. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSWPPL",
    "doc": "Read Check Write Swap quadword in memory atomically loads a 128-bit quadword from a memory location, and conditionally stores the value held in a pair of registers back to the same memory location. Storing back to memory is conditional on RCW Checks. The value initially loaded from memory is returned in the same pair of registers. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RCWSWPPAL",
    "doc": "Read Check Write Swap quadword in memory atomically loads a 128-bit quadword from a memory location, and conditionally stores the value held in a pair of registers back to the same memory location. Storing back to memory is conditional on RCW Checks. The value initially loaded from memory is returned in the same pair of registers. This instruction updates the condition flags based on the result of the update of memory."
  },
  {
    "name": "RDFFRS",
    "doc": "Return predicate of succesfully loaded elements, setting the condition flags"
  },
  {
    "name": "RDFFR",
    "doc": "Read the first-fault register"
  },
  {
    "name": "RDSVL",
    "doc": "Read multiple of Streaming SVE vector register size to scalar register"
  },
  {
    "name": "RDVL",
    "doc": "Read multiple of vector register size to scalar register"
  },
  {
    "name": "RET",
    "doc": "Return from subroutine branches unconditionally to an address in a register, with a hint that this is a subroutine return."
  },
  {
    "name": "RETAA",
    "doc": "Return from subroutine, with pointer authentication. This instruction authenticates the address that is held in LR, using SP as the modifier and the specified key, branches to the authenticated address, with a hint that this instruction is a subroutine return."
  },
  {
    "name": "RETAB",
    "doc": "Return from subroutine, with pointer authentication. This instruction authenticates the address that is held in LR, using SP as the modifier and the specified key, branches to the authenticated address, with a hint that this instruction is a subroutine return."
  },
  {
    "name": "REV",
    "doc": "Reverse Bytes reverses the byte order in a register."
  },
  {
    "name": "REV16",
    "doc": "Reverse elements in 16-bit halfwords (vector). This instruction reverses the order of 8-bit elements in each halfword of the vector in the source SIMD&amp;FP register, places the results into a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "REV32",
    "doc": "Reverse elements in 32-bit words (vector). This instruction reverses the order of 8-bit or 16-bit elements in each word of the vector in the source SIMD&amp;FP register, places the results into a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "REV64",
    "doc": "Reverse elements in 64-bit doublewords (vector). This instruction reverses the order of 8-bit, 16-bit, or 32-bit elements in each doubleword of the vector in the source SIMD&amp;FP register, places the results into a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "REVB",
    "doc": "Reverse bytes / halfwords / words within elements (predicated)"
  },
  {
    "name": "REVH",
    "doc": "Reverse bytes / halfwords / words within elements (predicated)"
  },
  {
    "name": "REVW",
    "doc": "Reverse bytes / halfwords / words within elements (predicated)"
  },
  {
    "name": "REVD",
    "doc": "Reverse 64-bit doublewords in elements (predicated)"
  },
  {
    "name": "RMIF",
    "doc": "Performs a rotation right of a value held in a general purpose register by an immediate value, and then inserts a selection of the bottom four bits of the result of the rotation into the PSTATE flags, under the control of a second immediate mask."
  },
  {
    "name": "RORV",
    "doc": "Rotate Right Variable provides the value of the contents of a register rotated by a variable number of bits. The bits that are rotated off the right end are inserted into the vacated bit positions on the left. The remainder obtained by dividing the second source register by the data size defines the number of bits by which the first source register is right-shifted."
  },
  {
    "name": "ROR",
    "doc": "Rotate right (immediate) provides the value of the contents of a register rotated by a variable number of bits. The bits that are rotated off the right end are inserted into the vacated bit positions on the left."
  },
  {
    "name": "RPRFM",
    "doc": "Range Prefetch Memory signals the memory system that data memory accesses from a specified range of addresses are likely to occur in the near future. The instruction may also signal the memory system about the likelihood of data reuse of the specified range of addresses. The memory system can respond by taking actions that are expected to speed up the memory accesses when they do occur, such as prefetching locations within the specified address ranges into one or more caches. The memory system may also exploit the data reuse hints to decide whether to retain the data in other caches upon eviction from the innermost caches or to discard it."
  },
  {
    "name": "RSHRNB",
    "doc": "Rounding shift right narrow by immediate (bottom)"
  },
  {
    "name": "RSHRNT",
    "doc": "Rounding shift right narrow by immediate (top)"
  },
  {
    "name": "RSHRN",
    "doc": "Rounding Shift Right Narrow (immediate). This instruction reads each unsigned integer value from the vector in the source SIMD&amp;FP register, right shifts each result by an immediate value, writes the final result to a vector, and writes the vector to the lower or upper half of the destination SIMD&amp;FP register. The destination vector elements are half as long as the source vector elements. The results are rounded. For truncated results, see SHRN."
  },
  {
    "name": "RSHRN2",
    "doc": "Rounding Shift Right Narrow (immediate). This instruction reads each unsigned integer value from the vector in the source SIMD&amp;FP register, right shifts each result by an immediate value, writes the final result to a vector, and writes the vector to the lower or upper half of the destination SIMD&amp;FP register. The destination vector elements are half as long as the source vector elements. The results are rounded. For truncated results, see SHRN."
  },
  {
    "name": "RSUBHNB",
    "doc": "Rounding subtract narrow high part (bottom)"
  },
  {
    "name": "RSUBHNT",
    "doc": "Rounding subtract narrow high part (top)"
  },
  {
    "name": "RSUBHN",
    "doc": "Rounding Subtract returning High Narrow. This instruction subtracts each vector element of the second source SIMD&amp;FP register from the corresponding vector element of the first source SIMD&amp;FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&amp;FP register."
  },
  {
    "name": "RSUBHN2",
    "doc": "Rounding Subtract returning High Narrow. This instruction subtracts each vector element of the second source SIMD&amp;FP register from the corresponding vector element of the first source SIMD&amp;FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&amp;FP register."
  },
  {
    "name": "SABALB",
    "doc": "Signed absolute difference and accumulate long (bottom)"
  },
  {
    "name": "SABALT",
    "doc": "Signed absolute difference and accumulate long (top)"
  },
  {
    "name": "SABAL",
    "doc": "Signed Absolute difference and Accumulate Long. This instruction subtracts the vector elements in the lower or upper half of the second source SIMD&amp;FP register from the corresponding vector elements of the first source SIMD&amp;FP register, and accumulates the absolute values of the results into the vector elements of the destination SIMD&amp;FP register. The destination vector elements are twice as long as the source vector elements."
  },
  {
    "name": "SABAL2",
    "doc": "Signed Absolute difference and Accumulate Long. This instruction subtracts the vector elements in the lower or upper half of the second source SIMD&amp;FP register from the corresponding vector elements of the first source SIMD&amp;FP register, and accumulates the absolute values of the results into the vector elements of the destination SIMD&amp;FP register. The destination vector elements are twice as long as the source vector elements."
  },
  {
    "name": "SABA",
    "doc": "Signed Absolute difference and Accumulate. This instruction subtracts the elements of the vector of the second source SIMD&amp;FP register from the corresponding elements of the first source SIMD&amp;FP register, and accumulates the absolute values of the results into the elements of the vector of the destination SIMD&amp;FP register."
  },
  {
    "name": "SABDLB",
    "doc": "Signed absolute difference long (bottom)"
  },
  {
    "name": "SABDLT",
    "doc": "Signed absolute difference long (top)"
  },
  {
    "name": "SABDL",
    "doc": "Signed Absolute Difference Long. This instruction subtracts the vector elements in the lower or upper half of the second source SIMD&amp;FP register from the corresponding vector elements of the first source SIMD&amp;FP register, places the absolute value of the results into a vector, and writes the vector to the destination SIMD&amp;FP register. The destination vector elements are twice as long as the source vector elements."
  },
  {
    "name": "SABDL2",
    "doc": "Signed Absolute Difference Long. This instruction subtracts the vector elements in the lower or upper half of the second source SIMD&amp;FP register from the corresponding vector elements of the first source SIMD&amp;FP register, places the absolute value of the results into a vector, and writes the vector to the destination SIMD&amp;FP register. The destination vector elements are twice as long as the source vector elements."
  },
  {
    "name": "SABD",
    "doc": "Signed Absolute Difference. This instruction subtracts the elements of the vector of the second source SIMD&amp;FP register from the corresponding elements of the first source SIMD&amp;FP register, places the absolute values of the results into a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "SADALP",
    "doc": "Signed Add and Accumulate Long Pairwise. This instruction adds pairs of adjacent signed integer values from the vector in the source SIMD&amp;FP register and accumulates the results into the vector elements of the destination SIMD&amp;FP register. The destination vector elements are twice as long as the source vector elements."
  },
  {
    "name": "SADDLBT",
    "doc": "Signed add long (bottom + top)"
  },
  {
    "name": "SADDLB",
    "doc": "Signed add long (bottom)"
  },
  {
    "name": "SADDLP",
    "doc": "Signed Add Long Pairwise. This instruction adds pairs of adjacent signed integer values from the vector in the source SIMD&amp;FP register, places the result into a vector, and writes the vector to the destination SIMD&amp;FP register. The destination vector elements are twice as long as the source vector elements."
  },
  {
    "name": "SADDLT",
    "doc": "Signed add long (top)"
  },
  {
    "name": "SADDLV",
    "doc": "Signed Add Long across Vector. This instruction adds every vector element in the source SIMD&amp;FP register together, and writes the scalar result to the destination SIMD&amp;FP register. The destination scalar is twice as long as the source vector elements. All the values in this instruction are signed integer values."
  },
  {
    "name": "SADDL",
    "doc": "Signed Add Long (vector). This instruction adds each vector element in the lower or upper half of the first source SIMD&amp;FP register to the corresponding vector element of the second source SIMD&amp;FP register, places the results into a vector, and writes the vector to the destination SIMD&amp;FP register.  The destination vector elements are twice as long as the source vector elements. All the values in this instruction are signed integer values."
  },
  {
    "name": "SADDL2",
    "doc": "Signed Add Long (vector). This instruction adds each vector element in the lower or upper half of the first source SIMD&amp;FP register to the corresponding vector element of the second source SIMD&amp;FP register, places the results into a vector, and writes the vector to the destination SIMD&amp;FP register.  The destination vector elements are twice as long as the source vector elements. All the values in this instruction are signed integer values."
  },
  {
    "name": "SADDV",
    "doc": "Signed add reduction to scalar"
  },
  {
    "name": "SADDWB",
    "doc": "Signed add wide (bottom)"
  },
  {
    "name": "SADDWT",
    "doc": "Signed add wide (top)"
  },
  {
    "name": "SADDW",
    "doc": "Signed Add Wide. This instruction adds vector elements of the first source SIMD&amp;FP register to the corresponding vector elements in the lower or upper half of the second source SIMD&amp;FP register, places the results in a vector, and writes the vector to the SIMD&amp;FP destination register."
  },
  {
    "name": "SADDW2",
    "doc": "Signed Add Wide. This instruction adds vector elements of the first source SIMD&amp;FP register to the corresponding vector elements in the lower or upper half of the second source SIMD&amp;FP register, places the results in a vector, and writes the vector to the SIMD&amp;FP destination register."
  },
  {
    "name": "SB",
    "doc": "Speculation Barrier is a barrier that controls speculation."
  },
  {
    "name": "SBC",
    "doc": "Subtract with Carry subtracts a register value and the value of NOT (Carry flag) from a register value, and writes the result to the destination register."
  },
  {
    "name": "SBCLB",
    "doc": "Subtract with carry long (bottom)"
  },
  {
    "name": "SBCLT",
    "doc": "Subtract with carry long (top)"
  },
  {
    "name": "SBCS",
    "doc": "Subtract with Carry, setting flags, subtracts a register value and the value of NOT (Carry flag) from a register value, and writes the result to the destination register. It updates the condition flags based on the result."
  },
  {
    "name": "SBFIZ",
    "doc": "Signed Bitfield Insert in Zeros copies a bitfield of &lt;width&gt; bits from the least significant bits of the source register to bit position &lt;lsb&gt; of the destination register, setting the destination bits below the bitfield to zero, and the bits above the bitfield to a copy of the most significant bit of the bitfield."
  },
  {
    "name": "SBFM",
    "doc": "Signed Bitfield Move is usually accessed via one of its aliases, which are always preferred for disassembly."
  },
  {
    "name": "SBFX",
    "doc": "Signed Bitfield Extract copies a bitfield of &lt;width&gt; bits starting from bit position &lt;lsb&gt; in the source register to the least significant bits of the destination register, and sets destination bits above the bitfield to a copy of the most significant bit of the bitfield."
  },
  {
    "name": "SCLAMP",
    "doc": "Multi-vector signed clamp to minimum/maximum vector"
  },
  {
    "name": "SCVTF",
    "doc": "Signed fixed-point Convert to Floating-point (vector). This instruction converts each element in a vector from fixed-point to floating-point using the rounding mode that is specified by the FPCR, and writes the result to the SIMD&amp;FP destination register."
  },
  {
    "name": "SDIV",
    "doc": "Signed Divide divides a signed integer register value by another signed integer register value, and writes the result to the destination register. The condition flags are not affected."
  },
  {
    "name": "SDIVR",
    "doc": "Signed reversed divide (predicated)"
  },
  {
    "name": "SDOT",
    "doc": "Dot Product signed arithmetic (vector, by element). This instruction performs the dot product of the four 8-bit elements in each 32-bit element of the first source register with the four 8-bit elements of an indexed 32-bit element in the second source register, accumulating the result into the corresponding 32-bit element of the destination register."
  },
  {
    "name": "2",
    "doc": "Signed integer dot product"
  },
  {
    "name": "4",
    "doc": "Multi-vector signed integer dot-product by indexed element"
  },
  {
    "name": "SEL",
    "doc": "Multi-vector conditionally select elements from two vectors"
  },
  {
    "name": "SETF8",
    "doc": "Set the PSTATE.NZV flags based on the value in the specified general-purpose register. SETF8 treats the value as an 8 bit value, and SETF16 treats the value as an 16 bit value."
  },
  {
    "name": "SETF16",
    "doc": "Set the PSTATE.NZV flags based on the value in the specified general-purpose register. SETF8 treats the value as an 8 bit value, and SETF16 treats the value as an 16 bit value."
  },
  {
    "name": "SETFFR",
    "doc": "Initialise the first-fault register to all true"
  },
  {
    "name": "SETGP",
    "doc": "Memory Set with tag setting. These instructions perform a memory set using the value in the bottom byte of the source register and store an Allocation Tag to memory for each Tag Granule written. The Allocation Tag is calculated from the Logical Address Tag in the register which holds the first address that the set is made to. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: SETGP, then SETGM, and then SETGE."
  },
  {
    "name": "SETGM",
    "doc": "Memory Set with tag setting. These instructions perform a memory set using the value in the bottom byte of the source register and store an Allocation Tag to memory for each Tag Granule written. The Allocation Tag is calculated from the Logical Address Tag in the register which holds the first address that the set is made to. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: SETGP, then SETGM, and then SETGE."
  },
  {
    "name": "SETGE",
    "doc": "Memory Set with tag setting. These instructions perform a memory set using the value in the bottom byte of the source register and store an Allocation Tag to memory for each Tag Granule written. The Allocation Tag is calculated from the Logical Address Tag in the register which holds the first address that the set is made to. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: SETGP, then SETGM, and then SETGE."
  },
  {
    "name": "SETGPN",
    "doc": "Memory Set with tag setting, non-temporal. These instructions perform a memory set using the value in the bottom byte of the source register and store an Allocation Tag to memory for each Tag Granule written. The Allocation Tag is calculated from the Logical Address Tag in the register which holds the first address that the set is made to. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: SETGPN, then SETGMN, and then SETGEN."
  },
  {
    "name": "SETGMN",
    "doc": "Memory Set with tag setting, non-temporal. These instructions perform a memory set using the value in the bottom byte of the source register and store an Allocation Tag to memory for each Tag Granule written. The Allocation Tag is calculated from the Logical Address Tag in the register which holds the first address that the set is made to. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: SETGPN, then SETGMN, and then SETGEN."
  },
  {
    "name": "SETGEN",
    "doc": "Memory Set with tag setting, non-temporal. These instructions perform a memory set using the value in the bottom byte of the source register and store an Allocation Tag to memory for each Tag Granule written. The Allocation Tag is calculated from the Logical Address Tag in the register which holds the first address that the set is made to. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: SETGPN, then SETGMN, and then SETGEN."
  },
  {
    "name": "SETGPT",
    "doc": "Memory Set with tag setting, unprivileged. These instructions perform a memory set using the value in the bottom byte of the source register and store an Allocation Tag to memory for each Tag Granule written. The Allocation Tag is calculated from the Logical Address Tag in the register which holds the first address that the set is made to. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: SETGPT, then SETGMT, and then SETGET."
  },
  {
    "name": "SETGMT",
    "doc": "Memory Set with tag setting, unprivileged. These instructions perform a memory set using the value in the bottom byte of the source register and store an Allocation Tag to memory for each Tag Granule written. The Allocation Tag is calculated from the Logical Address Tag in the register which holds the first address that the set is made to. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: SETGPT, then SETGMT, and then SETGET."
  },
  {
    "name": "SETGET",
    "doc": "Memory Set with tag setting, unprivileged. These instructions perform a memory set using the value in the bottom byte of the source register and store an Allocation Tag to memory for each Tag Granule written. The Allocation Tag is calculated from the Logical Address Tag in the register which holds the first address that the set is made to. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: SETGPT, then SETGMT, and then SETGET."
  },
  {
    "name": "SETGPTN",
    "doc": "Memory Set with tag setting, unprivileged and non-temporal. These instructions perform a memory set using the value in the bottom byte of the source register and store an Allocation Tag to memory for each Tag Granule written. The Allocation Tag is calculated from the Logical Address Tag in the register which holds the first address that the set is made to. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: SETGPTN, then SETGMTN, and then SETGETN."
  },
  {
    "name": "SETGMTN",
    "doc": "Memory Set with tag setting, unprivileged and non-temporal. These instructions perform a memory set using the value in the bottom byte of the source register and store an Allocation Tag to memory for each Tag Granule written. The Allocation Tag is calculated from the Logical Address Tag in the register which holds the first address that the set is made to. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: SETGPTN, then SETGMTN, and then SETGETN."
  },
  {
    "name": "SETGETN",
    "doc": "Memory Set with tag setting, unprivileged and non-temporal. These instructions perform a memory set using the value in the bottom byte of the source register and store an Allocation Tag to memory for each Tag Granule written. The Allocation Tag is calculated from the Logical Address Tag in the register which holds the first address that the set is made to. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: SETGPTN, then SETGMTN, and then SETGETN."
  },
  {
    "name": "SETP",
    "doc": "Memory Set. These instructions perform a memory set using the value in the bottom byte of the source register. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: SETP, then SETM, and then SETE."
  },
  {
    "name": "SETM",
    "doc": "Memory Set. These instructions perform a memory set using the value in the bottom byte of the source register. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: SETP, then SETM, and then SETE."
  },
  {
    "name": "SETE",
    "doc": "Memory Set. These instructions perform a memory set using the value in the bottom byte of the source register. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: SETP, then SETM, and then SETE."
  },
  {
    "name": "SETPN",
    "doc": "Memory Set, non-temporal. These instructions perform a memory set using the value in the bottom byte of the source register. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: SETPN, then SETMN, and then SETEN."
  },
  {
    "name": "SETMN",
    "doc": "Memory Set, non-temporal. These instructions perform a memory set using the value in the bottom byte of the source register. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: SETPN, then SETMN, and then SETEN."
  },
  {
    "name": "SETEN",
    "doc": "Memory Set, non-temporal. These instructions perform a memory set using the value in the bottom byte of the source register. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: SETPN, then SETMN, and then SETEN."
  },
  {
    "name": "SETPT",
    "doc": "Memory Set, unprivileged. These instructions perform a memory set using the value in the bottom byte of the source register. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: SETPT, then SETMT, and then SETET."
  },
  {
    "name": "SETMT",
    "doc": "Memory Set, unprivileged. These instructions perform a memory set using the value in the bottom byte of the source register. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: SETPT, then SETMT, and then SETET."
  },
  {
    "name": "SETET",
    "doc": "Memory Set, unprivileged. These instructions perform a memory set using the value in the bottom byte of the source register. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: SETPT, then SETMT, and then SETET."
  },
  {
    "name": "SETPTN",
    "doc": "Memory Set, unprivileged and non-temporal. These instructions perform a memory set using the value in the bottom byte of the source register. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: SETPTN, then SETMTN, and then SETETN."
  },
  {
    "name": "SETMTN",
    "doc": "Memory Set, unprivileged and non-temporal. These instructions perform a memory set using the value in the bottom byte of the source register. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: SETPTN, then SETMTN, and then SETETN."
  },
  {
    "name": "SETETN",
    "doc": "Memory Set, unprivileged and non-temporal. These instructions perform a memory set using the value in the bottom byte of the source register. The prologue, main, and epilogue instructions are expected to be run in succession and to appear consecutively in memory: SETPTN, then SETMTN, and then SETETN."
  },
  {
    "name": "SEV",
    "doc": "Send Event is a hint instruction. It causes an event to be signaled to all PEs in the multiprocessor system. For more information, see Wait for Event mechanism and Send event."
  },
  {
    "name": "SEVL",
    "doc": "Send Event Local is a hint instruction that causes an event to be signaled locally without requiring the event to be signaled to other PEs in the multiprocessor system. It can prime a wait-loop which starts with a WFE instruction."
  },
  {
    "name": "SHA1C",
    "doc": "SHA1 hash update (choose)."
  },
  {
    "name": "SHA1H",
    "doc": "SHA1 fixed rotate."
  },
  {
    "name": "SHA1M",
    "doc": "SHA1 hash update (majority)."
  },
  {
    "name": "SHA1P",
    "doc": "SHA1 hash update (parity)."
  },
  {
    "name": "SHA1SU0",
    "doc": "SHA1 schedule update 0."
  },
  {
    "name": "SHA1SU1",
    "doc": "SHA1 schedule update 1."
  },
  {
    "name": "SHA256H2",
    "doc": "SHA256 hash update (part 2)."
  },
  {
    "name": "SHA256H",
    "doc": "SHA256 hash update (part 1)."
  },
  {
    "name": "SHA256SU0",
    "doc": "SHA256 schedule update 0."
  },
  {
    "name": "SHA256SU1",
    "doc": "SHA256 schedule update 1."
  },
  {
    "name": "SHA512H2",
    "doc": "SHA512 Hash update part 2 takes the values from the three 128-bit source SIMD&amp;FP registers and produces a 128-bit output value that combines the sigma0 and majority functions of two iterations of the SHA512 computation. It returns this value to the destination SIMD&amp;FP register."
  },
  {
    "name": "SHA512H",
    "doc": "SHA512 Hash update part 1 takes the values from the three 128-bit source SIMD&amp;FP registers and produces a 128-bit output value that combines the sigma1 and chi functions of two iterations of the SHA512 computation. It returns this value to the destination SIMD&amp;FP register."
  },
  {
    "name": "SHA512SU0",
    "doc": "SHA512 Schedule Update 0 takes the values from the two 128-bit source SIMD&amp;FP registers and produces a 128-bit output value that combines the gamma0 functions of two iterations of the SHA512 schedule update that are performed after the first 16 iterations within a block. It returns this value to the destination SIMD&amp;FP register."
  },
  {
    "name": "SHA512SU1",
    "doc": "SHA512 Schedule Update 1 takes the values from the three source SIMD&amp;FP registers and produces a 128-bit output value that combines the gamma1 functions of two iterations of the SHA512 schedule update that are performed after the first 16 iterations within a block. It returns this value to the destination SIMD&amp;FP register."
  },
  {
    "name": "SHADD",
    "doc": "Signed Halving Add. This instruction adds corresponding signed integer values from the two source SIMD&amp;FP registers, shifts each result right one bit, places the results into a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "S",
    "doc": "This page displays common pseudocode functions shared by many pages"
  },
  {
    "name": "SHLL",
    "doc": "Shift Left Long (by element size). This instruction reads each vector element in the lower or upper half of the source SIMD&amp;FP register, left shifts each result by the element size, writes the final result to a vector, and writes the vector to the destination SIMD&amp;FP register. The destination vector elements are twice as long as the source vector elements."
  },
  {
    "name": "SHLL2",
    "doc": "Shift Left Long (by element size). This instruction reads each vector element in the lower or upper half of the source SIMD&amp;FP register, left shifts each result by the element size, writes the final result to a vector, and writes the vector to the destination SIMD&amp;FP register. The destination vector elements are twice as long as the source vector elements."
  },
  {
    "name": "SHL",
    "doc": "Shift Left (immediate). This instruction reads each value from a vector, left shifts each result by an immediate value, writes the final result to a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "SHRNB",
    "doc": "Shift right narrow by immediate (bottom)"
  },
  {
    "name": "SHRNT",
    "doc": "Shift right narrow by immediate (top)"
  },
  {
    "name": "SHRN",
    "doc": "Shift Right Narrow (immediate). This instruction reads each unsigned integer value from the source SIMD&amp;FP register, right shifts each result by an immediate value, puts the final result into a vector, and writes the vector to the lower or upper half of the destination SIMD&amp;FP register. The destination vector elements are half as long as the source vector elements. The results are truncated. For rounded results, see RSHRN."
  },
  {
    "name": "SHRN2",
    "doc": "Shift Right Narrow (immediate). This instruction reads each unsigned integer value from the source SIMD&amp;FP register, right shifts each result by an immediate value, puts the final result into a vector, and writes the vector to the lower or upper half of the destination SIMD&amp;FP register. The destination vector elements are half as long as the source vector elements. The results are truncated. For rounded results, see RSHRN."
  },
  {
    "name": "SHSUBR",
    "doc": "Signed halving subtract reversed vectors"
  },
  {
    "name": "SHSUB",
    "doc": "Signed Halving Subtract. This instruction subtracts the elements in the vector in the second source SIMD&amp;FP register from the corresponding elements in the vector in the first source SIMD&amp;FP register, shifts each result right one bit, places each result into elements of a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "SLI",
    "doc": "Shift Left and Insert (immediate). This instruction reads each vector element in the source SIMD&amp;FP register, left shifts each vector element by an immediate value, and inserts the result into the corresponding vector element in the destination SIMD&amp;FP register such that the new zero bits created by the shift are not inserted but retain their existing value. Bits shifted out of the left of each vector element in the source register are lost."
  },
  {
    "name": "SM3PARTW1",
    "doc": "SM3PARTW1 takes three 128-bit vectors from the three source SIMD&amp;FP registers and returns a 128-bit result in the destination SIMD&amp;FP register. The result is obtained by a three-way exclusive-OR of the elements within the input vectors with some fixed rotations, see the Operation pseudocode for more information."
  },
  {
    "name": "SM3PARTW2",
    "doc": "SM3PARTW2 takes three 128-bit vectors from three source SIMD&amp;FP registers and returns a 128-bit result in the destination SIMD&amp;FP register. The result is obtained by a three-way exclusive-OR of the elements within the input vectors with some fixed rotations, see the Operation pseudocode for more information."
  },
  {
    "name": "SM3SS1",
    "doc": "SM3SS1 rotates the top 32 bits of the 128-bit vector in the first source SIMD&amp;FP register by 12, and adds that 32-bit value to the two other 32-bit values held in the top 32 bits of each of the 128-bit vectors in the second and third source SIMD&amp;FP registers, rotating this result left by 7 and writing the final result into the top 32 bits of the vector in the destination SIMD&amp;FP register, with the bottom 96 bits of the vector being written to 0."
  },
  {
    "name": "SM3TT1A",
    "doc": "SM3TT1A takes three 128-bit vectors from three source SIMD&amp;FP registers and a 2-bit immediate index value, and returns a 128-bit result in the destination SIMD&amp;FP register.  It performs a three-way exclusive-OR of the three 32-bit fields held in the upper three elements of the first source vector, and adds the resulting 32-bit value and the following three other 32-bit values:"
  },
  {
    "name": "SM3TT1B",
    "doc": "SM3TT1B takes three 128-bit vectors from three source SIMD&amp;FP registers and a 2-bit immediate index value, and returns a 128-bit result in the destination SIMD&amp;FP register. It performs a 32-bit majority function between the three 32-bit fields held in the upper three elements of the first source vector, and adds the resulting 32-bit value and the following three other 32-bit values:"
  },
  {
    "name": "SM3TT2A",
    "doc": "SM3TT2A takes three 128-bit vectors from three source SIMD&amp;FP register and a 2-bit immediate index value, and returns a 128-bit result in the destination SIMD&amp;FP register. It performs a three-way exclusive-OR of the three 32-bit fields held in the upper three elements of the first source vector, and adds the resulting 32-bit value and the following three other 32-bit values:"
  },
  {
    "name": "SM3TT2B",
    "doc": "SM3TT2B takes three 128-bit vectors from three source SIMD&amp;FP registers, and a 2-bit immediate index value, and returns a 128-bit result in the destination SIMD&amp;FP register. It performs a 32-bit majority function between the three 32-bit fields held in the upper three elements of the first source vector, and adds the resulting 32-bit value and the following three other 32-bit values:"
  },
  {
    "name": "SM4EKEY",
    "doc": "SM4 Key takes an input as a 128-bit vector from the first source SIMD&amp;FP register and a 128-bit constant from the second SIMD&amp;FP register. It derives four iterations of the output key, in accordance with the SM4 standard, returning the 128-bit result to the destination SIMD&amp;FP register."
  },
  {
    "name": "SM4E",
    "doc": "SM4 Encode takes input data as a 128-bit vector from the first source SIMD&amp;FP register, and four iterations of the round key held as the elements of the 128-bit vector in the second source SIMD&amp;FP register. It encrypts the data by four rounds, in accordance with the SM4 standard, returning the 128-bit result to the destination SIMD&amp;FP register."
  },
  {
    "name": "SMADDL",
    "doc": "Signed Multiply-Add Long multiplies two 32-bit register values, adds a 64-bit register value, and writes the result to the 64-bit destination register."
  },
  {
    "name": "SMAXP",
    "doc": "Signed Maximum Pairwise. This instruction creates a vector by concatenating the vector elements of the first source SIMD&amp;FP register after the vector elements of the second source SIMD&amp;FP register, reads each pair of adjacent vector elements in the two source SIMD&amp;FP registers, writes the largest of each pair of signed integer values into a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "SMAXQV",
    "doc": "Signed maximum reduction of quadword vector segments"
  },
  {
    "name": "SMAXV",
    "doc": "Signed Maximum across Vector. This instruction compares all the vector elements in the source SIMD&amp;FP register, and writes the largest of the values as a scalar to the destination SIMD&amp;FP register. All the values in this instruction are signed integer values."
  },
  {
    "name": "SMAX",
    "doc": "Signed Maximum (vector). This instruction compares corresponding elements in the vectors in the two source SIMD&amp;FP registers, places the larger of each pair of signed integer values into a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "SMC",
    "doc": "Secure Monitor Call causes an exception to EL3."
  },
  {
    "name": "SMINP",
    "doc": "Signed Minimum Pairwise. This instruction creates a vector by concatenating the vector elements of the first source SIMD&amp;FP register after the vector elements of the second source SIMD&amp;FP register, reads each pair of adjacent vector elements in the two source SIMD&amp;FP registers, writes the smallest of each pair of signed integer values into a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "SMINQV",
    "doc": "Signed minimum reduction of quadword vector segments"
  },
  {
    "name": "SMINV",
    "doc": "Signed Minimum across Vector. This instruction compares all the vector elements in the source SIMD&amp;FP register, and writes the smallest of the values as a scalar to the destination SIMD&amp;FP register. All the values in this instruction are signed integer values."
  },
  {
    "name": "SMIN",
    "doc": "Signed Minimum (vector). This instruction compares corresponding elements in the vectors in the two source SIMD&amp;FP registers, places the smaller of each of the two signed integer values into a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "SMLALB",
    "doc": "Signed multiply-add long to accumulator (bottom)"
  },
  {
    "name": "SMLALL",
    "doc": "Multi-vector signed integer multiply-add long-long by indexed element"
  },
  {
    "name": "SMLALT",
    "doc": "Signed multiply-add long to accumulator (top)"
  },
  {
    "name": "SMLAL",
    "doc": "Signed Multiply-Add Long (vector, by element). This instruction multiplies each vector element in the lower or upper half of the first source SIMD&amp;FP register by the specified vector element in the second source SIMD&amp;FP register, and accumulates the results with the vector elements of the destination SIMD&amp;FP register. The destination vector elements are twice as long as the elements that are multiplied. All the values in this instruction are signed integer values."
  },
  {
    "name": "SMLAL2",
    "doc": "Signed Multiply-Add Long (vector, by element). This instruction multiplies each vector element in the lower or upper half of the first source SIMD&amp;FP register by the specified vector element in the second source SIMD&amp;FP register, and accumulates the results with the vector elements of the destination SIMD&amp;FP register. The destination vector elements are twice as long as the elements that are multiplied. All the values in this instruction are signed integer values."
  },
  {
    "name": "SMLSLB",
    "doc": "Signed multiply-subtract long from accumulator (bottom)"
  },
  {
    "name": "SMLSLL",
    "doc": "Multi-vector signed integer multiply-subtract long-long by indexed element"
  },
  {
    "name": "SMLSLT",
    "doc": "Signed multiply-subtract long from accumulator (top)"
  },
  {
    "name": "SMLSL",
    "doc": "Signed Multiply-Subtract Long (vector, by element). This instruction multiplies each vector element in the lower or upper half of the first source SIMD&amp;FP register by the specified vector element of the second source SIMD&amp;FP register and subtracts the results from the vector elements of the destination SIMD&amp;FP register. The destination vector elements are twice as long as the elements that are multiplied."
  },
  {
    "name": "SMLSL2",
    "doc": "Signed Multiply-Subtract Long (vector, by element). This instruction multiplies each vector element in the lower or upper half of the first source SIMD&amp;FP register by the specified vector element of the second source SIMD&amp;FP register and subtracts the results from the vector elements of the destination SIMD&amp;FP register. The destination vector elements are twice as long as the elements that are multiplied."
  },
  {
    "name": "SMMLA",
    "doc": "Signed 8-bit integer matrix multiply-accumulate. This instruction multiplies the 2x8 matrix of signed 8-bit integer values in the first source vector by the 8x2 matrix of signed 8-bit integer values in the second source vector. The resulting 2x2 32-bit integer matrix product is destructively added to the 32-bit integer matrix accumulator in the destination vector. This is equivalent to performing an 8-way dot product per destination element."
  },
  {
    "name": "SMNEGL",
    "doc": "Signed Multiply-Negate Long multiplies two 32-bit register values, negates the product, and writes the result to the 64-bit destination register."
  },
  {
    "name": "SMOPA",
    "doc": "Signed integer sum of outer products and accumulate"
  },
  {
    "name": "SMOPS",
    "doc": "Signed integer sum of outer products and subtract"
  },
  {
    "name": "SMOV",
    "doc": "Signed Move vector element to general-purpose register. This instruction reads the signed integer from the source SIMD&amp;FP register, sign-extends it to form a 32-bit or 64-bit value, and writes the result to destination general-purpose register."
  },
  {
    "name": "SMSTART",
    "doc": "Enables access to Streaming SVE mode and SME architectural state."
  },
  {
    "name": "SMSTOP",
    "doc": "Disables access to Streaming SVE mode and SME architectural state."
  },
  {
    "name": "SMSUBL",
    "doc": "Signed Multiply-Subtract Long multiplies two 32-bit register values, subtracts the product from a 64-bit register value, and writes the result to the 64-bit destination register."
  },
  {
    "name": "SMULH",
    "doc": "Signed Multiply High multiplies two 64-bit register values, and writes bits[127:64] of the 128-bit result to the 64-bit destination register."
  },
  {
    "name": "SMULLB",
    "doc": "Signed multiply long (bottom)"
  },
  {
    "name": "SMULLT",
    "doc": "Signed multiply long (top)"
  },
  {
    "name": "SMULL",
    "doc": "Signed Multiply Long (vector, by element). This instruction multiplies each vector element in the lower or upper half of the first source SIMD&amp;FP register by the specified vector element of the second source SIMD&amp;FP register, places the result in a vector, and writes the vector to the destination SIMD&amp;FP register. The destination vector elements are twice as long as the elements that are multiplied."
  },
  {
    "name": "SMULL2",
    "doc": "Signed Multiply Long (vector, by element). This instruction multiplies each vector element in the lower or upper half of the first source SIMD&amp;FP register by the specified vector element of the second source SIMD&amp;FP register, places the result in a vector, and writes the vector to the destination SIMD&amp;FP register. The destination vector elements are twice as long as the elements that are multiplied."
  },
  {
    "name": "SPLICE",
    "doc": "Splice two vectors under predicate control"
  },
  {
    "name": "SQABS",
    "doc": "Signed saturating Absolute value. This instruction reads each vector element from the source SIMD&amp;FP register, puts the absolute value of the result into a vector, and writes the vector to the destination SIMD&amp;FP register. All the values in this instruction are signed integer values."
  },
  {
    "name": "SQADD",
    "doc": "Signed saturating Add. This instruction adds the values of corresponding elements of the two source SIMD&amp;FP registers, places the results into a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "SQCADD",
    "doc": "Saturating complex integer add with rotate"
  },
  {
    "name": "SQCVTN",
    "doc": "Signed saturating extract narrow and interleave"
  },
  {
    "name": "SQCVTUN",
    "doc": "Signed saturating unsigned extract narrow and interleave"
  },
  {
    "name": "SQCVTU",
    "doc": "Multi-vector signed saturating unsigned extract narrow"
  },
  {
    "name": "SQCVT",
    "doc": "Multi-vector signed saturating extract narrow"
  },
  {
    "name": "SQDECB",
    "doc": "Signed saturating decrement scalar by multiple of 8-bit predicate constraint element count"
  },
  {
    "name": "SQDECD",
    "doc": "Signed saturating decrement scalar by multiple of 64-bit predicate constraint element count"
  },
  {
    "name": "SQDECH",
    "doc": "Signed saturating decrement scalar by multiple of 16-bit predicate constraint element count"
  },
  {
    "name": "SQDECP",
    "doc": "Signed saturating decrement scalar by count of true predicate elements"
  },
  {
    "name": "SQDECW",
    "doc": "Signed saturating decrement scalar by multiple of 32-bit predicate constraint element count"
  },
  {
    "name": "SQDMLALBT",
    "doc": "Signed saturating doubling multiply-add long to accumulator (bottom × top)"
  },
  {
    "name": "SQDMLALB",
    "doc": "Signed saturating doubling multiply-add long to accumulator (bottom)"
  },
  {
    "name": "SQDMLALT",
    "doc": "Signed saturating doubling multiply-add long to accumulator (top)"
  },
  {
    "name": "SQDMLAL",
    "doc": "Signed saturating Doubling Multiply-Add Long (by element). This instruction multiplies each vector element in the lower or upper half of the first source SIMD&amp;FP register by the specified vector element of the second source SIMD&amp;FP register, doubles the results, and accumulates the final results with the vector elements of the destination SIMD&amp;FP register. The destination vector elements are twice as long as the elements that are multiplied."
  },
  {
    "name": "SQDMLAL2",
    "doc": "Signed saturating Doubling Multiply-Add Long (by element). This instruction multiplies each vector element in the lower or upper half of the first source SIMD&amp;FP register by the specified vector element of the second source SIMD&amp;FP register, doubles the results, and accumulates the final results with the vector elements of the destination SIMD&amp;FP register. The destination vector elements are twice as long as the elements that are multiplied."
  },
  {
    "name": "SQDMLSLBT",
    "doc": "Signed saturating doubling multiply-subtract long from accumulator (bottom × top)"
  },
  {
    "name": "SQDMLSLB",
    "doc": "Signed saturating doubling multiply-subtract long from accumulator (bottom)"
  },
  {
    "name": "SQDMLSLT",
    "doc": "Signed saturating doubling multiply-subtract long from accumulator (top)"
  },
  {
    "name": "SQDMLSL",
    "doc": "Signed saturating Doubling Multiply-Subtract Long (by element). This instruction multiplies each vector element in the lower or upper half of the first source SIMD&amp;FP register by the specified vector element of the second source SIMD&amp;FP register, doubles the results, and subtracts the final results from the vector elements of the destination SIMD&amp;FP register. The destination vector elements are twice as long as the elements that are multiplied. All the values in this instruction are signed integer values."
  },
  {
    "name": "SQDMLSL2",
    "doc": "Signed saturating Doubling Multiply-Subtract Long (by element). This instruction multiplies each vector element in the lower or upper half of the first source SIMD&amp;FP register by the specified vector element of the second source SIMD&amp;FP register, doubles the results, and subtracts the final results from the vector elements of the destination SIMD&amp;FP register. The destination vector elements are twice as long as the elements that are multiplied. All the values in this instruction are signed integer values."
  },
  {
    "name": "SQDMULH",
    "doc": "Signed saturating Doubling Multiply returning High half (by element). This instruction multiplies each vector element in the first source SIMD&amp;FP register by the specified vector element of the second source SIMD&amp;FP register, doubles the results, places the most significant half of the final results into a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "SQDMULLB",
    "doc": "Signed saturating doubling multiply long (bottom)"
  },
  {
    "name": "SQDMULLT",
    "doc": "Signed saturating doubling multiply long (top)"
  },
  {
    "name": "SQDMULL",
    "doc": "Signed saturating Doubling Multiply Long (by element). This instruction multiplies each vector element in the lower or upper half of the first source SIMD&amp;FP register by the specified vector element of the second source SIMD&amp;FP register, doubles the results, places the final results in a vector, and writes the vector to the destination SIMD&amp;FP register. All the values in this instruction are signed integer values."
  },
  {
    "name": "SQDMULL2",
    "doc": "Signed saturating Doubling Multiply Long (by element). This instruction multiplies each vector element in the lower or upper half of the first source SIMD&amp;FP register by the specified vector element of the second source SIMD&amp;FP register, doubles the results, places the final results in a vector, and writes the vector to the destination SIMD&amp;FP register. All the values in this instruction are signed integer values."
  },
  {
    "name": "SQINCB",
    "doc": "Signed saturating increment scalar by multiple of 8-bit predicate constraint element count"
  },
  {
    "name": "SQINCD",
    "doc": "Signed saturating increment scalar by multiple of 64-bit predicate constraint element count"
  },
  {
    "name": "SQINCH",
    "doc": "Signed saturating increment scalar by multiple of 16-bit predicate constraint element count"
  },
  {
    "name": "SQINCP",
    "doc": "Signed saturating increment scalar by count of true predicate elements"
  },
  {
    "name": "SQINCW",
    "doc": "Signed saturating increment scalar by multiple of 32-bit predicate constraint element count"
  },
  {
    "name": "SQNEG",
    "doc": "Signed saturating Negate. This instruction reads each vector element from the source SIMD&amp;FP register, negates each value, places the result into a vector, and writes the vector to the destination SIMD&amp;FP register. All the values in this instruction are signed integer values."
  },
  {
    "name": "SQRDCMLAH",
    "doc": "Saturating rounding doubling complex integer multiply-add high with rotate"
  },
  {
    "name": "SQRDMLAH",
    "doc": "Signed Saturating Rounding Doubling Multiply Accumulate returning High Half (by element). This instruction multiplies the vector elements of the first source SIMD&amp;FP register with the value of a vector element of the second source SIMD&amp;FP register without saturating the multiply results, doubles the results, and accumulates the most significant half of the final results with the vector elements of the destination SIMD&amp;FP register. The results are rounded."
  },
  {
    "name": "SQRDMLSH",
    "doc": "Signed Saturating Rounding Doubling Multiply Subtract returning High Half (by element). This instruction multiplies the vector elements of the first source SIMD&amp;FP register with the value of a vector element of the second source SIMD&amp;FP register without saturating the multiply results, doubles the results, and subtracts the most significant half of the final results from the vector elements of the destination SIMD&amp;FP register. The results are rounded."
  },
  {
    "name": "SQRDMULH",
    "doc": "Signed saturating Rounding Doubling Multiply returning High half (by element). This instruction multiplies each vector element in the first source SIMD&amp;FP register by the specified vector element of the second source SIMD&amp;FP register, doubles the results, places the most significant half of the final results into a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "SQRSHLR",
    "doc": "Signed saturating rounding shift left reversed vectors (predicated)"
  },
  {
    "name": "SQRSHL",
    "doc": "Signed saturating Rounding Shift Left (register). This instruction takes each vector element in the first source SIMD&amp;FP register, shifts it by a value from the least significant byte of the corresponding vector element of the second source SIMD&amp;FP register, places the results into a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "SQRSHRNB",
    "doc": "Signed saturating rounding shift right narrow by immediate (bottom)"
  },
  {
    "name": "SQRSHRNT",
    "doc": "Signed saturating rounding shift right narrow by immediate (top)"
  },
  {
    "name": "SQRSHRN",
    "doc": "Signed saturating Rounded Shift Right Narrow (immediate). This instruction reads each vector element in the source SIMD&amp;FP register, right shifts each result by an immediate value, saturates each shifted result to a value that is half the original width, puts the final result into a vector, and writes the vector to the lower or upper half of the destination SIMD&amp;FP register. All the values in this instruction are signed integer values. The destination vector elements are half as long as the source vector elements. The results are rounded. For truncated results, see SQSHRN."
  },
  {
    "name": "SQRSHRN2",
    "doc": "Signed saturating Rounded Shift Right Narrow (immediate). This instruction reads each vector element in the source SIMD&amp;FP register, right shifts each result by an immediate value, saturates each shifted result to a value that is half the original width, puts the final result into a vector, and writes the vector to the lower or upper half of the destination SIMD&amp;FP register. All the values in this instruction are signed integer values. The destination vector elements are half as long as the source vector elements. The results are rounded. For truncated results, see SQSHRN."
  },
  {
    "name": "SQRSHRUNB",
    "doc": "Signed saturating rounding shift right unsigned narrow by immediate (bottom)"
  },
  {
    "name": "SQRSHRUNT",
    "doc": "Signed saturating rounding shift right unsigned narrow by immediate (top)"
  },
  {
    "name": "SQRSHRUN",
    "doc": "Signed saturating Rounded Shift Right Unsigned Narrow (immediate). This instruction reads each signed integer value in the vector of the source SIMD&amp;FP register, right shifts each value by an immediate value, saturates the result to an unsigned integer value that is half the original width, places the final result into a vector, and writes the vector to the destination SIMD&amp;FP register. The results are rounded. For truncated results, see SQSHRUN."
  },
  {
    "name": "SQRSHRUN2",
    "doc": "Signed saturating Rounded Shift Right Unsigned Narrow (immediate). This instruction reads each signed integer value in the vector of the source SIMD&amp;FP register, right shifts each value by an immediate value, saturates the result to an unsigned integer value that is half the original width, places the final result into a vector, and writes the vector to the destination SIMD&amp;FP register. The results are rounded. For truncated results, see SQSHRUN."
  },
  {
    "name": "SQRSHRU",
    "doc": "Multi-vector signed saturating rounding shift right unsigned narrow by immediate"
  },
  {
    "name": "SQRSHR",
    "doc": "Multi-vector signed saturating rounding shift right narrow by immediate"
  },
  {
    "name": "SQSHLR",
    "doc": "Signed saturating shift left reversed vectors (predicated)"
  },
  {
    "name": "SQSHLU",
    "doc": "Signed saturating Shift Left Unsigned (immediate). This instruction reads each signed integer value in the vector of the source SIMD&amp;FP register, shifts each value by an immediate value, saturates the shifted result to an unsigned integer value, places the result in a vector, and writes the vector to the destination SIMD&amp;FP register. The results are truncated. For rounded results, see UQRSHL."
  },
  {
    "name": "SQSHL",
    "doc": "Signed saturating Shift Left (immediate). This instruction reads each vector element in the source SIMD&amp;FP register, shifts each result by an immediate value, places the final result in a vector, and writes the vector to the destination SIMD&amp;FP register. The results are truncated. For rounded results, see UQRSHL."
  },
  {
    "name": "SQSHRNB",
    "doc": "Signed saturating shift right narrow by immediate (bottom)"
  },
  {
    "name": "SQSHRNT",
    "doc": "Signed saturating shift right narrow by immediate (top)"
  },
  {
    "name": "SQSHRN",
    "doc": "Signed saturating Shift Right Narrow (immediate). This instruction reads each vector element in the source SIMD&amp;FP register, right shifts and truncates each result by an immediate value, saturates each shifted result to a value that is half the original width, puts the final result into a vector, and writes the vector to the lower or upper half of the destination SIMD&amp;FP register. All the values in this instruction are signed integer values. The destination vector elements are half as long as the source vector elements. For rounded results, see SQRSHRN."
  },
  {
    "name": "SQSHRN2",
    "doc": "Signed saturating Shift Right Narrow (immediate). This instruction reads each vector element in the source SIMD&amp;FP register, right shifts and truncates each result by an immediate value, saturates each shifted result to a value that is half the original width, puts the final result into a vector, and writes the vector to the lower or upper half of the destination SIMD&amp;FP register. All the values in this instruction are signed integer values. The destination vector elements are half as long as the source vector elements. For rounded results, see SQRSHRN."
  },
  {
    "name": "SQSHRUNB",
    "doc": "Signed saturating shift right unsigned narrow by immediate (bottom)"
  },
  {
    "name": "SQSHRUNT",
    "doc": "Signed saturating shift right unsigned narrow by immediate (top)"
  },
  {
    "name": "SQSHRUN",
    "doc": "Signed saturating Shift Right Unsigned Narrow (immediate). This instruction reads each signed integer value in the vector of the source SIMD&amp;FP register, right shifts each value by an immediate value, saturates the result to an unsigned integer value that is half the original width, places the final result into a vector, and writes the vector to the destination SIMD&amp;FP register. The results are truncated. For rounded results, see SQRSHRUN."
  },
  {
    "name": "SQSHRUN2",
    "doc": "Signed saturating Shift Right Unsigned Narrow (immediate). This instruction reads each signed integer value in the vector of the source SIMD&amp;FP register, right shifts each value by an immediate value, saturates the result to an unsigned integer value that is half the original width, places the final result into a vector, and writes the vector to the destination SIMD&amp;FP register. The results are truncated. For rounded results, see SQRSHRUN."
  },
  {
    "name": "SQSUBR",
    "doc": "Signed saturating subtraction reversed vectors (predicated)"
  },
  {
    "name": "SQSUB",
    "doc": "Signed saturating Subtract. This instruction subtracts the element values of the second source SIMD&amp;FP register from the corresponding element values of the first source SIMD&amp;FP register, places the results into a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "SQXTNB",
    "doc": "Signed saturating extract narrow (bottom)"
  },
  {
    "name": "SQXTNT",
    "doc": "Signed saturating extract narrow (top)"
  },
  {
    "name": "SQXTN",
    "doc": "Signed saturating extract Narrow. This instruction reads each vector element from the source SIMD&amp;FP register, saturates the value to half the original width, places the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&amp;FP register. The destination vector elements are half as long as the source vector elements. All the values in this instruction are signed integer values."
  },
  {
    "name": "SQXTN2",
    "doc": "Signed saturating extract Narrow. This instruction reads each vector element from the source SIMD&amp;FP register, saturates the value to half the original width, places the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&amp;FP register. The destination vector elements are half as long as the source vector elements. All the values in this instruction are signed integer values."
  },
  {
    "name": "SQXTUNB",
    "doc": "Signed saturating unsigned extract narrow (bottom)"
  },
  {
    "name": "SQXTUNT",
    "doc": "Signed saturating unsigned extract narrow (top)"
  },
  {
    "name": "SQXTUN",
    "doc": "Signed saturating extract Unsigned Narrow. This instruction reads each signed integer value in the vector of the source SIMD&amp;FP register, saturates the value to an unsigned integer value that is half the original width, places the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&amp;FP register. The destination vector elements are half as long as the source vector elements."
  },
  {
    "name": "SQXTUN2",
    "doc": "Signed saturating extract Unsigned Narrow. This instruction reads each signed integer value in the vector of the source SIMD&amp;FP register, saturates the value to an unsigned integer value that is half the original width, places the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&amp;FP register. The destination vector elements are half as long as the source vector elements."
  },
  {
    "name": "SRHADD",
    "doc": "Signed Rounding Halving Add. This instruction adds corresponding signed integer values from the two source SIMD&amp;FP registers, shifts each result right one bit, places the results into a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "SRI",
    "doc": "Shift Right and Insert (immediate). This instruction reads each vector element in the source SIMD&amp;FP register, right shifts each vector element by an immediate value, and inserts the result into the corresponding vector element in the destination SIMD&amp;FP register such that the new zero bits created by the shift are not inserted but retain their existing value. Bits shifted out of the right of each vector element of the source register are lost."
  },
  {
    "name": "SRSHLR",
    "doc": "Signed rounding shift left reversed vectors (predicated)"
  },
  {
    "name": "SRSHL",
    "doc": "Signed Rounding Shift Left (register). This instruction takes each signed integer value in the vector of the first source SIMD&amp;FP register, shifts it by a value from the least significant byte of the corresponding element of the second source SIMD&amp;FP register, places the results in a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "SRSHR",
    "doc": "Signed Rounding Shift Right (immediate). This instruction reads each vector element in the source SIMD&amp;FP register, right shifts each result by an immediate value, places the final result into a vector, and writes the vector to the destination SIMD&amp;FP register. All the values in this instruction are signed integer values. The results are rounded. For truncated results, see SSHR."
  },
  {
    "name": "SRSRA",
    "doc": "Signed Rounding Shift Right and Accumulate (immediate). This instruction reads each vector element in the source SIMD&amp;FP register, right shifts each result by an immediate value, and accumulates the final results with the vector elements of the destination SIMD&amp;FP register. All the values in this instruction are signed integer values. The results are rounded. For truncated results, see SSRA."
  },
  {
    "name": "SSBB",
    "doc": "Speculative Store Bypass Barrier is a memory barrier that prevents speculative loads from bypassing earlier stores to the same virtual address under certain conditions. For more information and details of the semantics, see Speculative Store Bypass Barrier (SSBB)."
  },
  {
    "name": "SSHLLB",
    "doc": "Signed shift left long by immediate (bottom)"
  },
  {
    "name": "SSHLLT",
    "doc": "Signed shift left long by immediate (top)"
  },
  {
    "name": "SSHLL",
    "doc": "Signed Shift Left Long (immediate). This instruction reads each vector element from the source SIMD&amp;FP register, left shifts each vector element by the specified shift amount, places the result into a vector, and writes the vector to the destination SIMD&amp;FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are signed integer values."
  },
  {
    "name": "SSHLL2",
    "doc": "Signed Shift Left Long (immediate). This instruction reads each vector element from the source SIMD&amp;FP register, left shifts each vector element by the specified shift amount, places the result into a vector, and writes the vector to the destination SIMD&amp;FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are signed integer values."
  },
  {
    "name": "SSHL",
    "doc": "Signed Shift Left (register). This instruction takes each signed integer value in the vector of the first source SIMD&amp;FP register, shifts each value by a value from the least significant byte of the corresponding element of the second source SIMD&amp;FP register, places the results in a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "SSHR",
    "doc": "Signed Shift Right (immediate). This instruction reads each vector element in the source SIMD&amp;FP register, right shifts each result by an immediate value, places the final result into a vector, and writes the vector to the destination SIMD&amp;FP register. All the values in this instruction are signed integer values. The results are truncated. For rounded results, see SRSHR."
  },
  {
    "name": "SSRA",
    "doc": "Signed Shift Right and Accumulate (immediate). This instruction reads each vector element in the source SIMD&amp;FP register, right shifts each result by an immediate value, and accumulates the final results with the vector elements of the destination SIMD&amp;FP register. All the values in this instruction are signed integer values. The results are truncated. For rounded results, see SRSRA."
  },
  {
    "name": "SSUBLBT",
    "doc": "Signed subtract long (bottom - top)"
  },
  {
    "name": "SSUBLB",
    "doc": "Signed subtract long (bottom)"
  },
  {
    "name": "SSUBLTB",
    "doc": "Signed subtract long (top - bottom)"
  },
  {
    "name": "SSUBLT",
    "doc": "Signed subtract long (top)"
  },
  {
    "name": "SSUBL",
    "doc": "Signed Subtract Long. This instruction subtracts each vector element in the lower or upper half of the second source SIMD&amp;FP register from the corresponding vector element of the first source SIMD&amp;FP register, places the results into a vector, and writes the vector to the destination SIMD&amp;FP register. All the values in this instruction are signed integer values. The destination vector elements are twice as long as the source vector elements."
  },
  {
    "name": "SSUBL2",
    "doc": "Signed Subtract Long. This instruction subtracts each vector element in the lower or upper half of the second source SIMD&amp;FP register from the corresponding vector element of the first source SIMD&amp;FP register, places the results into a vector, and writes the vector to the destination SIMD&amp;FP register. All the values in this instruction are signed integer values. The destination vector elements are twice as long as the source vector elements."
  },
  {
    "name": "SSUBWB",
    "doc": "Signed subtract wide (bottom)"
  },
  {
    "name": "SSUBWT",
    "doc": "Signed subtract wide (top)"
  },
  {
    "name": "SSUBW",
    "doc": "Signed Subtract Wide. This instruction subtracts each vector element in the lower or upper half of the second source SIMD&amp;FP register from the corresponding vector element in the first source SIMD&amp;FP register, places the result in a vector, and writes the vector to the SIMD&amp;FP destination register. All the values in this instruction are signed integer values."
  },
  {
    "name": "SSUBW2",
    "doc": "Signed Subtract Wide. This instruction subtracts each vector element in the lower or upper half of the second source SIMD&amp;FP register from the corresponding vector element in the first source SIMD&amp;FP register, places the result in a vector, and writes the vector to the SIMD&amp;FP destination register. All the values in this instruction are signed integer values."
  },
  {
    "name": "ST1B",
    "doc": "Contiguous store of bytes from multiple strided vectors (immediate index)"
  },
  {
    "name": "ST1D",
    "doc": "Contiguous store of doublewords from multiple strided vectors (immediate index)"
  },
  {
    "name": "ST1H",
    "doc": "Contiguous store of halfwords from multiple strided vectors (immediate index)"
  },
  {
    "name": "ST1Q",
    "doc": "Contiguous store of quadwords from 128-bit element ZA tile slice"
  },
  {
    "name": "ST1W",
    "doc": "Contiguous store of words from multiple strided vectors (immediate index)"
  },
  {
    "name": "ST1",
    "doc": "Store multiple single-element structures from one, two, three, or four registers. This instruction stores elements to memory from one, two, three, or four SIMD&amp;FP registers, without interleaving. Every element of each register is stored."
  },
  {
    "name": "ST2B",
    "doc": "Contiguous store two-byte structures from two vectors (immediate index)"
  },
  {
    "name": "ST2D",
    "doc": "Contiguous store two-doubleword structures from two vectors (immediate index)"
  },
  {
    "name": "ST2G",
    "doc": "Store Allocation Tags stores an Allocation Tag to two Tag granules of memory. The address used for the store is calculated from the base register and an immediate signed offset scaled by the Tag granule. The Allocation Tag is calculated from the Logical Address Tag in the source register."
  },
  {
    "name": "ST2H",
    "doc": "Contiguous store two-halfword structures from two vectors (immediate index)"
  },
  {
    "name": "ST2Q",
    "doc": "Contiguous store two-quadword structures from two vectors (immediate index)"
  },
  {
    "name": "ST2W",
    "doc": "Contiguous store two-word structures from two vectors (immediate index)"
  },
  {
    "name": "ST2",
    "doc": "Store multiple 2-element structures from two registers. This instruction stores multiple 2-element structures from two SIMD&amp;FP registers to memory, with interleaving. Every element of each register is stored."
  },
  {
    "name": "ST3B",
    "doc": "Contiguous store three-byte structures from three vectors (immediate index)"
  },
  {
    "name": "ST3D",
    "doc": "Contiguous store three-doubleword structures from three vectors (immediate index)"
  },
  {
    "name": "ST3H",
    "doc": "Contiguous store three-halfword structures from three vectors (immediate index)"
  },
  {
    "name": "ST3Q",
    "doc": "Contiguous store three-quadword structures from three vectors (immediate index)"
  },
  {
    "name": "ST3W",
    "doc": "Contiguous store three-word structures from three vectors (immediate index)"
  },
  {
    "name": "ST3",
    "doc": "Store multiple 3-element structures from three registers. This instruction stores multiple 3-element structures to memory from three SIMD&amp;FP registers, with interleaving. Every element of each register is stored."
  },
  {
    "name": "ST4B",
    "doc": "Contiguous store four-byte structures from four vectors (immediate index)"
  },
  {
    "name": "ST4D",
    "doc": "Contiguous store four-doubleword structures from four vectors (immediate index)"
  },
  {
    "name": "ST4H",
    "doc": "Contiguous store four-halfword structures from four vectors (immediate index)"
  },
  {
    "name": "ST4Q",
    "doc": "Contiguous store four-quadword structures from four vectors (immediate index)"
  },
  {
    "name": "ST4W",
    "doc": "Contiguous store four-word structures from four vectors (immediate index)"
  },
  {
    "name": "ST4",
    "doc": "Store multiple 4-element structures from four registers. This instruction stores multiple 4-element structures to memory from four SIMD&amp;FP registers, with interleaving. Every element of each register is stored."
  },
  {
    "name": "ST64B",
    "doc": "Single-copy Atomic 64-byte Store without Return stores eight 64-bit doublewords from consecutive registers, Xt to X(t+7), to a memory location. The data that is stored is atomic and is required to be 64-byte-aligned."
  },
  {
    "name": "ST64BV",
    "doc": "Single-copy Atomic 64-byte Store with Return stores eight 64-bit doublewords from consecutive registers, Xt to X(t+7), to a memory location, and writes the status result of the store to a register. The data that is stored is atomic and is required to be 64-byte aligned."
  },
  {
    "name": "ST64BV0",
    "doc": "Single-copy Atomic 64-byte EL0 Store with Return stores eight 64-bit doublewords from consecutive registers, Xt to X(t+7), to a memory location, with the bottom 32 bits taken from ACCDATA_EL1, and writes the status result of the store to a register. The data that is stored is atomic and is required to be 64-byte aligned."
  },
  {
    "name": "STADDB",
    "doc": "Atomic add on byte in memory, without return, atomically loads an 8-bit byte from memory, adds the value held in a register to it, and stores the result back to memory."
  },
  {
    "name": "STADDLB",
    "doc": "Atomic add on byte in memory, without return, atomically loads an 8-bit byte from memory, adds the value held in a register to it, and stores the result back to memory."
  },
  {
    "name": "STADDH",
    "doc": "Atomic add on halfword in memory, without return, atomically loads a 16-bit halfword from memory, adds the value held in a register to it, and stores the result back to memory."
  },
  {
    "name": "STADDLH",
    "doc": "Atomic add on halfword in memory, without return, atomically loads a 16-bit halfword from memory, adds the value held in a register to it, and stores the result back to memory."
  },
  {
    "name": "STADD",
    "doc": "Atomic add on word or doubleword in memory, without return, atomically loads a 32-bit word or 64-bit doubleword from memory, adds the value held in a register to it, and stores the result back to memory."
  },
  {
    "name": "STADDL",
    "doc": "Atomic add on word or doubleword in memory, without return, atomically loads a 32-bit word or 64-bit doubleword from memory, adds the value held in a register to it, and stores the result back to memory."
  },
  {
    "name": "STCLRB",
    "doc": "Atomic bit clear on byte in memory, without return, atomically loads an 8-bit byte from memory, performs a bitwise AND with the complement of the value held in a register on it, and stores the result back to memory."
  },
  {
    "name": "STCLRLB",
    "doc": "Atomic bit clear on byte in memory, without return, atomically loads an 8-bit byte from memory, performs a bitwise AND with the complement of the value held in a register on it, and stores the result back to memory."
  },
  {
    "name": "STCLRH",
    "doc": "Atomic bit clear on halfword in memory, without return, atomically loads a 16-bit halfword from memory, performs a bitwise AND with the complement of the value held in a register on it, and stores the result back to memory."
  },
  {
    "name": "STCLRLH",
    "doc": "Atomic bit clear on halfword in memory, without return, atomically loads a 16-bit halfword from memory, performs a bitwise AND with the complement of the value held in a register on it, and stores the result back to memory."
  },
  {
    "name": "STCLR",
    "doc": "Atomic bit clear on word or doubleword in memory, without return, atomically loads a 32-bit word or 64-bit doubleword from memory, performs a bitwise AND with the complement of the value held in a register on it, and stores the result back to memory."
  },
  {
    "name": "STCLRL",
    "doc": "Atomic bit clear on word or doubleword in memory, without return, atomically loads a 32-bit word or 64-bit doubleword from memory, performs a bitwise AND with the complement of the value held in a register on it, and stores the result back to memory."
  },
  {
    "name": "STEORB",
    "doc": "Atomic Exclusive-OR on byte in memory, without return, atomically loads an 8-bit byte from memory, performs an exclusive-OR with the value held in a register on it, and stores the result back to memory."
  },
  {
    "name": "STEORLB",
    "doc": "Atomic Exclusive-OR on byte in memory, without return, atomically loads an 8-bit byte from memory, performs an exclusive-OR with the value held in a register on it, and stores the result back to memory."
  },
  {
    "name": "STEORH",
    "doc": "Atomic Exclusive-OR on halfword in memory, without return, atomically loads a 16-bit halfword from memory, performs an exclusive-OR with the value held in a register on it, and stores the result back to memory."
  },
  {
    "name": "STEORLH",
    "doc": "Atomic Exclusive-OR on halfword in memory, without return, atomically loads a 16-bit halfword from memory, performs an exclusive-OR with the value held in a register on it, and stores the result back to memory."
  },
  {
    "name": "STEOR",
    "doc": "Atomic Exclusive-OR on word or doubleword in memory, without return, atomically loads a 32-bit word or 64-bit doubleword from memory, performs an exclusive-OR with the value held in a register on it, and stores the result back to memory."
  },
  {
    "name": "STEORL",
    "doc": "Atomic Exclusive-OR on word or doubleword in memory, without return, atomically loads a 32-bit word or 64-bit doubleword from memory, performs an exclusive-OR with the value held in a register on it, and stores the result back to memory."
  },
  {
    "name": "STG",
    "doc": "Store Allocation Tag stores an Allocation Tag to memory. The address used for the store is calculated from the base register and an immediate signed offset scaled by the Tag granule. The Allocation Tag is calculated from the Logical Address Tag in the source register."
  },
  {
    "name": "STGM",
    "doc": "Store Tag Multiple writes a naturally aligned block of N Allocation Tags, where the size of N is identified in GMID_EL1.BS, and the Allocation Tag written to address A is taken from the source register at 4*A&lt;7:4&gt;+3:4*A&lt;7:4&gt;."
  },
  {
    "name": "STGP",
    "doc": "Store Allocation Tag and Pair of registers stores an Allocation Tag and two 64-bit doublewords to memory, from two registers. The address used for the store is calculated from the base register and an immediate signed offset scaled by the Tag granule. The Allocation Tag is calculated from the Logical Address Tag in the base register."
  },
  {
    "name": "STILP",
    "doc": "Store-Release ordered Pair of registers calculates an address from a base register value and an optional offset, and stores two 32-bit words or two 64-bit doublewords to the calculated address, from two registers. For information on single-copy atomicity and alignment requirements, see Requirements for single-copy atomicity and Alignment of data accesses. The instruction also has memory ordering semantics, as described in Load-Acquire, Load-AcquirePC, and Store-Release, with the additional requirement that:"
  },
  {
    "name": "STL1",
    "doc": "Store-Release a single-element structure from one lane of one register. This instruction stores the specified element of a SIMD&amp;FP register to memory."
  },
  {
    "name": "STLLR",
    "doc": "Store LORelease Register stores a 32-bit word or a 64-bit doubleword to a memory location, from a register. The instruction also has memory ordering semantics as described in Load LOAcquire, Store LORelease. For information about memory accesses, see Load/Store addressing modes."
  },
  {
    "name": "STLLRB",
    "doc": "Store LORelease Register Byte stores a byte from a 32-bit register to a memory location. The instruction also has memory ordering semantics as described in Load LOAcquire, Store LORelease. For information about memory accesses, see Load/Store addressing modes."
  },
  {
    "name": "STLLRH",
    "doc": "Store LORelease Register Halfword stores a halfword from a 32-bit register to a memory location. The instruction also has memory ordering semantics as described in Load LOAcquire, Store LORelease. For information about memory accesses, see Load/Store addressing modes."
  },
  {
    "name": "STLR",
    "doc": "Store-Release Register stores a 32-bit word or a 64-bit doubleword to a memory location, from a register. The instruction also has memory ordering semantics as described in Load-Acquire, Store-Release. For information about memory accesses, see Load/Store addressing modes."
  },
  {
    "name": "STLRB",
    "doc": "Store-Release Register Byte stores a byte from a 32-bit register to a memory location. The instruction also has memory ordering semantics as described in Load-Acquire, Store-Release. For information about memory accesses, see Load/Store addressing modes."
  },
  {
    "name": "STLRH",
    "doc": "Store-Release Register Halfword stores a halfword from a 32-bit register to a memory location. The instruction also has memory ordering semantics as described in Load-Acquire, Store-Release. For information about memory accesses, see Load/Store addressing modes."
  },
  {
    "name": "STLURB",
    "doc": "Store-Release Register Byte (unscaled) calculates an address from a base register value and an immediate offset, and stores a byte to the calculated address, from a 32-bit register."
  },
  {
    "name": "STLURH",
    "doc": "Store-Release Register Halfword (unscaled) calculates an address from a base register value and an immediate offset, and stores a halfword to the calculated address, from a 32-bit register."
  },
  {
    "name": "STLUR",
    "doc": "Store-Release SIMD&amp;FP Register (unscaled offset). This instruction stores a single SIMD&amp;FP register to memory. The address that is used for the store is calculated from a base register value and an optional immediate offset."
  },
  {
    "name": "STLXP",
    "doc": "Store-Release Exclusive Pair of registers stores two 32-bit words or two 64-bit doublewords to a memory location if the PE has exclusive access to the memory address, from two registers, and returns a status value of 0 if the store was successful, or of 1 if no store was performed. See Synchronization and semaphores. For information on single-copy atomicity and alignment requirements, see Requirements for single-copy atomicity and Alignment of data accesses. If a 64-bit pair Store-Exclusive succeeds, it causes a single-copy atomic update of the 128-bit memory location being updated. The instruction also has memory ordering semantics, as described in Load-Acquire, Store-Release. For information about memory accesses, see Load/Store addressing modes."
  },
  {
    "name": "STLXR",
    "doc": "Store-Release Exclusive Register stores a 32-bit word or a 64-bit doubleword to memory if the PE has exclusive access to the memory address, from two registers, and returns a status value of 0 if the store was successful, or of 1 if no store was performed. See Synchronization and semaphores. The memory access is atomic. The instruction also has memory ordering semantics as described in Load-Acquire, Store-Release. For information about memory accesses, see Load/Store addressing modes."
  },
  {
    "name": "STLXRB",
    "doc": "Store-Release Exclusive Register Byte stores a byte from a 32-bit register to memory if the PE has exclusive access to the memory address, and returns a status value of 0 if the store was successful, or of 1 if no store was performed. See Synchronization and semaphores. The memory access is atomic. The instruction also has memory ordering semantics as described in Load-Acquire, Store-Release. For information about memory accesses, see Load/Store addressing modes."
  },
  {
    "name": "STLXRH",
    "doc": "Store-Release Exclusive Register Halfword stores a halfword from a 32-bit register to memory if the PE has exclusive access to the memory address, and returns a status value of 0 if the store was successful, or of 1 if no store was performed. See Synchronization and semaphores. The memory access is atomic. The instruction also has memory ordering semantics as described in Load-Acquire, Store-Release. For information about memory accesses, see Load/Store addressing modes."
  },
  {
    "name": "STNP",
    "doc": "Store Pair of SIMD&amp;FP registers, with Non-temporal hint. This instruction stores a pair of SIMD&amp;FP registers to memory, issuing a hint to the memory system that the access is non-temporal. The address used for the store is calculated from an address from a base register value and an immediate offset. For information about non-temporal pair instructions, see Load/Store SIMD and Floating-point Non-temporal pair."
  },
  {
    "name": "STNT1B",
    "doc": "Contiguous store non-temporal of bytes from multiple strided vectors (immediate index)"
  },
  {
    "name": "STNT1D",
    "doc": "Contiguous store non-temporal of doublewords from multiple strided vectors (immediate index)"
  },
  {
    "name": "STNT1H",
    "doc": "Contiguous store non-temporal of halfwords from multiple strided vectors (immediate index)"
  },
  {
    "name": "STNT1W",
    "doc": "Contiguous store non-temporal of words from multiple strided vectors (immediate index)"
  },
  {
    "name": "STP",
    "doc": "Store Pair of SIMD&amp;FP registers. This instruction stores a pair of SIMD&amp;FP registers to memory. The address used for the store is calculated from a base register value and an immediate offset."
  },
  {
    "name": "STRB",
    "doc": "Store Register Byte (immediate) stores the least significant byte of a 32-bit register to memory. The address that is used for the store is calculated from a base register and an immediate offset. For information about memory accesses, see Load/Store addressing modes."
  },
  {
    "name": "STRH",
    "doc": "Store Register Halfword (immediate) stores the least significant halfword of a 32-bit register to memory. The address that is used for the store is calculated from a base register and an immediate offset. For information about memory accesses, see Load/Store addressing modes."
  },
  {
    "name": "STR",
    "doc": "Store SIMD&amp;FP register (immediate offset). This instruction stores a single SIMD&amp;FP register to memory. The address that is used for the store is calculated from a base register value and an immediate offset."
  },
  {
    "name": "STSETB",
    "doc": "Atomic bit set on byte in memory, without return, atomically loads an 8-bit byte from memory, performs a bitwise OR with the value held in a register on it, and stores the result back to memory."
  },
  {
    "name": "STSETLB",
    "doc": "Atomic bit set on byte in memory, without return, atomically loads an 8-bit byte from memory, performs a bitwise OR with the value held in a register on it, and stores the result back to memory."
  },
  {
    "name": "STSETH",
    "doc": "Atomic bit set on halfword in memory, without return, atomically loads a 16-bit halfword from memory, performs a bitwise OR with the value held in a register on it, and stores the result back to memory."
  },
  {
    "name": "STSETLH",
    "doc": "Atomic bit set on halfword in memory, without return, atomically loads a 16-bit halfword from memory, performs a bitwise OR with the value held in a register on it, and stores the result back to memory."
  },
  {
    "name": "STSET",
    "doc": "Atomic bit set on word or doubleword in memory, without return, atomically loads a 32-bit word or 64-bit doubleword from memory, performs a bitwise OR with the value held in a register on it, and stores the result back to memory."
  },
  {
    "name": "STSETL",
    "doc": "Atomic bit set on word or doubleword in memory, without return, atomically loads a 32-bit word or 64-bit doubleword from memory, performs a bitwise OR with the value held in a register on it, and stores the result back to memory."
  },
  {
    "name": "STSMAXB",
    "doc": "Atomic signed maximum on byte in memory, without return, atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as signed numbers."
  },
  {
    "name": "STSMAXLB",
    "doc": "Atomic signed maximum on byte in memory, without return, atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as signed numbers."
  },
  {
    "name": "STSMAXH",
    "doc": "Atomic signed maximum on halfword in memory, without return, atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as signed numbers."
  },
  {
    "name": "STSMAXLH",
    "doc": "Atomic signed maximum on halfword in memory, without return, atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as signed numbers."
  },
  {
    "name": "STSMAX",
    "doc": "Atomic signed maximum on word or doubleword in memory, without return, atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as signed numbers."
  },
  {
    "name": "STSMAXL",
    "doc": "Atomic signed maximum on word or doubleword in memory, without return, atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as signed numbers."
  },
  {
    "name": "STSMINB",
    "doc": "Atomic signed minimum on byte in memory, without return, atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as signed numbers."
  },
  {
    "name": "STSMINLB",
    "doc": "Atomic signed minimum on byte in memory, without return, atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as signed numbers."
  },
  {
    "name": "STSMINH",
    "doc": "Atomic signed minimum on halfword in memory, without return, atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as signed numbers."
  },
  {
    "name": "STSMINLH",
    "doc": "Atomic signed minimum on halfword in memory, without return, atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as signed numbers."
  },
  {
    "name": "STSMIN",
    "doc": "Atomic signed minimum on word or doubleword in memory, without return, atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as signed numbers."
  },
  {
    "name": "STSMINL",
    "doc": "Atomic signed minimum on word or doubleword in memory, without return, atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as signed numbers."
  },
  {
    "name": "STTR",
    "doc": "Store Register (unprivileged) stores a word or doubleword from a register to memory. The address that is used for the store is calculated from a base register and an immediate offset."
  },
  {
    "name": "STTRB",
    "doc": "Store Register Byte (unprivileged) stores a byte from a 32-bit register to memory. The address that is used for the store is calculated from a base register and an immediate offset."
  },
  {
    "name": "STTRH",
    "doc": "Store Register Halfword (unprivileged) stores a halfword from a 32-bit register to memory. The address that is used for the store is calculated from a base register and an immediate offset."
  },
  {
    "name": "STUMAXB",
    "doc": "Atomic unsigned maximum on byte in memory, without return, atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as unsigned numbers."
  },
  {
    "name": "STUMAXLB",
    "doc": "Atomic unsigned maximum on byte in memory, without return, atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as unsigned numbers."
  },
  {
    "name": "STUMAXH",
    "doc": "Atomic unsigned maximum on halfword in memory, without return, atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as unsigned numbers."
  },
  {
    "name": "STUMAXLH",
    "doc": "Atomic unsigned maximum on halfword in memory, without return, atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as unsigned numbers."
  },
  {
    "name": "STUMAX",
    "doc": "Atomic unsigned maximum on word or doubleword in memory, without return, atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as unsigned numbers."
  },
  {
    "name": "STUMAXL",
    "doc": "Atomic unsigned maximum on word or doubleword in memory, without return, atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the larger value back to memory, treating the values as unsigned numbers."
  },
  {
    "name": "STUMINB",
    "doc": "Atomic unsigned minimum on byte in memory, without return, atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as unsigned numbers."
  },
  {
    "name": "STUMINLB",
    "doc": "Atomic unsigned minimum on byte in memory, without return, atomically loads an 8-bit byte from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as unsigned numbers."
  },
  {
    "name": "STUMINH",
    "doc": "Atomic unsigned minimum on halfword in memory, without return, atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as unsigned numbers."
  },
  {
    "name": "STUMINLH",
    "doc": "Atomic unsigned minimum on halfword in memory, without return, atomically loads a 16-bit halfword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as unsigned numbers."
  },
  {
    "name": "STUMIN",
    "doc": "Atomic unsigned minimum on word or doubleword in memory, without return, atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as unsigned numbers."
  },
  {
    "name": "STUMINL",
    "doc": "Atomic unsigned minimum on word or doubleword in memory, without return, atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as unsigned numbers."
  },
  {
    "name": "STURB",
    "doc": "Store Register Byte (unscaled) calculates an address from a base register value and an immediate offset, and stores a byte to the calculated address, from a 32-bit register. For information about memory accesses, see Load/Store addressing modes."
  },
  {
    "name": "STURH",
    "doc": "Store Register Halfword (unscaled) calculates an address from a base register value and an immediate offset, and stores a halfword to the calculated address, from a 32-bit register. For information about memory accesses, see Load/Store addressing modes."
  },
  {
    "name": "STUR",
    "doc": "Store SIMD&amp;FP register (unscaled offset). This instruction stores a single SIMD&amp;FP register to memory. The address that is used for the store is calculated from a base register value and an optional immediate offset."
  },
  {
    "name": "STXP",
    "doc": "Store Exclusive Pair of registers stores two 32-bit words or two 64-bit doublewords from two registers to a memory location if the PE has exclusive access to the memory address, and returns a status value of 0 if the store was successful, or of 1 if no store was performed. See Synchronization and semaphores. For information on single-copy atomicity and alignment requirements, see Requirements for single-copy atomicity and Alignment of data accesses. If a 64-bit pair Store-Exclusive succeeds, it causes a single-copy atomic update of the 128-bit memory location being updated. For information about memory accesses, see Load/Store addressing modes."
  },
  {
    "name": "STXR",
    "doc": "Store Exclusive Register stores a 32-bit word or a 64-bit doubleword from a register to memory if the PE has exclusive access to the memory address, and returns a status value of 0 if the store was successful, or of 1 if no store was performed. See Synchronization and semaphores. For information about memory accesses, see Load/Store addressing modes."
  },
  {
    "name": "STXRB",
    "doc": "Store Exclusive Register Byte stores a byte from a register to memory if the PE has exclusive access to the memory address, and returns a status value of 0 if the store was successful, or of 1 if no store was performed. See Synchronization and semaphores. The memory access is atomic."
  },
  {
    "name": "STXRH",
    "doc": "Store Exclusive Register Halfword stores a halfword from a register to memory if the PE has exclusive access to the memory address, and returns a status value of 0 if the store was successful, or of 1 if no store was performed. See Synchronization and semaphores. The memory access is atomic."
  },
  {
    "name": "STZ2G",
    "doc": "Store Allocation Tags, Zeroing stores an Allocation Tag to two Tag granules of memory, zeroing the associated data locations. The address used for the store is calculated from the base register and an immediate signed offset scaled by the Tag granule. The Allocation Tag is calculated from the Logical Address Tag in the source register."
  },
  {
    "name": "STZG",
    "doc": "Store Allocation Tag, Zeroing stores an Allocation Tag to memory, zeroing the associated data location. The address used for the store is calculated from the base register and an immediate signed offset scaled by the Tag granule. The Allocation Tag is calculated from the Logical Address Tag in the source register."
  },
  {
    "name": "STZGM",
    "doc": "Store Tag and Zero Multiple writes a naturally aligned block of N Allocation Tags and stores zero to the associated data locations, where the size of N is identified in DCZID_EL0.BS, and the Allocation Tag is taken from the source register bits&lt;3:0&gt;."
  },
  {
    "name": "SUBG",
    "doc": "Subtract with Tag subtracts an immediate value scaled by the Tag granule from the address in the source register, modifies the Logical Address Tag of the address using an immediate value, and writes the result to the destination register. Tags specified in GCR_EL1.Exclude are excluded from the possible outputs when modifying the Logical Address Tag."
  },
  {
    "name": "SUBHNB",
    "doc": "Subtract narrow high part (bottom)"
  },
  {
    "name": "SUBHNT",
    "doc": "Subtract narrow high part (top)"
  },
  {
    "name": "SUBHN",
    "doc": "Subtract returning High Narrow. This instruction subtracts each vector element in the second source SIMD&amp;FP register from the corresponding vector element in the first source SIMD&amp;FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&amp;FP register. All the values in this instruction are signed integer values."
  },
  {
    "name": "SUBHN2",
    "doc": "Subtract returning High Narrow. This instruction subtracts each vector element in the second source SIMD&amp;FP register from the corresponding vector element in the first source SIMD&amp;FP register, places the most significant half of the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&amp;FP register. All the values in this instruction are signed integer values."
  },
  {
    "name": "SUBP",
    "doc": "Subtract Pointer subtracts the 56-bit address held in the second source register from the 56-bit address held in the first source register, sign-extends the result to 64-bits, and writes the result to the destination register."
  },
  {
    "name": "SUBPS",
    "doc": "Subtract Pointer, setting Flags subtracts the 56-bit address held in the second source register from the 56-bit address held in the first source register, sign-extends the result to 64-bits, and writes the result to the destination register. It updates the condition flags based on the result of the subtraction."
  },
  {
    "name": "SUBR",
    "doc": "Reversed subtract vectors (predicated)"
  },
  {
    "name": "SUBS",
    "doc": "Subtract (extended register), setting flags, subtracts a sign or zero-extended register value, followed by an optional left shift amount, from a register value, and writes the result to the destination register. The argument that is extended from the &lt;Rm&gt; register can be a byte, halfword, word, or doubleword. It updates the condition flags based on the result."
  },
  {
    "name": "SUB",
    "doc": "Subtract (extended register) subtracts a sign or zero-extended register value, followed by an optional left shift amount, from a register value, and writes the result to the destination register. The argument that is extended from the &lt;Rm&gt; register can be a byte, halfword, word, or doubleword."
  },
  {
    "name": "SUDOT",
    "doc": "Dot product index form with signed and unsigned integers. This instruction performs the dot product of the four signed 8-bit integer values in each 32-bit element of the first source register with the four unsigned 8-bit integer values in an indexed 32-bit element of the second source register, accumulating the result into the corresponding 32-bit element of the destination vector."
  },
  {
    "name": "SUMLALL",
    "doc": "Multi-vector signed by unsigned integer multiply-add long-long by indexed element"
  },
  {
    "name": "SUMOPA",
    "doc": "Signed by unsigned integer sum of outer products and accumulate"
  },
  {
    "name": "SUMOPS",
    "doc": "Signed by unsigned integer sum of outer products and subtract"
  },
  {
    "name": "SUNPKHI",
    "doc": "Signed unpack and extend half of vector"
  },
  {
    "name": "SUNPKLO",
    "doc": "Signed unpack and extend half of vector"
  },
  {
    "name": "SUNPK",
    "doc": "Unpack and sign-extend multi-vector elements"
  },
  {
    "name": "SUQADD",
    "doc": "Signed saturating Accumulate of Unsigned value. This instruction adds the unsigned integer values of the vector elements in the source SIMD&amp;FP register to corresponding signed integer values of the vector elements in the destination SIMD&amp;FP register, and writes the resulting signed integer values to the destination SIMD&amp;FP register."
  },
  {
    "name": "SUVDOT",
    "doc": "Multi-vector signed by unsigned integer vertical dot-product by indexed element"
  },
  {
    "name": "SVC",
    "doc": "Supervisor Call causes an exception to be taken to EL1."
  },
  {
    "name": "SVDOT",
    "doc": "Multi-vector signed integer vertical dot-product by indexed element"
  },
  {
    "name": "SWP",
    "doc": "Swap word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from a memory location, and stores the value held in a register back to the same memory location. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "SWPA",
    "doc": "Swap word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from a memory location, and stores the value held in a register back to the same memory location. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "SWPAL",
    "doc": "Swap word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from a memory location, and stores the value held in a register back to the same memory location. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "SWPL",
    "doc": "Swap word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from a memory location, and stores the value held in a register back to the same memory location. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "SWPB",
    "doc": "Swap byte in memory atomically loads an 8-bit byte from a memory location, and stores the value held in a register back to the same memory location. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "SWPAB",
    "doc": "Swap byte in memory atomically loads an 8-bit byte from a memory location, and stores the value held in a register back to the same memory location. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "SWPALB",
    "doc": "Swap byte in memory atomically loads an 8-bit byte from a memory location, and stores the value held in a register back to the same memory location. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "SWPLB",
    "doc": "Swap byte in memory atomically loads an 8-bit byte from a memory location, and stores the value held in a register back to the same memory location. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "SWPH",
    "doc": "Swap halfword in memory atomically loads a 16-bit halfword from a memory location, and stores the value held in a register back to the same memory location. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "SWPAH",
    "doc": "Swap halfword in memory atomically loads a 16-bit halfword from a memory location, and stores the value held in a register back to the same memory location. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "SWPALH",
    "doc": "Swap halfword in memory atomically loads a 16-bit halfword from a memory location, and stores the value held in a register back to the same memory location. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "SWPLH",
    "doc": "Swap halfword in memory atomically loads a 16-bit halfword from a memory location, and stores the value held in a register back to the same memory location. The value initially loaded from memory is returned in the destination register."
  },
  {
    "name": "SWPP",
    "doc": "Swap quadword in memory atomically loads a 128-bit quadword from a memory location, and stores the value held in a pair of registers back to the same memory location. The value initially loaded from memory is returned in the same pair of registers."
  },
  {
    "name": "SWPPA",
    "doc": "Swap quadword in memory atomically loads a 128-bit quadword from a memory location, and stores the value held in a pair of registers back to the same memory location. The value initially loaded from memory is returned in the same pair of registers."
  },
  {
    "name": "SWPPAL",
    "doc": "Swap quadword in memory atomically loads a 128-bit quadword from a memory location, and stores the value held in a pair of registers back to the same memory location. The value initially loaded from memory is returned in the same pair of registers."
  },
  {
    "name": "SWPPL",
    "doc": "Swap quadword in memory atomically loads a 128-bit quadword from a memory location, and stores the value held in a pair of registers back to the same memory location. The value initially loaded from memory is returned in the same pair of registers."
  },
  {
    "name": "SXTB",
    "doc": "Signed Extend Byte extracts an 8-bit value from a register, sign-extends it to the size of the register, and writes the result to the destination register."
  },
  {
    "name": "SXTH",
    "doc": "Signed byte / halfword / word extend (predicated)"
  },
  {
    "name": "SXTW",
    "doc": "Signed byte / halfword / word extend (predicated)"
  },
  {
    "name": "SXTL",
    "doc": "Signed extend Long. This instruction duplicates each vector element in the lower or upper half of the source SIMD&amp;FP register into a vector, and writes the vector to the destination SIMD&amp;FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are signed integer values."
  },
  {
    "name": "SXTL2",
    "doc": "Signed extend Long. This instruction duplicates each vector element in the lower or upper half of the source SIMD&amp;FP register into a vector, and writes the vector to the destination SIMD&amp;FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are signed integer values."
  },
  {
    "name": "SYS",
    "doc": "System instruction. For more information, see Op0 equals 0b01, cache maintenance, TLB maintenance, and address translation instructions for the encodings of System instructions."
  },
  {
    "name": "SYSL",
    "doc": "System instruction with result. For more information, see Op0 equals 0b01, cache maintenance, TLB maintenance, and address translation instructions for the encodings of System instructions."
  },
  {
    "name": "SYSP",
    "doc": "128-bit System instruction."
  },
  {
    "name": "TBLQ",
    "doc": "Programmable table lookup within each quadword vector segment (zeroing)"
  },
  {
    "name": "TBL",
    "doc": "Table vector Lookup. This instruction reads each value from the vector elements in the index source SIMD&amp;FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&amp;FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&amp;FP register. If an index is out of range for the table, the result for that lookup is 0. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table."
  },
  {
    "name": "TBNZ",
    "doc": "Test bit and Branch if Nonzero compares the value of a bit in a general-purpose register with zero, and conditionally branches to a label at a PC-relative offset if the comparison is not equal. It provides a hint that this is not a subroutine call or return. This instruction does not affect condition flags."
  },
  {
    "name": "TBXQ",
    "doc": "Programmable table lookup within each quadword vector segment (merging)"
  },
  {
    "name": "TBX",
    "doc": "Table vector lookup extension. This instruction reads each value from the vector elements in the index source SIMD&amp;FP register, uses each result as an index to perform a lookup in a table of bytes that is described by one to four source table SIMD&amp;FP registers, places the lookup result in a vector, and writes the vector to the destination SIMD&amp;FP register. If an index is out of range for the table, the existing value in the vector element of the destination register is left unchanged. If more than one source register is used to describe the table, the first source register describes the lowest bytes of the table."
  },
  {
    "name": "TBZ",
    "doc": "Test bit and Branch if Zero compares the value of a test bit with zero, and conditionally branches to a label at a PC-relative offset if the comparison is equal. It provides a hint that this is not a subroutine call or return. This instruction does not affect condition flags."
  },
  {
    "name": "TCANCEL",
    "doc": "This instruction exits Transactional state and discards all state modifications that were performed transactionally. Execution continues at the instruction that follows the TSTART instruction of the outer transaction. The destination register of the TSTART instruction of the outer transaction is written with the immediate operand of TCANCEL."
  },
  {
    "name": "TCOMMIT",
    "doc": "This instruction commits the current transaction. If the current transaction is an outer transaction, then Transactional state is exited, and all state modifications performed transactionally are committed to the architectural state. TCOMMIT takes no inputs and returns no value."
  },
  {
    "name": "TLBIP",
    "doc": "TLB Invalidate Pair operation."
  },
  {
    "name": "TLBI",
    "doc": "TLB Invalidate operation. For more information, see op0==0b01, cache maintenance, TLB maintenance, and address translation instructions."
  },
  {
    "name": "TRCIT",
    "doc": "Trace Instrumentation generates an instrumentation trace packet that contains the value of the provided register."
  },
  {
    "name": "TRN1",
    "doc": "Transpose vectors (primary). This instruction reads corresponding even-numbered vector elements from the two source SIMD&amp;FP registers, starting at zero, places each result into consecutive elements of a vector, and writes the vector to the destination SIMD&amp;FP register. Vector elements from the first source register are placed into even-numbered elements of the destination vector, starting at zero, while vector elements from the second source register are placed into odd-numbered elements of the destination vector."
  },
  {
    "name": "TRN2",
    "doc": "Interleave even or odd elements from two predicates"
  },
  {
    "name": "TSB",
    "doc": "Trace Synchronization Barrier. This instruction is a barrier that synchronizes the trace operations of instructions, see Trace Synchronization Buffer (TSB CSYNC)."
  },
  {
    "name": "TSTART",
    "doc": "This instruction starts a new transaction. If the transaction started successfully, the destination register is set to zero. If the transaction failed or was canceled, then all state modifications that were performed transactionally are discarded and the destination register is written with a nonzero value that encodes the cause of the failure."
  },
  {
    "name": "TST",
    "doc": "Test bits (immediate), setting the condition flags and discarding the result"
  },
  {
    "name": "TTEST",
    "doc": "This instruction writes the depth of the transaction to the destination register, or the value 0 otherwise."
  },
  {
    "name": "UABALB",
    "doc": "Unsigned absolute difference and accumulate long (bottom)"
  },
  {
    "name": "UABALT",
    "doc": "Unsigned absolute difference and accumulate long (top)"
  },
  {
    "name": "UABAL",
    "doc": "Unsigned Absolute difference and Accumulate Long. This instruction subtracts the vector elements in the lower or upper half of the second source SIMD&amp;FP register from the corresponding vector elements of the first source SIMD&amp;FP register, and accumulates the absolute values of the results into the vector elements of the destination SIMD&amp;FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are unsigned integer values."
  },
  {
    "name": "UABAL2",
    "doc": "Unsigned Absolute difference and Accumulate Long. This instruction subtracts the vector elements in the lower or upper half of the second source SIMD&amp;FP register from the corresponding vector elements of the first source SIMD&amp;FP register, and accumulates the absolute values of the results into the vector elements of the destination SIMD&amp;FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are unsigned integer values."
  },
  {
    "name": "UABA",
    "doc": "Unsigned Absolute difference and Accumulate. This instruction subtracts the elements of the vector of the second source SIMD&amp;FP register from the corresponding elements of the first source SIMD&amp;FP register, and accumulates the absolute values of the results into the elements of the vector of the destination SIMD&amp;FP register."
  },
  {
    "name": "UABDLB",
    "doc": "Unsigned absolute difference long (bottom)"
  },
  {
    "name": "UABDLT",
    "doc": "Unsigned absolute difference long (top)"
  },
  {
    "name": "UABDL",
    "doc": "Unsigned Absolute Difference Long. This instruction subtracts the vector elements in the lower or upper half of the second source SIMD&amp;FP register from the corresponding vector elements of the first source SIMD&amp;FP register, places the absolute value of the result into a vector, and writes the vector to the destination SIMD&amp;FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are unsigned integer values."
  },
  {
    "name": "UABDL2",
    "doc": "Unsigned Absolute Difference Long. This instruction subtracts the vector elements in the lower or upper half of the second source SIMD&amp;FP register from the corresponding vector elements of the first source SIMD&amp;FP register, places the absolute value of the result into a vector, and writes the vector to the destination SIMD&amp;FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are unsigned integer values."
  },
  {
    "name": "UABD",
    "doc": "Unsigned Absolute Difference (vector). This instruction subtracts the elements of the vector of the second source SIMD&amp;FP register from the corresponding elements of the first source SIMD&amp;FP register, places the absolute values of the results into a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "UADALP",
    "doc": "Unsigned Add and Accumulate Long Pairwise. This instruction adds pairs of adjacent unsigned integer values from the vector in the source SIMD&amp;FP register and accumulates the results with the vector elements of the destination SIMD&amp;FP register. The destination vector elements are twice as long as the source vector elements."
  },
  {
    "name": "UADDLB",
    "doc": "Unsigned add long (bottom)"
  },
  {
    "name": "UADDLP",
    "doc": "Unsigned Add Long Pairwise. This instruction adds pairs of adjacent unsigned integer values from the vector in the source SIMD&amp;FP register, places the result into a vector, and writes the vector to the destination SIMD&amp;FP register. The destination vector elements are twice as long as the source vector elements."
  },
  {
    "name": "UADDLT",
    "doc": "Unsigned add long (top)"
  },
  {
    "name": "UADDLV",
    "doc": "Unsigned sum Long across Vector. This instruction adds every vector element in the source SIMD&amp;FP register together, and writes the scalar result to the destination SIMD&amp;FP register. The destination scalar is twice as long as the source vector elements. All the values in this instruction are unsigned integer values."
  },
  {
    "name": "UADDL",
    "doc": "Unsigned Add Long (vector). This instruction adds each vector element in the lower or upper half of the first source SIMD&amp;FP register to the corresponding vector element of the second source SIMD&amp;FP register, places the result into a vector, and writes the vector to the destination SIMD&amp;FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are unsigned integer values."
  },
  {
    "name": "UADDL2",
    "doc": "Unsigned Add Long (vector). This instruction adds each vector element in the lower or upper half of the first source SIMD&amp;FP register to the corresponding vector element of the second source SIMD&amp;FP register, places the result into a vector, and writes the vector to the destination SIMD&amp;FP register. The destination vector elements are twice as long as the source vector elements. All the values in this instruction are unsigned integer values."
  },
  {
    "name": "UADDV",
    "doc": "Unsigned add reduction to scalar"
  },
  {
    "name": "UADDWB",
    "doc": "Unsigned add wide (bottom)"
  },
  {
    "name": "UADDWT",
    "doc": "Unsigned add wide (top)"
  },
  {
    "name": "UADDW",
    "doc": "Unsigned Add Wide. This instruction adds the vector elements of the first source SIMD&amp;FP register to the corresponding vector elements in the lower or upper half of the second source SIMD&amp;FP register, places the result in a vector, and writes the vector to the SIMD&amp;FP destination register. The vector elements of the destination register and the first source register are twice as long as the vector elements of the second source register. All the values in this instruction are unsigned integer values."
  },
  {
    "name": "UADDW2",
    "doc": "Unsigned Add Wide. This instruction adds the vector elements of the first source SIMD&amp;FP register to the corresponding vector elements in the lower or upper half of the second source SIMD&amp;FP register, places the result in a vector, and writes the vector to the SIMD&amp;FP destination register. The vector elements of the destination register and the first source register are twice as long as the vector elements of the second source register. All the values in this instruction are unsigned integer values."
  },
  {
    "name": "UBFIZ",
    "doc": "Unsigned Bitfield Insert in Zeros copies a bitfield of &lt;width&gt; bits from the least significant bits of the source register to bit position &lt;lsb&gt; of the destination register, setting the destination bits above and below the bitfield to zero."
  },
  {
    "name": "UBFM",
    "doc": "Unsigned Bitfield Move is usually accessed via one of its aliases, which are always preferred for disassembly."
  },
  {
    "name": "UBFX",
    "doc": "Unsigned Bitfield Extract copies a bitfield of &lt;width&gt; bits starting from bit position &lt;lsb&gt; in the source register to the least significant bits of the destination register, and sets destination bits above the bitfield to zero."
  },
  {
    "name": "UCLAMP",
    "doc": "Multi-vector unsigned clamp to minimum/maximum vector"
  },
  {
    "name": "UCVTF",
    "doc": "Unsigned fixed-point Convert to Floating-point (vector). This instruction converts each element in a vector from fixed-point to floating-point using the rounding mode that is specified by the FPCR, and writes the result to the SIMD&amp;FP destination register."
  },
  {
    "name": "UDF",
    "doc": "Permanently Undefined generates an Undefined Instruction exception (ESR_ELx.EC = 0b000000). The encodings for UDF used in this section are defined as permanently undefined."
  },
  {
    "name": "UDIV",
    "doc": "Unsigned Divide divides an unsigned integer register value by another unsigned integer register value, and writes the result to the destination register. The condition flags are not affected."
  },
  {
    "name": "UDIVR",
    "doc": "Unsigned reversed divide (predicated)"
  },
  {
    "name": "UDOT",
    "doc": "Dot Product unsigned arithmetic (vector, by element). This instruction performs the dot product of the four 8-bit elements in each 32-bit element of the first source register with the four 8-bit elements of an indexed 32-bit element in the second source register, accumulating the result into the corresponding 32-bit element of the destination register."
  },
  {
    "name": "UHADD",
    "doc": "Unsigned Halving Add. This instruction adds corresponding unsigned integer values from the two source SIMD&amp;FP registers, shifts each result right one bit, places the results into a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "UHSUBR",
    "doc": "Unsigned halving subtract reversed vectors"
  },
  {
    "name": "UHSUB",
    "doc": "Unsigned Halving Subtract. This instruction subtracts the vector elements in the second source SIMD&amp;FP register from the corresponding vector elements in the first source SIMD&amp;FP register, shifts each result right one bit, places each result into a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "UMADDL",
    "doc": "Unsigned Multiply-Add Long multiplies two 32-bit register values, adds a 64-bit register value, and writes the result to the 64-bit destination register."
  },
  {
    "name": "UMAXP",
    "doc": "Unsigned Maximum Pairwise. This instruction creates a vector by concatenating the vector elements of the first source SIMD&amp;FP register after the vector elements of the second source SIMD&amp;FP register, reads each pair of adjacent vector elements in the two source SIMD&amp;FP registers, writes the largest of each pair of unsigned integer values into a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "UMAXQV",
    "doc": "Unsigned maximum reduction of quadword vector segments"
  },
  {
    "name": "UMAXV",
    "doc": "Unsigned Maximum across Vector. This instruction compares all the vector elements in the source SIMD&amp;FP register, and writes the largest of the values as a scalar to the destination SIMD&amp;FP register. All the values in this instruction are unsigned integer values."
  },
  {
    "name": "UMAX",
    "doc": "Unsigned Maximum (vector). This instruction compares corresponding elements in the vectors in the two source SIMD&amp;FP registers, places the larger of each pair of unsigned integer values into a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "UMINP",
    "doc": "Unsigned Minimum Pairwise. This instruction creates a vector by concatenating the vector elements of the first source SIMD&amp;FP register after the vector elements of the second source SIMD&amp;FP register, reads each pair of adjacent vector elements in the two source SIMD&amp;FP registers, writes the smallest of each pair of unsigned integer values into a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "UMINQV",
    "doc": "Unsigned minimum reduction of quadword vector segments"
  },
  {
    "name": "UMINV",
    "doc": "Unsigned Minimum across Vector. This instruction compares all the vector elements in the source SIMD&amp;FP register, and writes the smallest of the values as a scalar to the destination SIMD&amp;FP register. All the values in this instruction are unsigned integer values."
  },
  {
    "name": "UMIN",
    "doc": "Unsigned Minimum (vector). This instruction compares corresponding vector elements in the two source SIMD&amp;FP registers, places the smaller of each of the two unsigned integer values into a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "UMLALB",
    "doc": "Unsigned multiply-add long to accumulator (bottom)"
  },
  {
    "name": "UMLALL",
    "doc": "Multi-vector unsigned integer multiply-add long-long by indexed element"
  },
  {
    "name": "UMLALT",
    "doc": "Unsigned multiply-add long to accumulator (top)"
  },
  {
    "name": "UMLAL",
    "doc": "Unsigned Multiply-Add Long (vector, by element). This instruction multiplies each vector element in the lower or upper half of the first source SIMD&amp;FP register by the specified vector element of the second source SIMD&amp;FP register and accumulates the results with the vector elements of the destination SIMD&amp;FP register. The destination vector elements are twice as long as the elements that are multiplied."
  },
  {
    "name": "UMLAL2",
    "doc": "Unsigned Multiply-Add Long (vector, by element). This instruction multiplies each vector element in the lower or upper half of the first source SIMD&amp;FP register by the specified vector element of the second source SIMD&amp;FP register and accumulates the results with the vector elements of the destination SIMD&amp;FP register. The destination vector elements are twice as long as the elements that are multiplied."
  },
  {
    "name": "UMLSLB",
    "doc": "Unsigned multiply-subtract long from accumulator (bottom)"
  },
  {
    "name": "UMLSLL",
    "doc": "Multi-vector unsigned integer multiply-subtract long-long by indexed element"
  },
  {
    "name": "UMLSLT",
    "doc": "Unsigned multiply-subtract long from accumulator (top)"
  },
  {
    "name": "UMLSL",
    "doc": "Unsigned Multiply-Subtract Long (vector, by element). This instruction multiplies each vector element in the lower or upper half of the first source SIMD&amp;FP register by the specified vector element of the second source SIMD&amp;FP register and subtracts the results from the vector elements of the destination SIMD&amp;FP register. The destination vector elements are twice as long as the elements that are multiplied."
  },
  {
    "name": "UMLSL2",
    "doc": "Unsigned Multiply-Subtract Long (vector, by element). This instruction multiplies each vector element in the lower or upper half of the first source SIMD&amp;FP register by the specified vector element of the second source SIMD&amp;FP register and subtracts the results from the vector elements of the destination SIMD&amp;FP register. The destination vector elements are twice as long as the elements that are multiplied."
  },
  {
    "name": "UMMLA",
    "doc": "Unsigned 8-bit integer matrix multiply-accumulate. This instruction multiplies the 2x8 matrix of unsigned 8-bit integer values in the first source vector by the 8x2 matrix of unsigned 8-bit integer values in the second source vector. The resulting 2x2 32-bit integer matrix product is destructively added to the 32-bit integer matrix accumulator in the destination vector. This is equivalent to performing an 8-way dot product per destination element."
  },
  {
    "name": "UMNEGL",
    "doc": "Unsigned Multiply-Negate Long multiplies two 32-bit register values, negates the product, and writes the result to the 64-bit destination register."
  },
  {
    "name": "UMOPA",
    "doc": "Unsigned integer sum of outer products and accumulate"
  },
  {
    "name": "UMOPS",
    "doc": "Unsigned integer sum of outer products and subtract"
  },
  {
    "name": "UMOV",
    "doc": "Unsigned Move vector element to general-purpose register. This instruction reads the unsigned integer from the source SIMD&amp;FP register, zero-extends it to form a 32-bit or 64-bit value, and writes the result to the destination general-purpose register."
  },
  {
    "name": "UMSUBL",
    "doc": "Unsigned Multiply-Subtract Long multiplies two 32-bit register values, subtracts the product from a 64-bit register value, and writes the result to the 64-bit destination register."
  },
  {
    "name": "UMULH",
    "doc": "Unsigned Multiply High multiplies two 64-bit register values, and writes bits[127:64] of the 128-bit result to the 64-bit destination register."
  },
  {
    "name": "UMULLB",
    "doc": "Unsigned multiply long (bottom)"
  },
  {
    "name": "UMULLT",
    "doc": "Unsigned multiply long (top)"
  },
  {
    "name": "UMULL",
    "doc": "Unsigned Multiply Long (vector, by element). This instruction multiplies each vector element in the lower or upper half of the first source SIMD&amp;FP register by the specified vector element of the second source SIMD&amp;FP register, places the results in a vector, and writes the vector to the destination SIMD&amp;FP register. The destination vector elements are twice as long as the elements that are multiplied."
  },
  {
    "name": "UMULL2",
    "doc": "Unsigned Multiply Long (vector, by element). This instruction multiplies each vector element in the lower or upper half of the first source SIMD&amp;FP register by the specified vector element of the second source SIMD&amp;FP register, places the results in a vector, and writes the vector to the destination SIMD&amp;FP register. The destination vector elements are twice as long as the elements that are multiplied."
  },
  {
    "name": "UQADD",
    "doc": "Unsigned saturating Add. This instruction adds the values of corresponding elements of the two source SIMD&amp;FP registers, places the results into a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "UQCVTN",
    "doc": "Unsigned saturating extract narrow and interleave"
  },
  {
    "name": "UQCVT",
    "doc": "Multi-vector unsigned saturating extract narrow"
  },
  {
    "name": "UQDECB",
    "doc": "Unsigned saturating decrement scalar by multiple of 8-bit predicate constraint element count"
  },
  {
    "name": "UQDECD",
    "doc": "Unsigned saturating decrement scalar by multiple of 64-bit predicate constraint element count"
  },
  {
    "name": "UQDECH",
    "doc": "Unsigned saturating decrement scalar by multiple of 16-bit predicate constraint element count"
  },
  {
    "name": "UQDECP",
    "doc": "Unsigned saturating decrement scalar by count of true predicate elements"
  },
  {
    "name": "UQDECW",
    "doc": "Unsigned saturating decrement scalar by multiple of 32-bit predicate constraint element count"
  },
  {
    "name": "UQINCB",
    "doc": "Unsigned saturating increment scalar by multiple of 8-bit predicate constraint element count"
  },
  {
    "name": "UQINCD",
    "doc": "Unsigned saturating increment scalar by multiple of 64-bit predicate constraint element count"
  },
  {
    "name": "UQINCH",
    "doc": "Unsigned saturating increment scalar by multiple of 16-bit predicate constraint element count"
  },
  {
    "name": "UQINCP",
    "doc": "Unsigned saturating increment scalar by count of true predicate elements"
  },
  {
    "name": "UQINCW",
    "doc": "Unsigned saturating increment scalar by multiple of 32-bit predicate constraint element count"
  },
  {
    "name": "UQRSHLR",
    "doc": "Unsigned saturating rounding shift left reversed vectors (predicated)"
  },
  {
    "name": "UQRSHL",
    "doc": "Unsigned saturating Rounding Shift Left (register). This instruction takes each vector element of the first source SIMD&amp;FP register, shifts the vector element by a value from the least significant byte of the corresponding vector element of the second source SIMD&amp;FP register, places the results into a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "UQRSHRNB",
    "doc": "Unsigned saturating rounding shift right narrow by immediate (bottom)"
  },
  {
    "name": "UQRSHRNT",
    "doc": "Unsigned saturating rounding shift right narrow by immediate (top)"
  },
  {
    "name": "UQRSHRN",
    "doc": "Unsigned saturating Rounded Shift Right Narrow (immediate). This instruction reads each vector element in the source SIMD&amp;FP register, right shifts each result by an immediate value, puts the final result into a vector, and writes the vector to the lower or upper half of the destination SIMD&amp;FP register. All the values in this instruction are unsigned integer values. The results are rounded. For truncated results, see UQSHRN."
  },
  {
    "name": "UQRSHRN2",
    "doc": "Unsigned saturating Rounded Shift Right Narrow (immediate). This instruction reads each vector element in the source SIMD&amp;FP register, right shifts each result by an immediate value, puts the final result into a vector, and writes the vector to the lower or upper half of the destination SIMD&amp;FP register. All the values in this instruction are unsigned integer values. The results are rounded. For truncated results, see UQSHRN."
  },
  {
    "name": "UQRSHR",
    "doc": "Multi-vector unsigned saturating rounding shift right narrow by immediate"
  },
  {
    "name": "UQSHLR",
    "doc": "Unsigned saturating shift left reversed vectors (predicated)"
  },
  {
    "name": "UQSHL",
    "doc": "Unsigned saturating Shift Left (immediate). This instruction takes each vector element in the source SIMD&amp;FP register, shifts it by an immediate value, places the results in a vector, and writes the vector to the destination SIMD&amp;FP register. The results are truncated. For rounded results, see UQRSHL."
  },
  {
    "name": "UQSHRNB",
    "doc": "Unsigned saturating shift right narrow by immediate (bottom)"
  },
  {
    "name": "UQSHRNT",
    "doc": "Unsigned saturating shift right narrow by immediate (top)"
  },
  {
    "name": "UQSHRN",
    "doc": "Unsigned saturating Shift Right Narrow (immediate). This instruction reads each vector element in the source SIMD&amp;FP register, right shifts each result by an immediate value, saturates each shifted result to a value that is half the original width, puts the final result into a vector, and writes the vector to the lower or upper half of the destination SIMD&amp;FP register. All the values in this instruction are unsigned integer values. The results are truncated. For rounded results, see UQRSHRN."
  },
  {
    "name": "UQSHRN2",
    "doc": "Unsigned saturating Shift Right Narrow (immediate). This instruction reads each vector element in the source SIMD&amp;FP register, right shifts each result by an immediate value, saturates each shifted result to a value that is half the original width, puts the final result into a vector, and writes the vector to the lower or upper half of the destination SIMD&amp;FP register. All the values in this instruction are unsigned integer values. The results are truncated. For rounded results, see UQRSHRN."
  },
  {
    "name": "UQSUBR",
    "doc": "Unsigned saturating subtraction reversed vectors (predicated)"
  },
  {
    "name": "UQSUB",
    "doc": "Unsigned saturating Subtract. This instruction subtracts the element values of the second source SIMD&amp;FP register from the corresponding element values of the first source SIMD&amp;FP register, places the results into a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "UQXTNB",
    "doc": "Unsigned saturating extract narrow (bottom)"
  },
  {
    "name": "UQXTNT",
    "doc": "Unsigned saturating extract narrow (top)"
  },
  {
    "name": "UQXTN",
    "doc": "Unsigned saturating extract Narrow. This instruction reads each vector element from the source SIMD&amp;FP register, saturates each value to half the original width, places the result into a vector, and writes the vector to the destination SIMD&amp;FP register. All the values in this instruction are unsigned integer values."
  },
  {
    "name": "UQXTN2",
    "doc": "Unsigned saturating extract Narrow. This instruction reads each vector element from the source SIMD&amp;FP register, saturates each value to half the original width, places the result into a vector, and writes the vector to the destination SIMD&amp;FP register. All the values in this instruction are unsigned integer values."
  },
  {
    "name": "URECPE",
    "doc": "Unsigned Reciprocal Estimate. This instruction reads each vector element from the source SIMD&amp;FP register, calculates an approximate inverse for the unsigned integer value, places the result into a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "URHADD",
    "doc": "Unsigned Rounding Halving Add. This instruction adds corresponding unsigned integer values from the two source SIMD&amp;FP registers, shifts each result right one bit, places the results into a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "URSHLR",
    "doc": "Unsigned rounding shift left reversed vectors (predicated)"
  },
  {
    "name": "URSHL",
    "doc": "Unsigned Rounding Shift Left (register). This instruction takes each element in the vector of the first source SIMD&amp;FP register, shifts the vector element by a value from the least significant byte of the corresponding element of the second source SIMD&amp;FP register, places the results in a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "URSHR",
    "doc": "Unsigned Rounding Shift Right (immediate). This instruction reads each vector element in the source SIMD&amp;FP register, right shifts each result by an immediate value, writes the final result to a vector, and writes the vector to the destination SIMD&amp;FP register. All the values in this instruction are unsigned integer values. The results are rounded. For truncated results, see USHR."
  },
  {
    "name": "URSQRTE",
    "doc": "Unsigned Reciprocal Square Root Estimate. This instruction reads each vector element from the source SIMD&amp;FP register, calculates an approximate inverse square root for each value, places the result into a vector, and writes the vector to the destination SIMD&amp;FP register. All the values in this instruction are unsigned integer values."
  },
  {
    "name": "URSRA",
    "doc": "Unsigned Rounding Shift Right and Accumulate (immediate). This instruction reads each vector element in the source SIMD&amp;FP register, right shifts each result by an immediate value, and accumulates the final results with the vector elements of the destination SIMD&amp;FP register. All the values in this instruction are unsigned integer values. The results are rounded. For truncated results, see USRA."
  },
  {
    "name": "USDOT",
    "doc": "Dot Product index form with unsigned and signed integers. This instruction performs the dot product of the four unsigned 8-bit integer values in each 32-bit element of the first source register with the four signed 8-bit integer values in an indexed 32-bit element of the second source register, accumulating the result into the corresponding 32-bit element of the destination register."
  },
  {
    "name": "USHLLB",
    "doc": "Unsigned shift left long by immediate (bottom)"
  },
  {
    "name": "USHLLT",
    "doc": "Unsigned shift left long by immediate (top)"
  },
  {
    "name": "USHLL",
    "doc": "Unsigned Shift Left Long (immediate). This instruction reads each vector element in the lower or upper half of the source SIMD&amp;FP register, shifts the unsigned integer value left by the specified number of bits, places the result into a vector, and writes the vector to the destination SIMD&amp;FP register. The destination vector elements are twice as long as the source vector elements."
  },
  {
    "name": "USHLL2",
    "doc": "Unsigned Shift Left Long (immediate). This instruction reads each vector element in the lower or upper half of the source SIMD&amp;FP register, shifts the unsigned integer value left by the specified number of bits, places the result into a vector, and writes the vector to the destination SIMD&amp;FP register. The destination vector elements are twice as long as the source vector elements."
  },
  {
    "name": "USHL",
    "doc": "Unsigned Shift Left (register). This instruction takes each element in the vector of the first source SIMD&amp;FP register, shifts each element by a value from the least significant byte of the corresponding element of the second source SIMD&amp;FP register, places the results in a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "USHR",
    "doc": "Unsigned Shift Right (immediate). This instruction reads each vector element in the source SIMD&amp;FP register, right shifts each result by an immediate value, writes the final result to a vector, and writes the vector to the destination SIMD&amp;FP register. All the values in this instruction are unsigned integer values. The results are truncated. For rounded results, see URSHR."
  },
  {
    "name": "USMLALL",
    "doc": "Multi-vector unsigned by signed integer multiply-add long-long by indexed element"
  },
  {
    "name": "USMMLA",
    "doc": "Unsigned and signed 8-bit integer matrix multiply-accumulate. This instruction multiplies the 2x8 matrix of unsigned 8-bit integer values in the first source vector by the 8x2 matrix of signed 8-bit integer values in the second source vector. The resulting 2x2 32-bit integer matrix product is destructively added to the 32-bit integer matrix accumulator in the destination vector. This is equivalent to performing an 8-way dot product per destination element."
  },
  {
    "name": "USMOPA",
    "doc": "Unsigned by signed integer sum of outer products and accumulate"
  },
  {
    "name": "USMOPS",
    "doc": "Unsigned by signed integer sum of outer products and subtract"
  },
  {
    "name": "USQADD",
    "doc": "Unsigned saturating Accumulate of Signed value. This instruction adds the signed integer values of the vector elements in the source SIMD&amp;FP register to corresponding unsigned integer values of the vector elements in the destination SIMD&amp;FP register, and accumulates the resulting unsigned integer values with the vector elements of the destination SIMD&amp;FP register."
  },
  {
    "name": "USRA",
    "doc": "Unsigned Shift Right and Accumulate (immediate). This instruction reads each vector element in the source SIMD&amp;FP register, right shifts each result by an immediate value, and accumulates the final results with the vector elements of the destination SIMD&amp;FP register. All the values in this instruction are unsigned integer values. The results are truncated. For rounded results, see URSRA."
  },
  {
    "name": "USUBLB",
    "doc": "Unsigned subtract long (bottom)"
  },
  {
    "name": "USUBLT",
    "doc": "Unsigned subtract long (top)"
  },
  {
    "name": "USUBL",
    "doc": "Unsigned Subtract Long. This instruction subtracts each vector element in the lower or upper half of the second source SIMD&amp;FP register from the corresponding vector element of the first source SIMD&amp;FP register, places the result into a vector, and writes the vector to the destination SIMD&amp;FP register. All the values in this instruction are unsigned integer values. The destination vector elements are twice as long as the source vector elements."
  },
  {
    "name": "USUBL2",
    "doc": "Unsigned Subtract Long. This instruction subtracts each vector element in the lower or upper half of the second source SIMD&amp;FP register from the corresponding vector element of the first source SIMD&amp;FP register, places the result into a vector, and writes the vector to the destination SIMD&amp;FP register. All the values in this instruction are unsigned integer values. The destination vector elements are twice as long as the source vector elements."
  },
  {
    "name": "USUBWB",
    "doc": "Unsigned subtract wide (bottom)"
  },
  {
    "name": "USUBWT",
    "doc": "Unsigned subtract wide (top)"
  },
  {
    "name": "USUBW",
    "doc": "Unsigned Subtract Wide. This instruction subtracts each vector element of the second source SIMD&amp;FP register from the corresponding vector element in the lower or upper half of the first source SIMD&amp;FP register, places the result in a vector, and writes the vector to the SIMD&amp;FP destination register. All the values in this instruction are unsigned integer values."
  },
  {
    "name": "USUBW2",
    "doc": "Unsigned Subtract Wide. This instruction subtracts each vector element of the second source SIMD&amp;FP register from the corresponding vector element in the lower or upper half of the first source SIMD&amp;FP register, places the result in a vector, and writes the vector to the SIMD&amp;FP destination register. All the values in this instruction are unsigned integer values."
  },
  {
    "name": "USVDOT",
    "doc": "Multi-vector unsigned by signed integer vertical dot-product by indexed element"
  },
  {
    "name": "UUNPKHI",
    "doc": "Unsigned unpack and extend half of vector"
  },
  {
    "name": "UUNPKLO",
    "doc": "Unsigned unpack and extend half of vector"
  },
  {
    "name": "UUNPK",
    "doc": "Unpack and zero-extend multi-vector elements"
  },
  {
    "name": "UVDOT",
    "doc": "Multi-vector unsigned integer vertical dot-product by indexed element"
  },
  {
    "name": "UXTB",
    "doc": "Unsigned Extend Byte extracts an 8-bit value from a register, zero-extends it to the size of the register, and writes the result to the destination register."
  },
  {
    "name": "UXTH",
    "doc": "Unsigned byte / halfword / word extend (predicated)"
  },
  {
    "name": "UXTW",
    "doc": "Unsigned byte / halfword / word extend (predicated)"
  },
  {
    "name": "UXTL",
    "doc": "Unsigned extend Long. This instruction copies each vector element from the lower or upper half of the source SIMD&amp;FP register into a vector, and writes the vector to the destination SIMD&amp;FP register. The destination vector elements are twice as long as the source vector elements."
  },
  {
    "name": "UXTL2",
    "doc": "Unsigned extend Long. This instruction copies each vector element from the lower or upper half of the source SIMD&amp;FP register into a vector, and writes the vector to the destination SIMD&amp;FP register. The destination vector elements are twice as long as the source vector elements."
  },
  {
    "name": "UZP1",
    "doc": "Unzip vectors (primary). This instruction reads corresponding even-numbered vector elements from the two source SIMD&amp;FP registers, starting at zero, places the result from the first source register into consecutive elements in the lower half of a vector, and the result from the second source register into consecutive elements in the upper half of a vector, and writes the vector to the destination SIMD&amp;FP register."
  },
  {
    "name": "UZP2",
    "doc": "Concatenate even or odd elements from two predicates"
  },
  {
    "name": "UZPQ1",
    "doc": "Concatenate even elements within each pair of quadword vector segments"
  },
  {
    "name": "UZPQ2",
    "doc": "Concatenate odd elements within each pair of quadword vector segments"
  },
  {
    "name": "UZP",
    "doc": "Concatenate elements from four vectors"
  },
  {
    "name": "WFE",
    "doc": "Wait For Event is a hint instruction that indicates that the PE can enter a low-power state and remain there until a wakeup event occurs. Wakeup events include the event signaled as a result of executing the SEV instruction on any PE in the multiprocessor system. For more information, see Wait For Event mechanism and Send event."
  },
  {
    "name": "WFET",
    "doc": "Wait For Event with Timeout is a hint instruction that indicates that the PE can enter a low-power state and remain there until either a local timeout event or a wakeup event occurs. Wakeup events include the event signaled as a result of executing the SEV instruction on any PE in the multiprocessor system. For more information, see Wait For Event mechanism and Send event."
  },
  {
    "name": "WFI",
    "doc": "Wait For Interrupt is a hint instruction that indicates that the PE can enter a low-power state and remain there until a wakeup event occurs. For more information, see Wait For Interrupt."
  },
  {
    "name": "WFIT",
    "doc": "Wait For Interrupt with Timeout is a hint instruction that indicates that the PE can enter a low-power state and remain there until either a local timeout event or a wakeup event occurs. For more information, see Wait For Interrupt."
  },
  {
    "name": "WHILEGE",
    "doc": "While decrementing signed scalar greater than or equal to scalar (predicate-as-counter)"
  },
  {
    "name": "WHILEGT",
    "doc": "While decrementing signed scalar greater than scalar (predicate-as-counter)"
  },
  {
    "name": "WHILEHI",
    "doc": "While decrementing unsigned scalar higher than scalar (predicate-as-counter)"
  },
  {
    "name": "WHILEHS",
    "doc": "While decrementing unsigned scalar higher or same as scalar (predicate-as-counter)"
  },
  {
    "name": "WHILELE",
    "doc": "While incrementing signed scalar less than or equal to scalar (predicate-as-counter)"
  },
  {
    "name": "WHILELO",
    "doc": "While incrementing unsigned scalar lower than scalar (predicate-as-counter)"
  },
  {
    "name": "WHILELS",
    "doc": "While incrementing unsigned scalar lower or same as scalar (predicate-as-counter)"
  },
  {
    "name": "WHILELT",
    "doc": "While incrementing signed scalar less than scalar (predicate-as-counter)"
  },
  {
    "name": "WHILERW",
    "doc": "While free of read-after-write conflicts"
  },
  {
    "name": "WHILEWR",
    "doc": "While free of write-after-read/write conflicts"
  },
  {
    "name": "WRFFR",
    "doc": "Write the first-fault register"
  },
  {
    "name": "XAFLAG",
    "doc": "Convert floating-point condition flags from external format to Arm format. This instruction converts the state of the PSTATE.{N,Z,C,V} flags from an alternative representation required by some software to a form representing the result of an Arm floating-point scalar compare instruction."
  },
  {
    "name": "XAR",
    "doc": "Exclusive-OR and Rotate performs a bitwise exclusive-OR of the 128-bit vectors in the two source SIMD&amp;FP registers, rotates each 64-bit element of the resulting 128-bit vector right by the value specified by a 6-bit immediate value, and writes the result to the destination SIMD&amp;FP register."
  },
  {
    "name": "XPACD",
    "doc": "Strip Pointer Authentication Code. This instruction removes the pointer authentication code from an address. The address is in the specified general-purpose register for XPACI and XPACD, and is in LR for XPACLRI."
  },
  {
    "name": "XPACI",
    "doc": "Strip Pointer Authentication Code. This instruction removes the pointer authentication code from an address. The address is in the specified general-purpose register for XPACI and XPACD, and is in LR for XPACLRI."
  },
  {
    "name": "XPACLRI",
    "doc": "Strip Pointer Authentication Code. This instruction removes the pointer authentication code from an address. The address is in the specified general-purpose register for XPACI and XPACD, and is in LR for XPACLRI."
  },
  {
    "name": "XTN",
    "doc": "Extract Narrow. This instruction reads each vector element from the source SIMD&amp;FP register, narrows each value to half the original width, places the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&amp;FP register. The destination vector elements are half as long as the source vector elements."
  },
  {
    "name": "XTN2",
    "doc": "Extract Narrow. This instruction reads each vector element from the source SIMD&amp;FP register, narrows each value to half the original width, places the result into a vector, and writes the vector to the lower or upper half of the destination SIMD&amp;FP register. The destination vector elements are half as long as the source vector elements."
  },
  {
    "name": "YIELD",
    "doc": "YIELD is a hint instruction. Software with a multithreading capability can use a YIELD instruction to indicate to the PE that it is performing a task, for example a spin-lock, that could be swapped out to improve overall system performance. The PE can use this hint to suspend and resume multiple software threads if it supports the capability."
  },
  {
    "name": "ZERO",
    "doc": "Zero ZA single-vector groups"
  },
  {
    "name": "ZIP1",
    "doc": "Zip vectors (primary). This instruction reads adjacent vector elements from the lower half of two source SIMD&amp;FP registers as pairs, interleaves the pairs and places them into a vector, and writes the vector to the destination SIMD&amp;FP register. The first pair from the first source register is placed into the two lowest vector elements, with subsequent pairs taken alternately from each source register."
  },
  {
    "name": "ZIP2",
    "doc": "Interleave elements from two half predicates"
  },
  {
    "name": "ZIPQ1",
    "doc": "Interleave elements from low halves of each pair of quadword vector segments"
  },
  {
    "name": "ZIPQ2",
    "doc": "Interleave elements from high halves of each pair of quadword vector segments"
  },
  {
    "name": "ZIP",
    "doc": "Interleave elements from four vectors"
  }
]